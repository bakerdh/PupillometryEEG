---
title: "Different rules for binocular combination of luminance flicker in cortical and subcortical pathways"
author: |
 | Federico G. Segala, Aurelio Bruno, Joel T. Martin, 
 | Myat T. Aung, Alex R. Wade & Daniel H. Baker
 | Department of Psychology, University of York, UK
 | *eLife* (2023) https://doi.org/10.7554/eLife.87048
output:
  bookdown::pdf_document2:
    fig_caption: yes
    toc: no
    keep_tex: yes
  word_document2: default
  html_document: default
bibliography: references.bib
link-citations: true
csl: elife.csl
header-includes:
- \usepackage{float}
- \usepackage{float} \floatplacement{figure}{H}
- \newcommand{\beginsupplement}{\setcounter{table}{0}
- \renewcommand{\thetable}{A\arabic{table}}
- \setcounter{figure}{0}
- \renewcommand{\thefigure}{A\arabic{figure}}}
- \usepackage{caption}
---

```{r setup, include=FALSE}

processdata <- 1  # this flag determines the amount of processing, with 4 levels:
# 0 - do no processing, generate the pdf using existing versions of all figures
# 1 - generate figures using the processed group data
# 2 - average data across participants, do bootstrapping
# 3 - download all raw data and analyse (requires 48GB of storage)
cleanupraw <- 0  # if downloading raw data, delete once processed to save space

domodelling <- 0    # if set to 1, run the Stan models (takes ~24 hours)

# cut off for data inclusion (Mahalanobis distance for complex data)
SDthresh <<- 3
nbootstraps <<- 1000

# check which packages are installed, install the missing ones, and activate
packagelist <- c('knitr','remotes','tictoc','R.matlab','bookdown','grImport','png','tiff','pals','ez','gtools','signal','boot','quickpsy','rstan','rstatix','coda','parallel','utils','osfr') # list of CRAN packages
missingpackages <- packagelist[!packagelist %in% installed.packages()[,1]]
if (length(missingpackages)>0){install.packages(missingpackages)}
if (!'FourierStats' %in% installed.packages()[,1]){remotes::install_github("bakerdh/FourierStats")}
packagelist <- c(packagelist,'FourierStats')
toinstall <- packagelist[which(!packagelist %in% (.packages()))]
invisible(lapply(toinstall,library,character.only=TRUE))

knitr::opts_chunk$set(echo = TRUE)

# settings for sampler 
numSavedSteps <- 100000    # total number of MCMC steps
adaptSteps <- 1000  # Number of steps to "tune" the samplers
burnInSteps <- 2000 
thinSteps <- 10
nChains <- 16
ncores <- 8  # because of multi-threading, this is usually double the true number of physical cores, so we halve the number as Stan can only use physical cores
options(mc.cores=ncores)

# helper function to make colours transparent
addalpha <- function(col, alpha=1){apply(sapply(col, col2rgb)/255, 2, function(x) rgb(x[1], x[2], x[3], alpha=alpha))}

v4Interp <- function(df, xo, yo, rmax = .75, gridRes = 67) {
  ## Create a function to perform Matlab's v4 interpolation.
  ## Takes as input a data-frame with columns x, y, and z (x co-ordinates, y co-ordinates, and amplitude)
  ## and variables xo and yo, the co-ordinates which will be use to create a grid for interpolation
  xo <- matrix(rep(xo,length(yo)),nrow = length(xo),ncol = length(yo))
  yo <- t(matrix(rep(yo,length(xo)),nrow = length(yo),ncol = length(xo)))
  xy <- df$x + df$y*sqrt(as.complex(-1))
  d <- matrix(rep(xy,length(xy)),nrow = length(xy), ncol = length(xy))
  d <- abs(d - t(d))
  diag(d) <- 1
  g <- (d^2) * (log(d)-1)   # Green's function.
  diag(g) <- 0
  weights <- qr.solve(g,df$z)
  xy <- t(xy)
  outmat <- matrix(nrow = gridRes,ncol = gridRes)
  for (i in 1:gridRes){
    for (j in 1:gridRes) {
      test4 <- abs((xo[i,j] + sqrt(as.complex(-1))*yo[i,j]) - xy)
      g <- (test4^2) * (log(test4)-1)
      outmat[i,j] <- g %*% weights}}
  outDf <- data.frame(x = xo[,1],outmat)
  names(outDf)[1:length(yo[1,])+1] <- yo[1,]
  return(outDf)}

anovacirc2way <- function(data, groupA=NULL, groupB=NULL, participant=NULL){
  
  grouplabelsA <- groupA
  grouplabelsB <- groupB
  participantlabels <- participant
  datavals <- data

  grouplabelsA <- as.factor(grouplabelsA)
  factorlistA <- levels(grouplabelsA)
  grouplabelsB <- as.factor(grouplabelsB)
  factorlistB <- levels(grouplabelsB)
  participantlabels <- as.factor(participantlabels)
  participantlist <- levels(participantlabels)
  
  grandmean <- mean(datavals)
  grandvar <- sum(abs(datavals - grandmean)^2)/(length(datavals)-1)
  
    SST <- grandvar*(length(datavals) - 1)
    
    SSW <- 0
    for (n in 1:nlevels(participantlabels)){SSW <- SSW + sum(abs(datavals[which(participantlabels==participantlist[n])] - mean(datavals[which(participantlabels==participantlist[n])]))^2)}
    dfW <- 2*(nlevels(participantlabels)*(nlevels(grouplabelsA)*nlevels(grouplabelsB)-1))
    
    SSBet <- SST - SSW  # between subjects SS - not actually used
    SSM <- 0
    for (a in 1:nlevels(grouplabelsA)){
      for (b in 1:nlevels(grouplabelsB)){
        i <- as.numeric(((grouplabelsA==grouplabelsA[a])))
        j <- as.numeric(((grouplabelsB==grouplabelsB[b])))
        indices <- which((i*j)>0)
        SSM <- SSM + (nlevels(participantlabels)*sum(abs(datavals[indices] - grandmean)^2))
      }
    }
    dfM <- 2*((nlevels(grouplabelsA)*nlevels(grouplabelsB))-1)
    
    SSR <- 0
    for (a in 1:nlevels(grouplabelsA)){
      for (b in 1:nlevels(grouplabelsB)){
        i <- as.numeric(((grouplabelsA==grouplabelsA[a])))
        j <- as.numeric(((grouplabelsB==grouplabelsB[b])))
        indices <- which((i*j)>0)
        condvar <- sum(abs(datavals[indices] - mean(datavals[indices]))^2)/(length(indices)-1)
        SSR <- SSR + (nlevels(participantlabels)-1)*condvar
      }
    }    
    dfR <- 2*(nlevels(participantlabels)-1)*(nlevels(grouplabelsA)*nlevels(grouplabelsB))
    
    groupmeansA <- NULL
    for (n in 1:nlevels(grouplabelsA)){groupmeansA[n] <- mean(datavals[which(grouplabelsA==factorlistA[n])])}
    SSA <- 0
    for (n in 1:nlevels(grouplabelsA)){SSA <- SSA + length(which(grouplabelsA==factorlistA[n]))*abs(groupmeansA[n]-grandmean)^2}
    dfA <- 2*(nlevels(grouplabelsA)-1)
    
    groupmeansB <- NULL
    for (n in 1:nlevels(grouplabelsB)){groupmeansB[n] <- mean(datavals[which(grouplabelsB==factorlistB[n])])}
    SSB <- 0
    for (n in 1:nlevels(grouplabelsB)){SSB <- SSB + length(which(grouplabelsB==factorlistB[n]))*abs(groupmeansB[n]-grandmean)^2}
    dfB <- 2*(nlevels(grouplabelsB)-1)
    
    SSAB <- SSW - (SSA + SSB)
    dfAB <- 2 * (nlevels(grouplabelsA)-1) * (nlevels(grouplabelsB)-1)
    
    MSA <- SSA/dfA
    MSB <- SSB/dfB
    MSAB <- SSAB/dfAB
    MSR <- SSR/dfR
    
    FratioA <- MSA/MSR
    pvalA <- pf(FratioA,df1=dfA,df2=dfR,lower.tail=FALSE)
    FratioB <- MSB/MSR
    pvalB <- pf(FratioB,df1=dfB,df2=dfR,lower.tail=FALSE)
    FratioAB <- MSAB/MSR
    pvalAB <- pf(FratioAB,df1=dfAB,df2=dfR,lower.tail=FALSE)
    
    method <- 'Factorial repeated measures ANOVA^2-circ'
    output <- data.frame(FratioA,pvalA,FratioB,pvalB,FratioAB,pvalAB,dfA,dfB,dfAB,dfR,method)
  
  return(output)
}

cleanup2D <- function(data){
  # helper function to clean up complex data by removing any data points more than 
  # SDthresh standard deviations from the mean (in Mahalanobis distance units)
  cartdata <- data.frame(Re(data),Im(data))
  output <- 0
  if (sum(cartdata)!=0){
    D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
    i <- which(D<SDthresh) 
    output <- mean(temp[i])}
return(output)}

bootstrap2D <- function(data){
  mbs <- data.frame(meanamp=0,lowerCI=0,upperCI=0)
    cartdata <- data.frame(Re(data),Im(data))
    if (sum(cartdata)!=0){
      D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
      i <- which(D<SDthresh) 
    mbs <- amperrors(data[i],method='boot',quantiles=68,nresamples=nbootstraps)}
return(mbs)}

colpal <- c('#FE5000','#8783CF','#228B22','#808080','#6d008b','#8B8000')
targetelectrodes <- c('Oz','POz','O1','O2')

localdir <- 'local/'    # all files are stored in the project directory /local/ which git is told to ignore
if (!file.exists(localdir)){dir.create(localdir)}   # create a local directory to store data and outputs
rawdir <- 'local/rawdata/'
if (!file.exists(rawdir)){dir.create(rawdir)}   # create a local directory to store raw data
figdir <- 'Figures/'
if (!file.exists(figdir)){dir.create(figdir)}   # create a local directory to store figures
datadir <- 'local/processeddata/'
if (!file.exists(datadir)){dir.create(datadir)}   # create a local directory to store processed data

if (processdata>0){
if (!file.exists(paste0(datadir,'headerfile.csv'))){
# copy from resources folder
file.copy('resources/headerfile.csv',paste0(datadir,'headerfile.csv'))
} 
if (!file.exists(paste0(localdir,'StimulusExample.png'))){
# copy from resources folder
file.copy('resources/StimulusExample.png',paste0(localdir,'StimulusExample.png'))
}
}

if (processdata==2){
# if we're going to need the pre-processed files, extract from zip file
  if (!file.exists(paste0(datadir,'P101summary.RData'))){
   if (file.exists('resources/allprocessed.zip')){file.copy('resources/allprocessed.zip',localdir)}
   if (!file.exists('resources/allprocessed.zip')){ 
          osfnode <- '2qu6y'
          osfproject <- osf_retrieve_node(osfnode)
          osffiles <- osf_ls_files(osfproject,n_max=300)
          fid <- which(osffiles$name=='allprocessed.zip')
          osf_download(osffiles[fid,],localdir,progress=TRUE)
   }
          unzip(paste0(localdir,'allprocessed.zip'),exdir=localdir)
          d <- dir(paste0(localdir,'allprocessed'),full.names=TRUE)
          file.copy(d,datadir)
  }
}


```

# Abstract

How does the brain combine information across the eyes? In primary visual cortex, spatial patterns are subject to 'ocularity invariance', where monocular and binocular responses are rendered equal by mutual suppression between the eyes. Here we asked whether this invariance holds for pure changes in luminance. We collected steady-state EEG and pupillometry data simultaneously, and find strong deviations from ocularity invariance both in the cortex and also in the subcortical pathway that determines pupil diameter. In cortex, we find strong binocular facilitation, and negligible interocular suppression from cortical sources, whereas measurements of pupil diameter showed weaker facilitation and stronger suppression. This was not purely a consequence of the temporal stimulus parameters; pronounced binocular facilitation was also observed at faster flicker rates. Near-linear binocular combination was also found for the same stimuli using a perceptual matching task. A hierarchical Bayesian implementation of a standard binocular combination model confirms that interocular suppression was substantially weaker for our EEG and matching data compared with the pupillometry results. These findings illustrate that ocularity invariance is not a ubiquitous feature of visual processing, and that the brain can repurpose a generic algorithm for different functions by adjusting parameters such as the weight of suppression between pathways.

# Introduction

The brain must combine information across multiple sensory inputs to derive a coherent percept of the external world. This involves a process of signal combination both within [@Baker2017] and between [@Ernst2002] the senses. Binocular vision is a useful test case for signal combination, as the inputs to the two eyes overlap substantially (in species with forward-facing eyes), and the neural locus is well-established [@Hubel1962]. Much of our knowledge about binocular combination derives from studies on the contrast response of the 'canonical' visual pathway, in which signals pass from the eyes to primary visual cortex (V1), via the lateral geniculate nucleus (LGN) [@Purves2008]. However, signals are also combined across the eyes in the network of subcortical nuclei that govern pupil diameter in response to absolute light levels [@McDougal2008] and much less is known about the computations that operate in these subcortical pathways. Our primary purpose here is to investigate the computations governing signal combination in these two anatomically distinct pathways in response to luminance changes.

For pattern vision, binocular presentation confers greater sensitivity to low contrast targets than monocular presentation. This is known as binocular summation, with summation ratios (the relative improvement under binocular presentation) at detection threshold lying between $\sqrt{2}$ and 2 [@Campbell1965; @Baker2018]. This advantage is lost at high stimulus contrasts, where both psychophysical performance (contrast discrimination thresholds) [@Legge1984; @Meese2006] and neural activity [@Moradi2009; @Baker2017] are approximately equal for monocular and binocular presentation. Contemporary models of binocular vision [@Ding2006; @Meese2006] advocate a process of interocular suppression that normalizes the two eyes' inputs at high contrasts and negates the binocular advantage. This is consistent with our everyday experience of 'ocularity invariance' [@Baker2007]: perceived contrast does not change when one eye is opened and closed.

The pupillary light reflex is an automatic constriction of the iris sphincter muscles in response to increases in light levels, which causes the pupil to shrink [@McDougal2008]. There is a clear binocular component to this reflex, as stimulation of one eye still causes constriction of the other eye's pupil (termed the consensual response; @Wyatt1981). Importantly, the neuroanatomical pathway involved completely bypasses the canonical cortical pathway (retina to V1), instead involving a network of subcortical nuclei, including the Pretectal Olivary nucleus, Superior Cervical ganglion, and Edinger-Westphal nucleus [@Angee2021; @Mathot2018; @McDougal2008; @Wang2015]. To account for the consensual response, these brain regions must combine information from the left and right eyes [@Doesschate1967], yet the computation that achieves this is achieved is unclear. The pupil response can be modulated by periodic changes in luminance, and is temporally low-pass [@Barrionuevo2014; @Spitschan2014], most likely due to the mechanical limitations of the iris sphincter and dilator muscles. 

To investigate the binocular combination of light, we designed an experiment that allowed us to simultaneously record electrophysiological and pupillometric responses to monocular and binocular stimuli. We chose a primary flicker frequency of 2Hz as a compromise between the low-pass pupil response [see @Barrionuevo2014; @Spitschan2014], and the relatively higher-pass EEG response [@Regan1966]. This novel paradigm allowed us to probe both cortical (using EEG) and subcortical (using a binocular eyetracker) pathways simultaneously in response to flickering light, and make quantitative comparisons between them. Periodic flicker entrains both neural [@Norcia2015] and pupil [@Spitschan2014] responses at the flicker frequency, enabling precise estimation of response amplitudes in the Fourier domain. Relative to the response to a monocular signal, adding a signal in the other eye can either increase the response (facilitation) or reduce it (suppression). We followed up our main experiment with additional exploration of the effect of stimulus frequency, and a psychophysical matching experiment measuring perceived flicker intensity (i.e. temporal contrast). The results are interpreted using a hierarchical Bayesian computational model of binocular vision, and reveal that subcortical pathways implement stronger interocular suppression than the canonical cortical pathway.

# Methods

## Participants

Thirty (20 females), twelve (7 females) and ten (3 females) adult participants, whose ages ranged from 18 to 45, were recruited for Experiments 1, 2 and 3 respectively. All participants had normal or corrected to normal binocular vision, and gave written informed consent. Our procedures were approved by the Ethics Committee of the Department of Psychology at the University of York (identification number 792).

## Apparatus & stimuli

```{r createmethodsfig, include=FALSE, results='hide'}

if (processdata>0){
  
           if (!file.exists(paste0(localdir,'StimulusExample.png'))){
           # download it from OSF
           if (!exists('osffiles')){
           osfnode <- 'tbema'
           osfproject <- osf_retrieve_node(osfnode)
          osffiles <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffiles$name=='StimulusExample.png')
          osf_download(osffiles[fid,],localdir,progress=TRUE)
         } 

stim <- readPNG('local/StimulusExample.png')


pdf("Figures/methodsfig.pdf", bg="transparent", height = 8, width = 8)

contlist <- c(0.06,0.12,0.24,0.48,0.96)
amp <- 0.5
t <- seq(0,1,length=100)
sinetarget <- sin(2 * t * 2*pi)*amp
sinemask <- sin(1.6 * t * 2*pi)*amp

colpal <- c('#FE5000','#8783CF','#228B22','#808080','#6d008b','#8B8000')
symbollist <- c(21:23,21,24,25)
ramp <- colorRamp(c("white", "black"))  # create a ramp from one colour to another
greypal <- rgb(ramp(seq(0, 1, length = 5)), max = 255)   # index the ramp at ten points

plotlims <- c(0.5,4.1,0.5,7)  # define the x and y limits of the plot (minx,maxx,miny,maxy)

par(mar=c(0.1,0.1,0.1,0.1))
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions

condlabels <- c('Monocular','Binocular','Dichoptic','Monocular cross','Binocular cross','Dichoptic cross')
text(1.2,6:1,condlabels,pos=2,cex=1.2)

text(c(2,3.5),7,c('Left eye','Right eye'),cex=1.6)

points(rep(1.3,6),6:1, pch=symbollist, bg=colpal, cex=1.6, lwd=3)

for (cont in 5:1){
  
  polygon(c(0,t,t[100])+1.5, c(0,sinetarget*contlist[cont],0) + 6, col=greypal[cont], border=NA)
  polygon(c(0,t,t[100])+1.5, c(0,sinetarget*contlist[cont],0) + 5, col=greypal[cont], border=NA)
  polygon(c(0,t,t[100])+1.5, c(0,sinetarget*contlist[cont],0) + 4, col=greypal[cont], border=NA)
  polygon(c(0,t,t[100])+1.5, c(0,sinetarget*contlist[cont],0) + 2, col=greypal[cont], border=NA)
  polygon(c(0,t,t[100])+1.5, c(0,sinetarget*contlist[cont],0) + 1, col=greypal[cont], border=NA)

  polygon(c(0,t,t[100])+3, c(0,sinetarget*contlist[cont],0) + 5, col=greypal[cont], border=NA)
  polygon(c(0,t,t[100])+3, c(0,sinemask*contlist[cont],0) + 3, col=greypal[cont], border=NA)
  polygon(c(0,t,t[100])+3, c(0,sinemask*contlist[cont],0) + 2, col=greypal[cont], border=NA)
  
}

for (cond in 1:6){lines(c(1.5,2.5),c(cond,cond),lty=2)}
for (cond in 1:6){lines(c(3,4),c(cond,cond),lty=2)}

lines(t+3, sinetarget*0.48 + 4, lwd=2)
lines(t+3, sinemask*0.48 + 1, lwd=2)

lines(t+3, sinetarget*0 + 6, lwd=2)
lines(t+1.5, sinetarget*0 + 3, lwd=2)

text(2.6,c(1,2,4,5,6),'2Hz',srt=270)
text(4.1,c(4,5),'2Hz',srt=270)
text(4.1,c(1,2,3),'1.6Hz',srt=270)

text(2.6,3,'Mean',srt=270)
text(4.1,6,'Mean',srt=270)

imwidth <- 0.5
xstart <- 0.4
ystart <- 6.2
rasterImage(stim,xstart,ystart,xstart+imwidth,ystart+imwidth*1.9) 

dev.off()

}

```

The stimuli were two discs of achromatic flickering light with a diameter of 3.74 degrees, presented on a black background. The same stimuli were used for all three experiments. Four dark red lines were added around both discs to help with their perceptual fusion, giving the appearance of a single binocular disc (see upper left insert in Figure \@ref(fig:methodsfig) for an example of the fused stimulus). The discs were viewed through a four-mirror stereoscope, which used front silvered mirrors to avoid internal reflections, and meant that participants saw a single fused disc. The use of a stereoscope allowed us to modulate the stimuli in three different ocular configurations: monocular, binocular, and dichoptic. Note that during monocular presentation of flicker, the unstimulated eye still saw the static (non-flickering) disc of mean luminance.

All stimuli had a mean luminance of 42 cd/m$^2$ and were displayed on an Iiyama VisionMasterâ„¢ Pro 510 display (800 x 600 pixels, 60 Hz refresh rate), which was gamma corrected using a Minolta LS-110 photometer (Minolta Camera Co. Ltd., Japan). For experiments 1 and 2, the stimuli were presented using Psychopy (v3.0.7). For experiment 3, the stimuli were presented using Psychopy (v2022.1.1).

EEG data were collected for Experiments 1 and 2 using a 64-electrode ANT WaveGuard cap and the signals were recorded at 1 kHz using the ASA software (ANT Neuro, Netherlands). Pupillometry data were collected for Experiment 1 using a binocular Pupil Core eye-tracker [Pupil Labs GmbH, Berlin, Germany\; @Kassner2014] running at 120 Hz, and the signals were recorded with the Pupil Capture software.

## Procedure

Before each experiment, participants adjusted the angle of the stereoscope mirrors to achieve binocular fusion. This was done so that they would perceive the two discs as one fused disc when looking at the screen through the stereoscope.

### Experiment 1: simultaneous EEG and pupillometry

The experiment was conducted in a windowless room, in which the only light source was the monitor. The participants sat at 99 cm from the monitor and the total optical viewing distance (through the stereoscope) was 107 cm. The experiment was carried out in a single session lasting 45 minutes in total, divided into three blocks of 15 minutes each. In each block, there were 60 trials lasting 15 seconds each (12s of stimulus presentation, with an interstimulus interval of 3s). The participants were given no task other than to look at the fixation cross in the middle of the disc while trying to minimise their blinking during the presentation period.

We included six distinct ocular conditions, each at five temporal contrast levels (combined factorially) relative to the mean luminance: 6, 12, 24, 48 and 96\%. Contrast was defined as temporal Michelson contrast; the difference between maximum and minimum luminances, scaled by the mean and expressed as a percentage. In the first three conditions, the discs flickered at 2 Hz, in either a monocular, binocular, or dichoptic arrangement (see upper rows of Figure \@ref(fig:methodsfig)). In the dichoptic condition the non-target eye saw a fixed temporal contrast of 48\%. The rationale for including the monocular and binocular conditions is that they permit us to measure empirically any binocular facilitation, by comparing the response amplitudes across these two conditions. The rationale for including the dichoptic condition is that it provides additional contraints to computational models, and further explores the binocular contrast-response space [see @Baker2007].

In the remaining three conditions (termed the cross-frequency conditions) an additional flicker frequency of 1.6Hz was introduced. We chose this frequency because it is sufficiently well-isolated from the target frequency (2Hz) in the Fourier spectrum for 10-second trials. We repeated the monocular condition with this stimulus (one eye sees 1.6Hz flicker, the other sees mean luminance), as well as testing in a binocular cross configuration (one eye sees each frequency at the target contrast). The rationale for the binocular cross condition is that it allows us to see the effects of suppression between the eyes without the additional complication of signal summation (which occurs when both eyes receive the same frequency), because the response of each eye can be resolved independently by frequency. Finally, in the dichoptic cross condition, one eye saw the target stimulus flickering at 2Hz, the other eye saw flicker at 1.6Hz with a contrast of 48\% - again this reveals the presence of suppression (by comparison with the 2Hz monocular condition). A schematic overview of the cross-frequency conditions is shown in the lower rows of Figure \@ref(fig:methodsfig). In all conditions, we counterbalanced presentation of the target stimulus across the left and right eyes.

```{r methodsfig, fig.cap="Schematic diagram illustrating the ocular arrangements, and temporal waveforms of the luminance modulations used in Experiment 1. Shaded waveforms indicate a target stimulus, that was presented at one of five contrasts on each trial (denoted by the shading levels). Unshaded waveforms indicate mask stimuli, that were presented at a fixed contrast level of 48\\% regardless of the target contrast. Each waveform corresponds to a 1 second period of a 12 second trial, and coloured symbols are for consistency with Figures 2 and 3. The icon in the upper left corner illustrates the stimulus appearance (a luminous disc against a black background). The left and right eye assignments were counterbalanced across trials in the experiment (i.e. the monocular stimulus could be shown to either eye with equal probability).", fig.align="center", echo=FALSE}

knitr::include_graphics(paste0(figdir,'methodsfig.pdf'))

```

### Experiment 2: EEG responses across temporal frequency

This experiment used the same equipment set up as Experiment 1, except that the eye tracker was not used. Unlike the first experiment, only one contrast level was used (96\%) and the discs were set to flicker at five different frequencies (2, 4, 8, 16 and 30 Hz). Only two ocular configurations, monocular and binocular, were included, with the latter having both discs flickering at the same frequency. The experiment was carried out in one session lasting 25 minutes in total, divided into five blocks of 5 minutes each. In each block, there were 20 trials in total with the same timing as for Experiment 1.

### Experiment 3: temporal contrast matching

The experiment was conducted in a darkened room with a blacked-out window. The display equipment (monitor and stereoscope) were the same as for the two previous experiments, but no EEG or pupillometry data were collected. A two-interval contrast matching procedure was used to collect data. In one interval, participants were presented with a standard fused disc that flickered at a set contrast level (either 24 or 48\%), which was selected by the experimenter at the beginning of each block. In the other interval, a target disc was displayed, flickering at different contrast levels on each trial, but with a fixed interocular contrast ratio across the block. The contrast level of the target was controlled by a 1-up, 1-down staircase moving in logarithmic (dB) steps of contrast. The ratio of flicker amplitudes in the left and right eyes was varied across blocks and was set to be 0, 0.25, 0.5, 0.75 or 1 (9 distinct conditions). The standard and target discs were displayed for 1 second each, with an interstimulus interval of 0.5 seconds. After both discs had appeared on screen, the participants had to indicate which interval they perceived as having the more intense flicker. The intervals were randomly ordered, and all discs flickered at a frequency of 2 Hz (two cycles in sine phase).

Due to its long duration (approximately 3 hours in total), the participants completed the experiment across multiple sessions initiated at their own convenience. The experiment was divided into 54 blocks (3 repetitions $\times$ 2 standard contrasts $\times$ 9 target ratios), which lasted on average 3 minutes each, depending on the response speed of the participant. In each block, there was a total of 50 trials. No auditory feedback was given for this subjective task.

## Data analysis

EEG data were converted from the ANT-EEProbe format to a compressed csv text file using a custom Matlab script and components of the EEGlab toolbox [@Delorme2004]. The data for each participant were then loaded into R for analysis, where a ten-second waveform for each trial at each electrode was extracted (omitting the first two seconds). The Fourier transform of each waveform was calculated, and the complex spectrum stored in a matrix. All repetitions of each condition were then averaged for each electrode. They were then averaged across four occipital electrodes (\emph{POz}, \emph{Oz}, \emph{O1}, \emph{O2}), to obtain individual results. Finally, these were averaged across participants to obtain the group results. All averaging was performed in the complex domain and therefore retained the phase information (i.e. coherent averaging), and at each stage we excluded data points with a Mahalanobis distance exceeding $D$ = `r SDthresh` from the complex-valued mean [see @Baker2021]. For statistical comparisons of complex-valued data, we use the $ANOVA^2_{circ}$ statistic described by @Baker2021. This is a multivariate extension of ANOVA that assumes equal variance of the real and imaginary Fourier components, or equivalently, an extension of the $T^2_{circ}$ statistic of @Victor1991 that can compare more than two conditions.

A similar analysis pipeline was adopted for the pupillometry data. The data were converted from mp4 videos to a csv text file using the Pupil Player software [@Kassner2014], which estimated pupil diameter for each eye on each frame using a 3D model of the eyeball. The individual data were then loaded into R for analysis, where again a ten-second waveform for each trial in each eye was extracted (excluding the first two seconds after stimulus onset). We interpolated across any dropped or missing frames to ensure regular and continuous sampling over time. The Fourier transform was calculated for each waveform, and all repetitions of each condition were pooled across eye and then averaged. We confirmed in additional analyses that the monocular consensual pupil response was complete, justifying our pooling of data across the eyes. Finally, data were averaged across all participants to obtain the group results. Again, we used coherent averaging, and excluded outlying data points in the same way as for the EEG data. Note that previous pupillometry studies using luminance flicker have tended to fit a single sine-wave at the fundamental frequency, rather than using Fourier analysis [e.g. @Spitschan2014]. The Fourier approach is more robust to noise at other frequencies (which can make the phase and amplitude of a fitted sine wave unstable) and has been used in some previous studies [see @Barrionuevo2014; @Barrionuevo2016]. Additionally, it makes the pupillometry analysis consistent with standard practice in steady-state EEG analysis [e.g. @Figueira2022].

To analyse the matching data, we pooled the trial responses across all repetitions of a given condition for each participant. We then fitted a cumulative normal psychometric function to estimate the point of subjective equality at the 50\% level. Thresholds were averaged across participants in logarithmic (dB) units. 

For all experiments, we used a bootstrapping procedure with `r nbootstraps` iterations to estimate standard errors across participants. All analysis and figure construction was conducted using a single R-script, available online, making this study fully computationally reproducible.

## Computational model and parameter estimation

To describe our data, we chose a model of binocular contrast gain control with the same general form as the first stage of the model proposed by @Meese2006. The second gain control stage was omitted [consistent with @Baker2017] to simplify the model and reduce the number of free parameters. The response of the left eye's channel is given by:

\begin{equation}
\label{eq:respL}
Resp_L = \frac{L^2}{Z + L + wR},
\end{equation}

with an equivalent expression for the right eye:

\begin{equation}
\label{eq:respR}
Resp_R = \frac{R^2}{Z + R + wL}.
\end{equation}

In both equations, _L_ and _R_ are the contrast signals from the left and right eyes, _Z_ is a saturation constant that shifts the contrast-response function laterally, and _w_ is the weight of suppression from the other eye.

The responses from the two eyes are then summed binocularly:

\begin{equation}
\label{eq:respB}
Resp_B = R_{max}(Resp_L + Resp_R) + n,
\end{equation}

where _n_ is a noise parameter, and $R_{max}$ scales the overall response amplitude. The $R_{max}$ parameter was omitted when modelling the contrast matching data, as it has no effect in this paradigm.

Despite being derived from the model proposed by @Meese2006, the simplifications applied to this architecture make it very similar to other models [e.g. @Ding2006; @Legge1984; @Schrodinger1926; @Doesschate1967]. In particular we fixed the numerator exponent at 2 in our model, because otherwise this value tends to trade off with the weight of interocular suppression [see @Baker2012; @Kingdom2015]. Our key parameter of interest is the weight of interocular suppression. Large values around $w$ = 1 result in a very small or nonexistent binocular advantage at suprathreshold contrasts, consistent with previous work using grating stimuli [@Baker2017]. Low values around $w$ = 0 produce substantial, near-linear binocular facilitation [@Baker2020]. Models from this family can handle both scalar contrast values and continuous waveforms [@Tsai2012] or images [@Meese2007] as inputs. For time-varying inputs, the calculations are performed at each time point, and the output waveform can then be analysed using Fourier analysis in the same way as for empirical data. This means that the model can make predictions for the entire Fourier spectrum, including harmonic and intermodulation responses that arise as a consequence of nonlinearities in the model [@Baker2017]. However for computational tractability, we performed fitting here using scalar contrast values.

We implemented the model within a Bayesian framework using the Stan software [@Carpenter2017]. This allowed us to estimate group-level posterior parameter distributions for the weight of interocular suppression, $w$, and the other free model parameters $R_{max}$, $Z$ and $n$. The prior distributions for all parameters were Gaussian, with means and standard deviations of 1 and 0.5 for $w$ and $R_{max}$, and 5 and 2 for $Z$ and $n$, with these values chosen based on previous literature [@Meese2006; @Baker2012]. We sampled from a Student's t-distribution for the amplitudes in the pupillometry and EEG experiments, and from a Bernoulli distribution for the single trial matching data. The models were fit using the individual data across all participants, independently for each data set. We used coherent averaging to combine the data across participants, but this was not implemented in the model, so to compensate we corrected the group-level model by scaling the estimated noise parameter ($n$) by the square root of the number of participants ($n_{group} = \frac{n}{\sqrt{30}}$). We took posterior samples at over a million steps for each data set, using a computer cluster, and retained 10\% of samples for plotting.

## Preregistration, data and code availability

We initially preregistered our main hypotheses and analysis intentions for the first experiment. We then conducted a pilot study with N = 12 participants, before making some minor changes to the stimulus (we added dim red lines to aid binocular fusion). We then ran the main experiment, followed by two additional experiments that were not preregistered. The preregistration document, raw data files, and experimental and analysis code, are available on the project repository: https://doi.org/10.17605/OSF.IO/TBEMA.

# Results

## Experiment 1

```{r exp1individualanalysis, include=FALSE, results='hide'}

# (download and) analyse individual participant data for experiment 1

if (processdata > 2){
  
legaltriggers <- 1

timeseq <- seq(1/120,10,length.out=120*10)
timeseq2 <- seq(1/120,14,length.out=120*14)
EEGtimes <- seq(1/1000,10,1/1000)
targetindex <- (2*10)+1
maskindex <- (1.6*10)+1
targetindex2 <- (2*2*10)+1
maskindex2 <- (2*1.6*10)+1

  for (participant in 1:30){
    
    # only download and process data if this has not been done already for this participant
    if (!file.exists(paste0(datadir,'P',100+participant,'summary.RData'))){   

      # if there is no directory for this participant's data
      if (!file.exists(paste0(rawdir,'P',100+participant))){
        dir.create(paste0(rawdir,'P',100+participant))
        
       d <- dir(paste0(rawdir,'P',100+participant))
       
       if (length(d)==0){
         
         # if the tar file of this participant's data doesn't exist
         if (!file.exists(paste0(rawdir,'P',100+participant,'.tar'))){
           # download it from OSF
           if (!exists('osffiles')){
           osfnode <- 'x8u4v'
           osfproject <- osf_retrieve_node(osfnode)
          osffiles <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffiles$name==paste0('P',100+participant,'.tar'))
          osf_download(osffiles[fid,],rawdir,progress=TRUE)
         }
         
         # then unzip the tar file
         untar(paste0(rawdir,'P',100+participant,'.tar'),exdir=paste0(rawdir,'P',100+participant))
         
         # and delete the tar file to save storage space
         file.remove(paste0(rawdir,'P',100+participant,'.tar'))
       }
      }
      
      d <- dir(paste0(rawdir,'P',100+participant),full.names=TRUE)
      
      pupiltargets <- array(0,dim=c(3,2,60))
pupilmasks <- pupiltargets
pupilwaveforms <- array(0,dim=c(3,2,60,120*14))
pupilspectra <- array(0,dim=c(3,2,60,300))
EEGtargets <- array(0,dim=c(3,64,60))
EEGmasks <- EEGtargets
EEGtargets2 <- EEGtargets
EEGmasks2 <- EEGtargets
EEGwaveforms <- array(0,dim=c(3,64,60,1000*14))
EEGspectra <- array(0,dim=c(3,64,60,300))

psychopyfiles <- dir(path=paste0(rawdir,'P',100+participant),pattern=paste0('P',100+participant,'_CRFstudy'), full.names = TRUE)
infofiles <- dir(path=paste0(rawdir,'P',100+participant),pattern='*_info.csv', full.names = TRUE)
EEGfiles <- dir(path=paste0(rawdir,'P',100+participant),pattern='*_EEG.csv.gz', full.names = TRUE)
pupilfiles <- dir(path=paste0(rawdir,'P',100+participant),pattern='*_pupil_positions.csv', full.names = TRUE)

for (block in 1:length(EEGfiles)){
  
    infofile <- read.csv(infofiles[block])
  pupilstarttime <- as.numeric(as.character(infofile[4,2]))
  localstarttime <- as.numeric(as.character(infofile[5,2]))
  
  psychoutput <- read.csv(psychopyfiles[block])

  trialtimes <- psychoutput$trialonset - pupilstarttime
  condorder <- psychoutput$condition
  
    EEGdata <- read.csv(EEGfiles[block])
  electrodes <- colnames(EEGdata)
  
      triggertimes <- NULL
    counter <- 0
    lasttrigger <- -10000
    for (n in 1:nrow(EEGdata)){
      if(EEGdata$Trigger[n] %in% legaltriggers){
        if(n>(lasttrigger+10000)){
        counter <- counter + 1
        triggertimes[counter] <- n
        lasttrigger <- n
      }}
    }
  
    for (cond in 1:60){
      for (ch in 1:64){
        trial <- EEGdata[(triggertimes[cond]+(2001:12000)),ch+2]
        fspec <- (fft(trial)/length(trial))
        EEGtargets[block,ch,condorder[cond]] <- fspec[targetindex]
        EEGmasks[block,ch,condorder[cond]] <- fspec[maskindex]
        EEGtargets2[block,ch,condorder[cond]] <- fspec[targetindex2]
        EEGmasks2[block,ch,condorder[cond]] <- fspec[maskindex2]
        EEGspectra[block,ch,condorder[cond],1:300] <- fspec[1:300]
        
        trial <- EEGdata[(triggertimes[cond]+(-999:13000)),ch+2]
        EEGwaveforms[block,ch,condorder[cond],] <- trial - mean(trial[1:1000])
      }}
    
    
  pdata <- read.csv(pupilfiles[block])
  pdata2 <- pdata[,c(1,3,4,14)]
  pdata2[,1] <- pdata2[,1] - localstarttime
  pdata2 <- pdata2[which(pdata2[,3]>0.0),]

  for (eye in 1:2){
    eyedata <- pdata2[which(pdata2[,2]==(2-eye)),]
    for (cond in 1:60){
      a <- which(eyedata[,1]>trialtimes[cond]+2)
      b <- which(eyedata[,1]<(trialtimes[cond]+12))
      i <- intersect(a,b)
      trial <- eyedata[i,]
      trial[,1] <- trial[,1] - trial[1,1]
      if (nrow(trial)>3){
        resampled <- interp1(trial[,1],trial[,4],timeseq,method='linear',extrap=TRUE)
        fspec <- (fft(resampled)/length(resampled))
        pupiltargets[block,eye,condorder[cond]] <- fspec[targetindex]
        pupilmasks[block,eye,condorder[cond]] <- fspec[maskindex]
        pupilspectra[block,eye,condorder[cond],1:300] <- fspec[1:300]
      }
      
      a <- which(eyedata[,1]>(trialtimes[cond]-1))
      b <- which(eyedata[,1]<(trialtimes[cond]+13))
      i <- intersect(a,b)
      trial <- eyedata[i,]
      trial[,1] <- trial[,1] - trial[1,1]
      if (nrow(trial)>3){
        resampled <- interp1(trial[,1],trial[,4],timeseq2,method='linear',extrap=TRUE)
        pupilwaveforms[block,eye,condorder[cond],] <- resampled - mean(resampled[1:120])
      }
      
      }}
  
}

cleanmeansP <- matrix(0,nrow=6,ncol=5)
cleanmasksP <- matrix(0,nrow=6,ncol=5)
cleanmeansE <- array(0,dim=c(64,6,5))
cleanmasksE <- array(0,dim=c(64,6,5))
cleanmeansE2 <- array(0,dim=c(64,6,5))
cleanmasksE2 <- array(0,dim=c(64,6,5))

for (cond in 1:6){
  startindex <- (10*(cond-1))
  for (level in 1:5){
    temp <- c(pupiltargets[,,startindex+level],pupiltargets[,,startindex+level+5])
    cleanmeansP[cond,level] <- cleanup2D(temp)

    temp <- c(pupilmasks[,,startindex+level],pupilmasks[,,startindex+level+5])
    cleanmasksP[cond,level] <- cleanup2D(temp)

    for (ch in 1:64){
    temp <- c(EEGtargets[,ch,startindex+level],EEGtargets[,ch,startindex+level+5])
    cleanmeansE[ch,cond,level] <- cleanup2D(temp)
    
    temp <- c(EEGmasks[,ch,startindex+level],EEGmasks[,ch,startindex+level+5])
    cleanmasksE[ch,cond,level] <- cleanup2D(temp)
    
    temp <- c(EEGtargets2[,ch,startindex+level],EEGtargets2[,ch,startindex+level+5])
    cleanmeansE2[ch,cond,level] <- cleanup2D(temp)
    
    temp <- c(EEGmasks2[,ch,startindex+level],EEGmasks2[,ch,startindex+level+5])
    cleanmasksE2[ch,cond,level] <- cleanup2D(temp) 
    }
  }
}

electrodeindices <- match(targetelectrodes,electrodes)-2

meanwavesP <- apply(pupilwaveforms[,,c(15,20),],4,mean,na.rm=TRUE)
meanwavesE <- apply(EEGwaveforms[,electrodeindices,c(15,20),],4,mean,na.rm=TRUE)
meanspectraP <- apply(pupilspectra[,,c(15,20),],4,mean,na.rm=TRUE)
meanspectraE <- apply(EEGspectra[,electrodeindices,c(15,20),],4,mean,na.rm=TRUE)
IMspectraP <- apply(pupilspectra[,,c(44,49,54,59),],4,mean,na.rm=TRUE)
IMspectraE <- apply(EEGspectra[,electrodeindices,c(44,49,54,59),],4,mean,na.rm=TRUE)
save(file=paste(datadir,'P',100+participant,'summary.RData',sep=''),list=c('cleanmeansP','cleanmeansE','cleanmeansE2','cleanmasksP','cleanmasksE','cleanmasksE2','meanspectraP','meanspectraE','meanwavesP','meanwavesE','electrodes','IMspectraP','IMspectraE'))

 if (cleanupraw==1){file.remove(d)} # delete raw data files to save space
      }

      }

  }
  


```

```{r exp1groupanalysis, include=FALSE, results='hide'}

# load in individual participant data and average, save group data

if (processdata > 1){

         if (!file.exists(paste0(datadir,'headerfile.csv'))){
           # download it from OSF
           if (!exists('osffiles')){
           osfnode <- 'x8u4v'
           osfproject <- osf_retrieve_node(osfnode)
          osffiles <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffiles$name=='headerfile.csv')
          osf_download(osffiles[fid,],datadir,progress=TRUE)
          } 
  
  hdata <- read.csv(paste0(datadir,'headerfile.csv'))  

for (participant in 1:30){
         # if the summary file of this participant's data doesn't exist
         if (!file.exists(paste0(datadir,'P',100+participant,'summary.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '2qu6y'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name==paste0('P',100+participant,'summary.RData'))
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
         }
}

 
d <- paste0('P',101:130,'summary.RData')

allmasksP <- array(0,dim=c(length(d),6,5))
allmeansP <- allmasksP
allmasksE <- array(0,dim=c(length(d),64,6,5))
allmeansE <- allmasksE
allmeansE2 <- allmeansE
allmasksE2 <- allmasksE
allspectraP <- array(0,dim=c(length(d),300))
allspectraE <- array(0,dim=c(length(d),300))
allspectraP_IM <- array(0,dim=c(length(d),300))
allspectraE_IM <- array(0,dim=c(length(d),300))
allwavesP <- array(0,dim=c(length(d),1680))
allwavesE <- array(0,dim=c(length(d),14000))

  for (s in 1:length(d)){
    
    load(paste0(datadir,d[s]))
    
  allmasksP[s,,] <- cleanmasksP
  allmeansP[s,,] <- cleanmeansP
  allspectraP[s,] <- meanspectraP
  allspectraE[s,] <- meanspectraE
  allspectraP_IM[s,] <- IMspectraP
  allspectraE_IM[s,] <- IMspectraE  
  allwavesP[s,] <- meanwavesP
  allwavesE[s,] <- meanwavesE
  allmeansE[s,,,] <- cleanmeansE
  allmasksE[s,,,] <- cleanmasksE
  allmeansE2[s,,,] <- cleanmeansE2
  allmasksE2[s,,,] <- cleanmasksE2
    
  }

electrodeindices <- match(targetelectrodes,electrodes)-2

allspectraP <- allspectraP[-c(2,4,13,20,26),]

cleanmeansP <- matrix(0,nrow=6,ncol=5)
cleanmeansPCI <- array(0,c(2,6,5))
cleanmasksP <- matrix(0,nrow=6,ncol=5)
cleanmasksPCI <- array(0,c(2,6,5))
cleanmeansEav <- matrix(0,nrow=6,ncol=5)
cleanmeansEavCI <- array(0,c(2,6,5))
cleanmasksEav <- matrix(0,nrow=6,ncol=5)
cleanmasksEavCI <- array(0,c(2,6,5))
cleanmeansE2av <- matrix(0,nrow=6,ncol=5)
cleanmeansE2avCI <- array(0,c(2,6,5))
cleanmasksE2av <- matrix(0,nrow=6,ncol=5)
cleanmasksE2avCI <- array(0,c(2,6,5))
cleanmeansE <- array(0,dim=c(64,6,5))
cleanmeansECI <- array(0,c(2,64,6,5))
cleanmasksE <- array(0,dim=c(64,6,5))
cleanmasksECI <- array(0,c(2,64,6,5))
cleanmeansE2 <- array(0,dim=c(64,6,5))
cleanmeansE2CI <- array(0,c(2,64,6,5))
cleanmasksE2 <- array(0,dim=c(64,6,5))
cleanmasksE2CI <- array(0,c(2,64,6,5))


for (cond in 1:6){
  for (level in 1:5){
    
    temp <- allmeansP[,cond,level]
    mbs <- bootstrap2D(temp)
    cleanmeansP[cond,level] <- mbs$meanamp
    cleanmeansPCI[1,cond,level] <- mbs$lowerCI
    cleanmeansPCI[2,cond,level] <- mbs$upperCI
      
    temp <- allmasksP[,cond,level]
    mbs <- bootstrap2D(temp)
    cleanmasksP[cond,level] <- mbs$meanamp
    cleanmasksPCI[1,cond,level] <- mbs$lowerCI
    cleanmasksPCI[2,cond,level] <- mbs$upperCI

      temp <- apply(allmeansE[,electrodeindices,cond,level],1,mean)
      mbs <- bootstrap2D(temp)
    cleanmeansEav[cond,level] <- mbs$meanamp
    cleanmeansEavCI[1,cond,level] <- mbs$lowerCI
    cleanmeansEavCI[2,cond,level] <- mbs$upperCI
      
temp <- apply(allmasksE[,electrodeindices,cond,level],1,mean)
mbs <- bootstrap2D(temp)
    cleanmasksEav[cond,level] <- mbs$meanamp
    cleanmasksEavCI[1,cond,level] <- mbs$lowerCI
    cleanmasksEavCI[2,cond,level] <- mbs$upperCI

temp <- apply(allmeansE2[,electrodeindices,cond,level],1,mean)
mbs <- bootstrap2D(temp)
    cleanmeansE2av[cond,level] <- mbs$meanamp
    cleanmeansE2avCI[1,cond,level] <- mbs$lowerCI
    cleanmeansE2avCI[2,cond,level] <- mbs$upperCI

      temp <- apply(allmasksE2[,electrodeindices,cond,level],1,mean)
      mbs <- bootstrap2D(temp)
    cleanmasksE2av[cond,level] <- mbs$meanamp
    cleanmasksE2avCI[1,cond,level] <- mbs$lowerCI
    cleanmasksE2avCI[2,cond,level] <- mbs$upperCI

    for (ch in 1:64){
      
      temp <- allmeansE[,ch,cond,level]
      mbs <- bootstrap2D(temp)
    cleanmeansE[ch,cond,level] <- mbs$meanamp
    cleanmeansECI[1,ch,cond,level] <- mbs$lowerCI
    cleanmeansECI[2,ch,cond,level] <- mbs$upperCI

      temp <- allmasksE[,ch,cond,level]
      mbs <- bootstrap2D(temp)
    cleanmasksE[ch,cond,level] <- mbs$meanamp
    cleanmasksECI[1,ch,cond,level] <- mbs$lowerCI
    cleanmasksECI[2,ch,cond,level] <- mbs$upperCI

      temp <- allmeansE2[,ch,cond,level]
      mbs <- bootstrap2D(temp)
    cleanmeansE2[ch,cond,level] <- mbs$meanamp
    cleanmeansE2CI[1,ch,cond,level] <- mbs$lowerCI
    cleanmeansE2CI[2,ch,cond,level] <- mbs$upperCI
      
      temp <- allmasksE2[,ch,cond,level]
      mbs <- bootstrap2D(temp)
    cleanmasksE2[ch,cond,level] <- mbs$meanamp
    cleanmasksE2CI[1,ch,cond,level] <- mbs$lowerCI
    cleanmasksE2CI[2,ch,cond,level] <- mbs$upperCI
      
    }}}

meanspectraP <- (1:300)*0
meanspectraE <- (1:300)*0
meanspectraPCI <- array(0,c(2,300))
meanspectraECI <- array(0,c(2,300))
meanspectraP_IM <- (1:300)*0
meanspectraE_IM <- (1:300)*0
meanspectraPCI_IM <- array(0,c(2,300))
meanspectraECI_IM <- array(0,c(2,300))

for (f in 2:300){
  
        temp <- allspectraP[,f]
        mbs <- bootstrap2D(temp)
meanspectraP[f] <- mbs$meanamp
meanspectraPCI[1,f] <- mbs$lowerCI
meanspectraPCI[2,f] <- mbs$upperCI
      
        temp <- allspectraE[,f]
        mbs <- bootstrap2D(temp)
meanspectraE[f] <- mbs$meanamp
meanspectraECI[1,f] <- mbs$lowerCI
meanspectraECI[2,f] <- mbs$upperCI

        temp <- allspectraP_IM[,f]
        mbs <- bootstrap2D(temp)
meanspectraP_IM[f] <- mbs$meanamp
meanspectraPCI_IM[1,f] <- mbs$lowerCI
meanspectraPCI_IM[2,f] <- mbs$upperCI
      
        temp <- allspectraE_IM[,f]
        mbs <- bootstrap2D(temp)
meanspectraE_IM[f] <- mbs$meanamp
meanspectraECI_IM[1,f] <- mbs$lowerCI
meanspectraECI_IM[2,f] <- mbs$upperCI

}

meanwavesP <- NULL
meanwavesE <- NULL
meanwavesPCI <- array(0,dim=c(2,dim(allwavesP)[2]))
meanwavesECI <- array(0,dim=c(2,dim(allwavesE)[2]))
nsubjs <- dim(allwavesP)[1]
for (t in 1:dim(allwavesP)[2]){
  temp <- allwavesP[,t]
  i <- which(abs(temp-mean(temp))<(SDthresh*sd(temp)))
  meanwavesP[t] <- mean(temp[i])
  bspop <- NULL
  for (s in 1:nbootstraps){bspop[s] <- mean(sample(temp[i],length(i),replace=TRUE))}
  meanwavesPCI[,t] <- quantile(bspop,c(0.16,0.84),na.rm=TRUE)
}

for (t in 1:dim(allwavesE)[2]){
    temp <- allwavesE[,t]
  i <- which(abs(temp-mean(temp))<(SDthresh*sd(temp)))
  meanwavesE[t] <- mean(temp[i])
  bspop <- NULL
  for (s in 1:nbootstraps){bspop[s] <- mean(sample(temp[i],length(i),replace=TRUE))}
  meanwavesECI[,t] <- quantile(bspop,c(0.16,0.84),na.rm=TRUE)
}

save(file=paste0(datadir,'Averagedata.RData'),list=c('cleanmeansP','cleanmeansPCI','cleanmasksP','cleanmasksPCI','cleanmeansEav','cleanmeansEavCI','cleanmasksEav','cleanmasksEavCI','cleanmeansE2av','cleanmeansE2avCI','cleanmasksE2av','cleanmasksE2avCI','cleanmeansE','cleanmeansECI','cleanmasksECI','cleanmeansE2','cleanmeansE2CI','cleanmasksE2','cleanmasksE2CI','meanspectraP','meanspectraPCI','meanspectraE','meanspectraECI','meanwavesP','meanwavesE','meanwavesPCI','meanwavesECI','electrodes','allmeansP','allmeansE','allmeansE2','allmasksP','allmasksE','allmasksE2','meanspectraP_IM','meanspectraPCI_IM','meanspectraE_IM','meanspectraECI_IM'))

}

```

```{r createpupilfig, include=FALSE, results='hide'}

# generate plot showing the group pupillometry data

         if (!file.exists(paste0(datadir,'Averagedata.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '2qu6y'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name=='Averagedata.RData')
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
         }

load(file=paste0(datadir,'Averagedata.RData'))

if (processdata > 0){

contrastsdB <- 20*log10(c(6,12,24,48,96))

plotlims <- c(15,40,0,0.03) 
ticklocsx <- contrastsdB    # locations of tick marks on x axis
ticklocsy <- seq(0,0.03,0.01)    # locations of tick marks on y axis
ticklabelsx <-c(6,12,24,48,96)        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

postscript("CRF1p.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude at 2Hz (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansP[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  arrows(contrastsdB,abs(cleanmeansP[cond,]),contrastsdB,cleanmeansPCI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansP[cond,]),contrastsdB,cleanmeansPCI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  points(contrastsdB,abs(cleanmeansP[cond,]), pch = 20+cond, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves
}  
legend(22,0.03,c('Monocular','Binocular','Dichoptic'),pch=21:23,pt.bg=colpal[1:3],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.028,'(c)',adj=0.5,cex=2.5)

dev.off()

postscript("CRF2p.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)   
title(ylab="Amplitude at 2Hz (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

condlist <- c(1,5,6)
pointlist <- c(21,24,25)
for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansP[condlist[cond],]), col=colpal[condlist[cond]], lwd=3, cex=0.5)  
  arrows(contrastsdB,abs(cleanmeansP[condlist[cond],]),contrastsdB,cleanmeansPCI[1,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansP[condlist[cond],]),contrastsdB,cleanmeansPCI[2,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)  
  points(contrastsdB,abs(cleanmeansP[condlist[cond],]), pch = pointlist[cond], col='black', bg=colpal[condlist[cond]], cex=1.6, lwd=3)   
}  
legend(22,0.03,c('Monocular','Binocular cross','Dichoptic cross'),pch=pointlist,pt.bg=colpal[condlist],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.028,'(d)',adj=0.5,cex=2.5)

dev.off()


postscript("CRF3p.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

plotlims <- c(15,40,0,0.04) 
ticklocsy <- seq(0,0.04,0.01)    # locations of tick marks on y axis
ticklabelsy <- ticklocsy    # set labels for y ticks

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude at 1.6Hz (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

for (cond in 4:6){
  lines(contrastsdB,abs(cleanmasksP[cond,]), col=colpal[cond], lwd=3, cex=0.5)   
  arrows(contrastsdB,abs(cleanmasksP[cond,]),contrastsdB,cleanmasksPCI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmasksP[cond,]),contrastsdB,cleanmasksPCI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)    
  points(contrastsdB,abs(cleanmasksP[cond,]), pch = pointlist[cond-3], col='black', bg=colpal[cond], cex=1.6, lwd=3) 
}
legend(22,0.04,c('Monocular 1.6Hz','Binocular cross','Dichoptic cross'),pch=pointlist,pt.bg=colpal[4:6],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.038,'(e)',adj=0.5,cex=2.5)

dev.off()


postscript("SpecP.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 8)

frequencies <- (0:299)/10

plotlims <- c(1,6,0,0.03) 
ticklocsx <- seq(1,6,1)    # locations of tick marks on x axis
ticklocsy <- seq(0,0.03,0.01)    # locations of tick marks on y axis
ticklabelsx <-ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
title(xlab="Frequency (Hz)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

polygon(frequencies[c(11:61,61:11)],c(meanspectraPCI[1,11:61],meanspectraPCI[2,61:11]),col=colpal[2],border=NA)

lines(frequencies[11:61],abs(meanspectraP[11:61]), col=colpal[2], lwd=3, cex=0.5) 

text(1.1,0.028,'(b)',adj=0.5,cex=2.5)

dev.off()



postscript("timecourseP.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 8)

times <- seq((1/120)-1,13,1/120)
sinewave <- sin(2*times * 2*pi)
sinewave[1:120] <- 0
sinewave[1560:1680] <- 0

plotlims <- c(-1,13,-1.5,0.5) 
ticklocsx <- seq(-1,13,1)    # locations of tick marks on x axis
ticklocsy <- seq(-1.5,0.5,0.5)    # locations of tick marks on y axis
ticklabelsx <- ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
title(xlab="Time (s)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Relative amplitude (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

filt <- butter(3,0.083)
filtwaveP <- signal::filter(filt, meanwavesP)
filtU <- signal::filter(filt,meanwavesPCI[1,])
filtL <- signal::filter(filt,meanwavesPCI[2,])
polygon(times[c(1:length(times),length(times):1)],c(filtL,filtU[length(filtU):1]),col=colpal[2],border=NA)

lines(times, filtwaveP, col=colpal[2], lwd=1.5) 

lines(times, (sinewave/10)-1.4, col='black', lwd=3) 

text(-0.7,0.4,'(a)',adj=0.5,cex=2.5)

dev.off()

  PostScriptTrace('CRF1p.ps')
  p1 <- readPicture('CRF1p.ps.xml')
  PostScriptTrace('CRF2p.ps')
  p2 <- readPicture('CRF2p.ps.xml')
  PostScriptTrace('CRF3p.ps')
  p3 <- readPicture('CRF3p.ps.xml')
  PostScriptTrace('SpecP.ps')
  p4 <- readPicture('SpecP.ps.xml')
  PostScriptTrace('timecourseP.ps')
  p5 <- readPicture('timecourseP.ps.xml')
  
    for (n in 1:length(p4@paths)){
    temp <- class(p4@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(p4@paths[n]$path@rgb))<765){p4@paths[n]$path@rgb <- addalpha(p4@paths[n]$path@rgb,alpha=0.2)}}}
  
      for (n in 1:length(p5@paths)){
    temp <- class(p5@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(p5@paths[n]$path@rgb))<765){p5@paths[n]$path@rgb <- addalpha(p5@paths[n]$path@rgb,alpha=0.2)}}}

  
  pdf(paste0(figdir,"pupildata.pdf"), bg="transparent", height = 10, width = 15)
  par(mar=c(0.1,0.1,0.1,0.1))
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(0,1), ylim=c(0,1))
  
  grid.picture(p1,x=0.17,y=0.25,width=0.32,height=1)
  grid.picture(p2,x=0.5,y=0.25,width=0.32,height=1)
  grid.picture(p3,x=0.83,y=0.25,width=0.32,height=1)
  grid.picture(p5,x=0.25,y=0.7,width=0.5,height=1)
  grid.picture(p4,x=0.75,y=0.7,width=0.5,height=1)
  
  text(0.5,0.98,'Pupillometry',cex=4)
  
  dev.off()
  
  file.remove(c('CRF1p.ps','CRF2p.ps','CRF3p.ps','SpecP.ps','timecourseP.ps'))
  file.remove(c('CRF1p.ps.xml','CRF2p.ps.xml','CRF3p.ps.xml','SpecP.ps.xml','timecourseP.ps.xml'))

}

```

```{r pupilstats, include=FALSE, results='hide'}

# do statistics on the pupillometry data

alldata <- NULL
groupID <- NULL
allP <- NULL
counter <- 0
for (cont in 1:dim(allmeansP)[3]){
  for (p in 1:dim(allmeansP)[1]){
    counter <- counter + 1
    alldata[counter] <- allmeansP[p,3,cont]
    groupID[counter] <- cont
    allP[counter] <- p
  }
}
dichA2c <- anovacirc.test(alldata,group=groupID,participant=allP)
# groupID <- as.factor(groupID)
# participantID <- as.factor(participantID)
# adata <- data.frame(dichdata,groupID,participantID)
# dichA2c <- ezANOVA(data = adata, dv = dichdata, within=groupID, wid=participantID)


alldata <- NULL
allgroupA <- NULL
allgroupB <- NULL
allP <- NULL
counter <- 0
for (p in 1:30){
  for (lev in 1:5){
    for (cond in 1:2){
    counter <- counter + 1
    alldata[counter] <- allmeansP[p,cond,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- cond
    allP[counter] <- p
    }
  }
}
monbinPstats <- anovacirc2way(alldata,allgroupA,allgroupB,allP)
# allgroupA <- as.factor(allgroupA)
# allgroupB <- as.factor(allgroupB)
# allP <- as.factor(allP)
# alldata <- abs(alldata)
# adata <- data.frame(alldata,allgroupA,allgroupB,allP)
# monbinPstats <- ezANOVA(data = adata, dv = alldata, within=c(allgroupA,allgroupB), wid=allP)


alldata <- NULL
allgroupA <- NULL
allgroupB <- NULL
allP <- NULL
counter <- 0
for (p in 1:30){
  for (lev in 1:5){
    counter <- counter + 1
    alldata[counter] <- allmeansP[p,1,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- 1
    allP[counter] <- p

    counter <- counter + 1
    alldata[counter] <- allmeansP[p,3,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- 2
    allP[counter] <- p
  }
}
mondichPstats <- anovacirc2way(alldata,allgroupA,allgroupB,allP)
# allgroupA <- as.factor(allgroupA)
# allgroupB <- as.factor(allgroupB)
# allP <- as.factor(allP)
# alldata <- abs(alldata)
# adata <- data.frame(alldata,allgroupA,allgroupB,allP)
# mondichPstats <- ezANOVA(data = adata, dv = alldata, within=c(allgroupA,allgroupB), wid=allP)


alldata <- NULL
allgroupA <- NULL
allgroupB <- NULL
allP <- NULL
counter <- 0
for (p in 1:30){
  for (lev in 1:5){
    counter <- counter + 1
    alldata[counter] <- allmeansP[p,1,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- 1
    allP[counter] <- p

    counter <- counter + 1
    alldata[counter] <- allmeansP[p,5,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- 2
    allP[counter] <- p
  }
}

monbinPstatsX <- anovacirc2way(alldata,allgroupA,allgroupB,allP)
# allgroupA <- as.factor(allgroupA)
# allgroupB <- as.factor(allgroupB)
# allP <- as.factor(allP)
# alldata <- abs(alldata)
# adata <- data.frame(alldata,allgroupA,allgroupB,allP)
# monbinPstatsX <- ezANOVA(data = adata, dv = alldata, within=c(allgroupA,allgroupB), wid=allP)

alldata <- NULL
allgroupA <- NULL
allgroupB <- NULL
allP <- NULL
counter <- 0
for (p in 1:30){
  for (lev in 1:5){
    counter <- counter + 1
    alldata[counter] <- allmeansP[p,1,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- 1
    allP[counter] <- p

    counter <- counter + 1
    alldata[counter] <- allmeansP[p,6,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- 2
    allP[counter] <- p
  }
}

mondichPstatsX <- anovacirc2way(alldata,allgroupA,allgroupB,allP)
# allgroupA <- as.factor(allgroupA)
# allgroupB <- as.factor(allgroupB)
# allP <- as.factor(allP)
# alldata <- abs(alldata)
# adata <- data.frame(alldata,allgroupA,allgroupB,allP)
# mondichPstatsX <- ezANOVA(data = adata, dv = alldata, within=c(allgroupA,allgroupB), wid=allP)

alldata <- NULL
allgroupA <- NULL
allgroupB <- NULL
allP <- NULL
counter <- 0
for (p in 1:30){
  for (lev in 1:5){
    counter <- counter + 1
    alldata[counter] <- allmasksP[p,4,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- 1
    allP[counter] <- p

    counter <- counter + 1
    alldata[counter] <- allmasksP[p,5,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- 2
    allP[counter] <- p
  }
}

monbinPstatsX2 <- anovacirc2way(alldata,allgroupA,allgroupB,allP)


alldata <- NULL
allgroupA <- NULL
allgroupB <- NULL
allP <- NULL
counter <- 0
for (p in 1:30){
  for (lev in 1:5){
    counter <- counter + 1
    alldata[counter] <- allmasksP[p,4,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- 1
    allP[counter] <- p

  }
}

mondichPstatsX2 <- anovacirc.test(alldata,allgroupA,allP)


```

The pupillometry results are summarised in Figure \@ref(fig:pupildata). The group average waveform for binocular presentation is shown in Figure \@ref(fig:pupildata)a. There is a substantial pupil constriction at stimulus onset, followed by visible oscillations at the flicker frequency (2Hz, see waveform at foot). The average Fourier spectrum is displayed in Figure \@ref(fig:pupildata)b, and shows a clear spike at 2 Hz, but no evidence of a second harmonic response at 4Hz (though see Appendix 1). These results demonstrate that our paradigm can evoke measurable steady-state pupil responses at 2Hz.

```{r pupildata, fig.cap="Summary of pupillometry results for N=30 participants. Panel (a) shows a group average waveform for binocular presentation (low pass filtered at 5Hz), with the driving signal plotted at the foot. Negative values indicate constriction relative to baseline, and positive values indicate dilation. Panel (b) shows the average Fourier spectrum (absolute amplitude values). Panels (c,d) show contrast response functions for pupil diameter at 2Hz for different conditions (illustrated in Figure 1). Panel (e) shows contrast response functions at 1.6Hz for three conditions. Shaded regions and error bars indicate bootstrapped standard errors.", fig.align="center", echo=FALSE}

knitr::include_graphics(paste0(figdir,'pupildata.pdf'))

```

Figure \@ref(fig:pupildata)c shows contrast response functions driven by stimuli flickering only at 2Hz. Response amplitudes increased monotonically with target contrast, confirming that our paradigm is suitable for measuring contrast-dependent differences in the pupil response (to our knowledge this is the first time this has been demonstrated). The amplitude of the binocular condition (blue squares) is consistently greater than that of the monocular condition (red circles) across all target contrasts. A $2\times5$ repeated measures $ANOVA^2_{circ}$ [@Baker2021] comparing these conditions revealed a significant main effect of target contrast (F(`r monbinPstats$dfA`,`r monbinPstats$dfR`) = `r round(monbinPstats$FratioA,digits=2)`, $p$ `r p_format(monbinPstats$pvalA,digits=3,accuracy=0.001)`), a significant effect of condition (F(`r monbinPstats$dfB`,`r monbinPstats$dfR`) = `r round(monbinPstats$FratioB,digits=2)`, $p$ `r p_format(monbinPstats$pvalB,digits=3,accuracy=0.001)`), and a significant interaction (F(`r monbinPstats$dfAB`,`r monbinPstats$dfR`) = `r round(monbinPstats$FratioAB,digits=2)`, $p$ `r p_format(monbinPstats$pvalAB,digits=3,accuracy=0.001)`). The dichoptic condition begins at a much higher amplitude, owing to binocular combination of the target and high (48%) contrast mask, and then increases slightly with increasing target contrast (main effect of target contrast: F(`r dichA2c$dfM`,`r dichA2c$dfR`) = `r round(dichA2c$Fratio,digits=2)`, $p$ < `r p_format(dichA2c$pval,digits=1,accuracy=0.001)`).

In Figure \@ref(fig:pupildata)d, we plot responses to monocular target stimuli flickering at 2Hz, when the other eye viewed stimuli flickering at 1.6Hz (the red monocular-only data are replotted from Figure \@ref(fig:pupildata)c for comparison). When the 1.6Hz component had the same contrast as the target (the binocular cross condition, shown in purple) responses were facilitated slightly at low contrasts, and suppressed at the highest target contrasts (interaction between contrast and condition: F(`r monbinPstatsX$dfAB`,`r monbinPstatsX$dfR`) = `r round(monbinPstatsX$FratioAB,digits=2)`, $p$ `r p_format(monbinPstatsX$pvalAB,digits=3,accuracy=0.001)`). When the 1.6Hz component had a fixed contrast of 48% (the dichoptic cross condition, shown in yellow), responses were suppressed slightly across the contrast range (interaction between contrast and condition: F(`r mondichPstatsX$dfAB`,`r mondichPstatsX$dfR`) = `r round(mondichPstatsX$FratioAB,digits=2)`, $p$ `r p_format(mondichPstatsX$pvalAB,digits=3,accuracy=0.001)`).

Figure \@ref(fig:pupildata)e shows responses at 1.6Hz, for the same conditions, as well as for a condition in which a monocular stimulus flickered at 1.6Hz (grey circles). Here we find strong suppression in both the binocular cross (purple triangles) and dichoptic cross (yellow triangles) conditions. In the binocular cross condition, the amplitudes are reduced relative to the monocular condition (grey circles) (interaction effect: F(`r monbinPstatsX2$dfAB`,`r monbinPstatsX2$dfR`) = `r round(monbinPstatsX2$FratioAB,digits=2)`, $p$ `r p_format(monbinPstatsX2$pvalAB,digits=3,accuracy=0.001)`). In the dichoptic cross condition, increasing the 2Hz target contrast suppresses the response to the 1.6Hz mask, and the function decreases [see e.g. @Busse2009] (main effect of target contrast F(`r mondichPstatsX2$dfM`,`r mondichPstatsX2$dfR`) = `r round(mondichPstatsX2$Fratio,digits=2)`, $p$ `r p_format(mondichPstatsX2$pval,digits=3,accuracy=0.001)`).

Figure \@ref(fig:EEGdata) shows equivalent results, measured contemporaneously using EEG. Figure \@ref(fig:EEGdata)a shows the group average waveform for binocular presentation, and Figure \@ref(fig:EEGdata)b shows the Fourier spectrum for binocular presentation, both averaged across four posterior electrodes (_Oz_, _POz_, _O1_ and _O2_, marked on the inset scalp plots). Unlike for the pupillometry data, there are clear responses at both the first harmonic frequency (2Hz), and also the second harmonic frequency (4Hz). We therefore calculated contrast response functions at both first and second harmonic frequencies.

```{r createEEGfig, include=FALSE, results='hide'}

# generate plot showing the group EEG data

contrastsdB <- 20*log10(c(6,12,24,48,96))

         if (!file.exists(paste0(datadir,'headerfile.csv'))){
           # download it from OSF
           if (!exists('osffiles')){
           osfnode <- 'x8u4v'
           osfproject <- osf_retrieve_node(osfnode)
          osffiles <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffiles$name=='headerfile.csv')
          osf_download(osffiles[fid,],datadir,progress=TRUE)
          } 
hdata <- read.csv(paste0(datadir,'headerfile.csv'))  

         if (!file.exists(paste0(datadir,'Averagedata.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '2qu6y'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name=='Averagedata.RData')
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
         }

load(file=paste0(datadir,'Averagedata.RData'))

electrodeindices <- match(targetelectrodes,electrodes)-2

if (processdata > 0){

plotlims <- c(15,40,0,0.8)  
ticklocsx <- contrastsdB    # locations of tick marks on x axis
ticklocsy <- seq(0,0.8,0.2)    # locations of tick marks on y axis
ticklabelsx <-c(6,12,24,48,96)        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

postscript("CRF1e.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude (ÂµV) at 2Hz", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansEav[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  arrows(contrastsdB,abs(cleanmeansEav[cond,]),contrastsdB,cleanmeansEavCI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansEav[cond,]),contrastsdB,cleanmeansEavCI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  points(contrastsdB,abs(cleanmeansEav[cond,]), pch = 20+cond, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves
}  
legend(22,0.8,c('Monocular','Binocular','Dichoptic'),pch=21:23,pt.bg=colpal[1:3],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.75,'(c)',adj=0.5,cex=2.5)

dev.off()

postscript("CRF2e.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)   
title(ylab="Amplitude (ÂµV) at 2Hz", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

condlist <- c(1,5,6)
pointlist <- c(21,24,25)
for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansEav[condlist[cond],]), col=colpal[condlist[cond]], lwd=3, cex=0.5)  
  arrows(contrastsdB,abs(cleanmeansEav[condlist[cond],]),contrastsdB,cleanmeansEavCI[1,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansEav[condlist[cond],]),contrastsdB,cleanmeansEavCI[2,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  points(contrastsdB,abs(cleanmeansEav[condlist[cond],]), pch = pointlist[cond], col='black', bg=colpal[condlist[cond]], cex=1.6, lwd=3)   
}  
legend(22,0.8,c('Monocular','Binocular cross','Dichoptic cross'),pch=pointlist,pt.bg=colpal[condlist],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.75,'(d)',adj=0.5,cex=2.5)

dev.off()


postscript("CRF3e.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude (ÂµV) at 1.6Hz", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

for (cond in 4:6){
  lines(contrastsdB,abs(cleanmasksEav[cond,]), col=colpal[cond], lwd=3, cex=0.5)   
  arrows(contrastsdB,abs(cleanmasksEav[cond,]),contrastsdB,cleanmasksEavCI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmasksEav[cond,]),contrastsdB,cleanmasksEavCI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  points(contrastsdB,abs(cleanmasksEav[cond,]), pch = pointlist[cond-3], col='black', bg=colpal[cond], cex=1.6, lwd=3) 
}
legend(22,0.8,c('Monocular 1.6Hz','Binocular cross','Dichoptic cross'),pch=pointlist,pt.bg=colpal[4:6],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.75,'(e)',adj=0.5,cex=2.5)

dev.off()


postscript("CRF1e2.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude (ÂµV) at 4Hz", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansE2av[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  arrows(contrastsdB,abs(cleanmeansE2av[cond,]),contrastsdB,cleanmeansE2avCI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  if (cond!=2){
  arrows(contrastsdB,abs(cleanmeansE2av[cond,]),contrastsdB,cleanmeansE2avCI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)}
  
  # plot an arrow for the final binocular target contrast level that is above 0.8
  if (cond==2){
  arrows(contrastsdB[1:4],abs(cleanmeansE2av[cond,1:4]),contrastsdB[1:4],cleanmeansE2avCI[2,cond,1:4],lwd=3,col=colpal[cond],length=0.05,angle=90)   
  arrows(contrastsdB[5],abs(cleanmeansE2av[cond,5]),contrastsdB[5],0.8,lwd=3,col=colpal[cond],length=0.05,angle=45)    
  }
  
  points(contrastsdB,abs(cleanmeansE2av[cond,]), pch = 20+cond, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves
}  
legend(22,0.8,c('Monocular','Binocular','Dichoptic'),pch=21:23,pt.bg=colpal[1:3],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.75,'(f)',adj=0.5,cex=2.5)

dev.off()

postscript("CRF2e2.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)   
title(ylab="Amplitude (ÂµV) at 4Hz", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

condlist <- c(1,5,6)
pointlist <- c(21,24,25)
for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansE2av[condlist[cond],]), col=colpal[condlist[cond]], lwd=3, cex=0.5)  
  arrows(contrastsdB,abs(cleanmeansE2av[condlist[cond],]),contrastsdB,cleanmeansE2avCI[1,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansE2av[condlist[cond],]),contrastsdB,cleanmeansE2avCI[2,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  points(contrastsdB,abs(cleanmeansE2av[condlist[cond],]), pch = pointlist[cond], col='black', bg=colpal[condlist[cond]], cex=1.6, lwd=3)   
}  
legend(22,0.8,c('Monocular','Binocular cross','Dichoptic cross'),pch=pointlist,pt.bg=colpal[condlist],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.75,'(g)',adj=0.5,cex=2.5)

dev.off()


postscript("CRF3e2.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude (ÂµV) at 3.2Hz", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

for (cond in 4:6){
  lines(contrastsdB,abs(cleanmasksE2av[cond,]), col=colpal[cond], lwd=3, cex=0.5)   
  arrows(contrastsdB,abs(cleanmasksE2av[cond,]),contrastsdB,cleanmasksE2avCI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmasksE2av[cond,]),contrastsdB,cleanmasksE2avCI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  points(contrastsdB,abs(cleanmasksE2av[cond,]), pch = pointlist[cond-3], col='black', bg=colpal[cond], cex=1.6, lwd=3) 
}
legend(22,0.8,c('Monocular 1.6Hz','Binocular cross','Dichoptic cross'),pch=pointlist,pt.bg=colpal[4:6],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.75,'(h)',adj=0.5,cex=2.5)

dev.off()


postscript("SpecE.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 8)

frequencies <- (0:299)/10

plotlims <- c(1,6,0,1) 
ticklocsx <- seq(1,6,1)    # locations of tick marks on x axis
ticklocsy <- seq(0,1,0.2)    # locations of tick marks on y axis
ticklabelsx <-ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
title(xlab="Frequency (Hz)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude (ÂµV)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

polygon(frequencies[c(11:61,61:11)],c(meanspectraECI[1,11:61],meanspectraECI[2,61:11]),col=colpal[2],border=NA)

lines(frequencies[11:61],abs(meanspectraE[11:61]), col=colpal[2], lwd=3, cex=0.5) 

text(1.1,0.95,'(b)',adj=0.5,cex=2.5)

dev.off()



postscript("timecourseE.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 8)

times <- seq((1/1000)-1,13,1/1000)
sinewave <- sin(2*times * 2*pi)
sinewave[1:1000] <- 0
sinewave[13001:14000] <- 0

plotlims <- c(-1,13,-10,20) 
ticklocsx <- seq(-1,13,1)    # locations of tick marks on x axis
ticklocsy <- seq(-10,20,10)    # locations of tick marks on y axis
ticklabelsx <- ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
title(xlab="Time (s)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude (ÂµV)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

filt <- butter(3,0.083*0.12)
filtwaveE <- signal::filter(filt, meanwavesE)
filtU <- signal::filter(filt,meanwavesECI[1,])
filtL <- signal::filter(filt,meanwavesECI[2,])
polygon(times[c(1:length(times),length(times):1)],c(filtL,filtU[length(filtU):1]),col=colpal[2],border=NA)

lines(times, filtwaveE, col=colpal[2], lwd=1.5) 

lines(times, (sinewave*2.5)-7.5, col='black', lwd=3) 

text(-0.7,18,'(a)',adj=0.5,cex=2.5)

dev.off()


xpos <- 1:64
ypos <- 1:64
montageE <- toupper(as.character(hdata$Electrode))
for (ch in 1:64){
  i <- match(toupper(electrodes[ch+2]),montageE)
  xpos[ch] <- hdata$X_position[i]
  ypos[ch] <- hdata$Y_position[i]
}

ramp2 <- colorRamp(c("white",colpal[2]))  # create a ramp from one colour to another
colmatrix2 <- rgb(ramp2(seq(0, 1, length = 101)), max = 255)

## Create data frame to be used for interpolation - the function needs columns labelled x, y, and z
rmax <- 0.55   #specify a maximum boundary for the grid
gridRes <- 100 #specify the interpolation grid resolution

toplot <- abs(cleanmeansE[,2,5])
toplot[which(is.na(toplot))] <- 0
testDat<- data.frame(x = xpos, y = -ypos, z = toplot)

#Create the interpolation grid
xo <- seq(min(-rmax, testDat$x), max(rmax, testDat$x), length = gridRes)
yo <- seq(max(rmax, testDat$y), min(-rmax, testDat$y), length = gridRes)

interpV4 <- v4Interp(testDat, xo, yo, rmax, gridRes)

zo2 <- as.matrix(interpV4[,2:ncol(interpV4)])

xo2 <- matrix(rep(xo,length(yo)),nrow = length(xo),ncol = length(yo))
yo2 <- t(matrix(rep(yo,length(xo)),nrow = length(yo),ncol = length(xo)))
outsidecircle <- sqrt(xo2^2 + yo2^2) > 0.51
zo2[outsidecircle] <- 0

tiff("head1.tiff", height = 600, width = 600, units="px", bg="white")

plotlims <- c(-rmax,rmax,-rmax,rmax) 
par(pty="s")  # make axis square
plot(x=NULL,y=NULL,ann=FALSE, axes=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
image(xo,xo,zo2,col=colmatrix2,zlim=c(0,1),add=TRUE,useRaster=TRUE)
maskx <- c(hdata$OutlineX[1:51]*2.2,hdata$OutlineX[51:1])
masky <- c(hdata$OutlineY[1:51]*2.2,hdata$OutlineY[51:1])
polygon(maskx,masky,border=NA,col="white")
maskx <- c(hdata$OutlineX[51:101]*2.2,hdata$OutlineX[101:51])
masky <- c(hdata$OutlineY[51:101]*2.2,hdata$OutlineY[101:51])
polygon(maskx,masky,border=NA,col="white")

blackelectrodes <- match(toupper(targetelectrodes),toupper(as.character(electrodes[3:66])))
points(xpos[blackelectrodes],ypos[blackelectrodes],pch=16,col="black",cex=2)

lines(hdata$OutlineX,hdata$OutlineY,col="black",lwd=2)
lines(hdata$NoseX,hdata$NoseY,col="black",lwd=2)
lines(hdata$LearX,hdata$LearY,col="black",lwd=2)
lines(hdata$RearX,hdata$RearY,col="black",lwd=2)

dev.off()


toplot <- abs(cleanmeansE2[,2,5])
toplot[which(is.na(toplot))] <- 0
testDat<- data.frame(x = xpos, y = -ypos, z = toplot)

#Create the interpolation grid
xo <- seq(min(-rmax, testDat$x), max(rmax, testDat$x), length = gridRes)
yo <- seq(max(rmax, testDat$y), min(-rmax, testDat$y), length = gridRes)

interpV4 <- v4Interp(testDat, xo, yo, rmax, gridRes)

zo2 <- as.matrix(interpV4[,2:ncol(interpV4)])

xo2 <- matrix(rep(xo,length(yo)),nrow = length(xo),ncol = length(yo))
yo2 <- t(matrix(rep(yo,length(xo)),nrow = length(yo),ncol = length(xo)))
outsidecircle <- sqrt(xo2^2 + yo2^2) > 0.51
zo2[outsidecircle] <- 0
zo2[which(zo2>1)] <- 1

tiff("head2.tiff", height = 600, width = 600, units="px", bg="white")

plotlims <- c(-rmax,rmax,-rmax,rmax) 
par(pty="s")  # make axis square
plot(x=NULL,y=NULL,ann=FALSE, axes=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
image(xo,xo,zo2,col=colmatrix2,zlim=c(0,1),add=TRUE,useRaster=TRUE)
maskx <- c(hdata$OutlineX[1:51]*2.2,hdata$OutlineX[51:1])
masky <- c(hdata$OutlineY[1:51]*2.2,hdata$OutlineY[51:1])
polygon(maskx,masky,border=NA,col="white")
maskx <- c(hdata$OutlineX[51:101]*2.2,hdata$OutlineX[101:51])
masky <- c(hdata$OutlineY[51:101]*2.2,hdata$OutlineY[101:51])
polygon(maskx,masky,border=NA,col="white")

blackelectrodes <- match(toupper(targetelectrodes),toupper(as.character(electrodes[3:66])))
points(xpos[blackelectrodes],ypos[blackelectrodes],pch=16,col="black",cex=2)

lines(hdata$OutlineX,hdata$OutlineY,col="black",lwd=2)
lines(hdata$NoseX,hdata$NoseY,col="black",lwd=2)
lines(hdata$LearX,hdata$LearY,col="black",lwd=2)
lines(hdata$RearX,hdata$RearY,col="black",lwd=2)

dev.off()


  PostScriptTrace('CRF1e.ps')
  p1 <- readPicture('CRF1e.ps.xml')
  PostScriptTrace('CRF2e.ps')
  p2 <- readPicture('CRF2e.ps.xml')
  PostScriptTrace('CRF3e.ps')
  p3 <- readPicture('CRF3e.ps.xml')
  PostScriptTrace('SpecE.ps')
  p4 <- readPicture('SpecE.ps.xml')
  PostScriptTrace('timecourseE.ps')
  p5 <- readPicture('timecourseE.ps.xml')
  PostScriptTrace('CRF1e2.ps')
  p6 <- readPicture('CRF1e2.ps.xml')
  PostScriptTrace('CRF2e2.ps')
  p7 <- readPicture('CRF2e2.ps.xml')
  PostScriptTrace('CRF3e2.ps')
  p8 <- readPicture('CRF3e2.ps.xml')
  
    for (n in 1:length(p4@paths)){
    temp <- class(p4@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(p4@paths[n]$path@rgb))<765){p4@paths[n]$path@rgb <- addalpha(p4@paths[n]$path@rgb,alpha=0.2)}}}

      for (n in 1:length(p5@paths)){
    temp <- class(p5@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(p5@paths[n]$path@rgb))<765){p5@paths[n]$path@rgb <- addalpha(p5@paths[n]$path@rgb,alpha=0.2)}}}

    
  h1 <- readTIFF('head1.tiff')
  h2 <- readTIFF('head2.tiff')
  
  pdf(paste0(figdir,"EEGdata.pdf"), bg="transparent", height = 15, width = 15)
  par(mar=c(0.1,0.1,0.1,0.1))
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(0,1), ylim=c(0,1))
  
  # insert the head plots first so the white border doesn't overlap the other graphs
    aspratio <- 1  # this is the aspect ratio of the output pdf
  imwidth <- 0.16
  xstart <- 0.65
  ystart <- 0.82
  rasterImage(h1,xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth) 
  xstart <- 0.82
  ystart <- 0.82
  rasterImage(h2,xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth)

  grid.picture(p5,x=0.25,y=0.8,width=0.5,height=1)
  grid.picture(p4,x=0.75,y=0.8,width=0.5,height=1)
  grid.picture(p1,x=0.17,y=0.5,width=0.32,height=1)
  grid.picture(p2,x=0.5,y=0.5,width=0.32,height=1)
  grid.picture(p3,x=0.83,y=0.5,width=0.32,height=1)
  grid.picture(p6,x=0.17,y=0.175,width=0.32,height=1)
  grid.picture(p7,x=0.5,y=0.175,width=0.32,height=1)
  grid.picture(p8,x=0.83,y=0.175,width=0.32,height=1)
  
    text(0.5,1,'Electroencephalography',cex=4)

  dev.off()
  
  file.remove(c('CRF1e.ps','CRF2e.ps','CRF3e.ps','CRF1e2.ps','CRF2e2.ps','CRF3e2.ps','SpecE.ps','timecourseE.ps','head1.tiff','head2.tiff'))
  file.remove(c('CRF1e.ps.xml','CRF2e.ps.xml','CRF3e.ps.xml','CRF1e2.ps.xml','CRF2e2.ps.xml','CRF3e2.ps.xml','SpecE.ps.xml','timecourseE.ps.xml'))

}

```

```{r eegstats, include=FALSE, results='hide'}

# do statistics on the EEG data

alldata <- NULL
groupID <- NULL
allP <- NULL
counter <- 0
for (cont in 1:dim(allmeansP)[3]){
  for (p in 1:dim(allmeansP)[1]){
    counter <- counter + 1
    alldata[counter] <- mean(allmeansE[p,electrodeindices,3,cont])
    groupID[counter] <- cont
    allP[counter] <- p
  }
}
dichE2c <- anovacirc.test(alldata,group=groupID,participant=allP)
# groupID <- as.factor(groupID)
# participantID <- as.factor(participantID)
# adata <- data.frame(dichdata,groupID,participantID)
# dichE2c <- ezANOVA(data = adata, dv = dichdata, within=groupID, wid=participantID)


alldata <- NULL
allgroupA <- NULL
allgroupB <- NULL
allP <- NULL
counter <- 0
for (p in 1:30){
  for (lev in 1:5){
    for (cond in 1:2){
    counter <- counter + 1
    alldata[counter] <- mean(allmeansE[p,electrodeindices,cond,lev])
    allgroupA[counter] <- lev
    allgroupB[counter] <- cond
    allP[counter] <- p
    }
  }
}
monbinEstats <- anovacirc2way(alldata,allgroupA,allgroupB,allP)
# allgroupA <- as.factor(allgroupA)
# allgroupB <- as.factor(allgroupB)
# allP <- as.factor(allP)
# alldata <- abs(alldata)
# adata <- data.frame(alldata,allgroupA,allgroupB,allP)
# monbinEstats <- ezANOVA(data = adata, dv = alldata, within=c(allgroupA,allgroupB), wid=allP)


alldata <- NULL
allgroupA <- NULL
allgroupB <- NULL
allP <- NULL
counter <- 0
for (p in 1:30){
  for (lev in 1:5){
    counter <- counter + 1
    alldata[counter] <- mean(allmeansE[p,electrodeindices,1,lev])
    allgroupA[counter] <- lev
    allgroupB[counter] <- 1
    allP[counter] <- p

    counter <- counter + 1
    alldata[counter] <- mean(allmeansE[p,electrodeindices,3,lev])
    allgroupA[counter] <- lev
    allgroupB[counter] <- 2
    allP[counter] <- p
  }
}
mondichEstats <- anovacirc2way(alldata,allgroupA,allgroupB,allP)
# allgroupA <- as.factor(allgroupA)
# allgroupB <- as.factor(allgroupB)
# allP <- as.factor(allP)
# alldata <- abs(alldata)
# adata <- data.frame(alldata,allgroupA,allgroupB,allP)
# mondichEstats <- ezANOVA(data = adata, dv = alldata, within=c(allgroupA,allgroupB), wid=allP)


alldata <- NULL
allgroupA <- NULL
allgroupB <- NULL
allP <- NULL
counter <- 0
for (p in 1:30){
  for (lev in 1:5){
    counter <- counter + 1
    alldata[counter] <- mean(allmeansE[p,electrodeindices,1,lev])
    allgroupA[counter] <- lev
    allgroupB[counter] <- 1
    allP[counter] <- p

    counter <- counter + 1
    alldata[counter] <- mean(allmeansE[p,electrodeindices,5,lev])
    allgroupA[counter] <- lev
    allgroupB[counter] <- 2
    allP[counter] <- p
  }
}

monbinEstatsX <- anovacirc2way(alldata,allgroupA,allgroupB,allP)
# allgroupA <- as.factor(allgroupA)
# allgroupB <- as.factor(allgroupB)
# allP <- as.factor(allP)
# alldata <- abs(alldata)
# adata <- data.frame(alldata,allgroupA,allgroupB,allP)
# monbinEstatsX <- ezANOVA(data = adata, dv = alldata, within=c(allgroupA,allgroupB), wid=allP)

alldata <- NULL
allgroupA <- NULL
allgroupB <- NULL
allP <- NULL
counter <- 0
for (p in 1:30){
  for (lev in 1:5){
    counter <- counter + 1
    alldata[counter] <- mean(allmeansE[p,electrodeindices,1,lev])
    allgroupA[counter] <- lev
    allgroupB[counter] <- 1
    allP[counter] <- p

    counter <- counter + 1
    alldata[counter] <- mean(allmeansE[p,electrodeindices,6,lev])
    allgroupA[counter] <- lev
    allgroupB[counter] <- 2
    allP[counter] <- p
  }
}

mondichEstatsX <- anovacirc2way(alldata,allgroupA,allgroupB,allP)
# allgroupA <- as.factor(allgroupA)
# allgroupB <- as.factor(allgroupB)
# allP <- as.factor(allP)
# alldata <- abs(alldata)
# adata <- data.frame(alldata,allgroupA,allgroupB,allP)
# mondichEstatsX <- ezANOVA(data = adata, dv = alldata, within=c(allgroupA,allgroupB), wid=allP)

```

```{r EEGdata, fig.cap="Summary of EEG results for N=30 participants. Panel (a) shows a group average waveform for binocular presentation (low pass filtered at 5Hz), with the driving signal plotted at the foot. Panel (b) shows the average Fourier spectrum, and inset scalp distributions. Black dots on the scalp plots indicate electrodes Oz, POz, O1 and O2. Panels (c,d) show contrast response functions at 2Hz for different conditions. Panel (e) shows contrast response functions at 1.6Hz for three conditions. Panels (f-h) are in the same format but for the second harmonic responses. Shaded regions and error bars indicate bootstrapped standard errors.", fig.align="center", echo=FALSE}

knitr::include_graphics(paste0(figdir,'EEGdata.pdf'))

```

When stimuli in both eyes flicker at 2Hz, the binocular responses at the first (Figure \@ref(fig:EEGdata)c) and second (Figure \@ref(fig:EEGdata)f) harmonics are substantially greater than the monocular responses, particularly at high contrasts. Analysis of variance on the complex values ($ANOVA^2_{circ}$) revealed a main effect of contrast (F(`r monbinEstats$dfA`,`r monbinEstats$dfR`) = `r round(monbinEstats$FratioA,digits=2)`, $p$ `r p_format(monbinEstats$pvalA,digits=3,accuracy=0.001)`) and an interaction effect (F(`r monbinEstats$dfAB`,`r monbinEstats$dfR`) = `r round(monbinEstats$FratioAB,digits=2)`, $p$ `r p_format(monbinEstats$pvalAB,digits=3,accuracy=0.001)`), but no effect of condition ($p$ = `r p_format(monbinEstats$pvalB,digits=2)`) at the first harmonic, with a similar pattern of results obtained at the second harmonic. For the cross-frequency conditions (Figure \@ref(fig:EEGdata)d,g), there was no appreciable effect of adding a 1.6Hz component on the response at 2Hz or 4Hz (no effect of condition, and no interaction). Similarly, there were no clear interocular interactions between frequencies in the responses at 1.6Hz (Figure \@ref(fig:EEGdata)e) and 3.2Hz (Figure \@ref(fig:EEGdata)h). This pattern of results suggests that processing of temporal luminance modulations happens in a more linear way in visual cortex (indexed by EEG), compared with subcortical pathways (indexed by pupillometry), and shows no evidence of interocular suppression.

```{r createBSfig, include=FALSE, results='hide'}

# generate plot showing the bin:mon ratio for three data sets

         if (!file.exists(paste0(datadir,'Averagedata.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '2qu6y'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name=='Averagedata.RData')
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
         }

load(file=paste0(datadir,'Averagedata.RData'))

contrastsdB <- 20*log10(c(6,12,24,48,96))
electrodeindices <- match(targetelectrodes,electrodes)-2

allPratios <- 20*log10(abs(allmeansP[,2,])/abs(allmeansP[,1,]))
allEratios <- 20*log10(abs(apply(allmeansE[,electrodeindices,2,],c(1,3),mean))/abs(apply(allmeansE[,electrodeindices,1,],c(1,3),mean)))
allE2ratios <- 20*log10(abs(apply(allmeansE2[,electrodeindices,2,],c(1,3),mean))/abs(apply(allmeansE2[,electrodeindices,1,],c(1,3),mean)))

allratios <- NULL
allconds <- NULL
allconts <- NULL
allparticipants <- NULL
counter <- 0
for (cont in 1:length(contrastsdB)){
  for (s in 1:nrow(allPratios)){
    counter <- counter + 1
    allratios[counter] <- allPratios[s,cont]
    allconds[counter] <- 1
    allparticipants[counter] <- s
    allconts[counter] <- cont
    
    counter <- counter + 1
    allratios[counter] <- allEratios[s,cont]
    allconds[counter] <- 2
    allparticipants[counter] <- s
    allconts[counter] <- cont
    
    counter <- counter + 1
    allratios[counter] <- allE2ratios[s,cont]
    allconds[counter] <- 3
    allparticipants[counter] <- s
    allconts[counter] <- cont
    
  }
}
allparticipants <- as.factor(allparticipants)
allconds <- as.factor(allconds)
allconts <- as.factor(allconts)
aovdata <- data.frame(allparticipants,allconds,allconts,allratios)
ratioaov <- ezANOVA(aovdata,dv=allratios,within=c(allconds,allconts),wid=allparticipants)
gg <- ratioaov$`Sphericity Corrections`$GGe

if (processdata > 0){

PratiosCI <- matrix(0,nrow=2,ncol=5)
EratiosCI <- matrix(0,nrow=2,ncol=5)
E2ratiosCI <- matrix(0,nrow=2,ncol=5)
for (level in 1:5){
    bspop <- NULL
    for (n in 1:nbootstraps){
      bspop[n] <- mean(sample(allPratios[,level],nrow(allPratios),replace=TRUE))
    }
    PratiosCI[,level] <- quantile(bspop,c((1-0.68)/2,1-((1-0.68)/2)))
     bspop <- NULL
    for (n in 1:nbootstraps){
      bspop[n] <- mean(sample(allEratios[,level],nrow(allEratios),replace=TRUE))
    }
    EratiosCI[,level] <- quantile(bspop,c((1-0.68)/2,1-((1-0.68)/2)))
    bspop <- NULL
    for (n in 1:nbootstraps){
      bspop[n] <- mean(sample(allE2ratios[,level],nrow(allE2ratios),replace=TRUE))
    }
    E2ratiosCI[,level] <- quantile(bspop,c((1-0.68)/2,1-((1-0.68)/2)))
}


plotlims <- c(15,40,-3,12)  
ticklocsx <- contrastsdB
ticklabelsx <-c(6,12,24,48,96) 
ticklocsy <- seq(-3,12,3)    # locations of tick marks on y axis
ticklabelsy <- c(expression(1/sqrt(2)),'1',expression(sqrt(2)),'2',expression(2*sqrt(2)),'4')

pdf("Figures/BSratios.pdf", onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Bin:Mon ratio", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

arrows(contrastsdB,colMeans(allPratios),contrastsdB,PratiosCI[1,],lwd=3,col=colpal[3],length=0.05,angle=90)
arrows(contrastsdB,colMeans(allPratios),contrastsdB,PratiosCI[2,],lwd=3,col=colpal[3],length=0.05,angle=90)
arrows(contrastsdB,colMeans(allEratios),contrastsdB,EratiosCI[1,],lwd=3,col=colpal[4],length=0.05,angle=90)
arrows(contrastsdB,colMeans(allEratios),contrastsdB,EratiosCI[2,],lwd=3,col=colpal[4],length=0.05,angle=90)
arrows(contrastsdB,colMeans(allE2ratios),contrastsdB,E2ratiosCI[1,],lwd=3,col=colpal[5],length=0.05,angle=90)
arrows(contrastsdB,colMeans(allE2ratios),contrastsdB,E2ratiosCI[2,],lwd=3,col=colpal[5],length=0.05,angle=90)
  
lines(contrastsdB,colMeans(allPratios), col=colpal[3], lwd=3, cex=0.5)
lines(contrastsdB,colMeans(allEratios), col=colpal[4], lwd=3, cex=0.5)
lines(contrastsdB,colMeans(allE2ratios), col=colpal[5], lwd=3, cex=0.5)

points(contrastsdB,colMeans(allPratios), pch = 21, col='black', bg=colpal[3], cex=1.6, lwd=3) 
points(contrastsdB,colMeans(allEratios), pch = 22, col='black', bg=colpal[4], cex=1.6, lwd=3)
points(contrastsdB,colMeans(allE2ratios), pch = 23, col='black', bg=colpal[5], cex=1.6, lwd=3)

legend(15,12,c('Pupillometry','EEG 1F', 'EEG 2F'), pch=21:23, pt.bg=colpal[3:5],box.lwd=2,pt.cex=1.6,pt.lwd=3)

dev.off()

}


```

Finally, we calculated the ratio of binocular to monocular responses across the three data types from Experiment 1. Figure \@ref(fig:BSratios) shows that these ratios are approximately $\sqrt2$ across the low-to-intermediate contrast range for all three data types. At higher contrasts, we see ratios of 2 or higher for the EEG data, but much weaker ratios near 1 for the pupillometry data. Note that the ratios here are calculated on a per-participant basis and then averaged, rather than being the ratios of the average values shown in Figures \@ref(fig:pupildata) and \@ref(fig:EEGdata). A $3 \times 5$ repeated measures ANOVA on the logarithmic (dB) ratios found a main effect of contrast (F(`r round(ratioaov$ANOVA$DFn[2]*gg[2],digits=2)`,`r round(ratioaov$ANOVA$DFd[2]*gg[2],digits=2)`) = `r round(ratioaov$ANOVA$F[2],digits=2)`, \emph{p} <`r p_format(ratioaov$ANOVA$p[2],digits=1,accuracy=0.001)`), no effect of data modality (F(`r ratioaov$ANOVA$DFn[1]`,`r ratioaov$ANOVA$DFd[1]`) = `r round(ratioaov$ANOVA$F[1],digits=2)`, \emph{p} = `r p_format(ratioaov$ANOVA$p[1],digits=2)`), but a highly significant interaction (F(`r round(ratioaov$ANOVA$DFn[3]*gg[3],digits=2)`,`r round(ratioaov$ANOVA$DFd[3]*gg[3],digits=2)`) = `r round(ratioaov$ANOVA$F[3],digits=2)`, \emph{p} `r p_format(ratioaov$ANOVA$p[3],digits=3,accuracy=0.001)`). All of the key results from Experiment 1 were subsequently replicated for peripheral stimulation (see Appendix 1).

```{r BSratios, fig.cap="Ratio of binocular to monocular response for three data types. These were calculated by dividing the binocular response by the monocular response at each contrast level, using the data underlying Figures 2c, 3c and 3f. Each value is the average of ratio across N=30 participants, and error bars indicate bootstrapped standard errors.", fig.align="center", out.width = '50%', echo=FALSE}

knitr::include_graphics(paste0(figdir,'BSratios.pdf'))

```

## Experiment 2

The strong binocular facilitation and weak interocular suppression in the EEG data from Experiment 1 was very different from previous findings on binocular combination using steady-state EEG with grating stimuli [@Baker2017]. One possible explanation is that the lower temporal frequency used here (2Hz, vs 5 or 7Hz in previous work) might be responsible for this difference. We therefore ran a second experiment to compare monocular and binocular responses at a range of temporal frequencies. Only EEG data were collected for this experiment, as the pupil response is substantially weaker above around 2Hz [@Barrionuevo2014; @Spitschan2014]; note that we originally chose 2Hz because it produces measurable signals for both EEG and pupillometry, yet is unfortunately optimal for neither.

```{r exp2individualanalysis, include=FALSE, results='hide'}

# (download and) analyse the raw data from the temporal frequency experiment

if (processdata > 2){
  
  legaltriggers <- 1
  
  TFs <- c(2,4,8,16,30)
  EEGtimes <- seq(1/1000,10,1/1000)
  targetindices <- (TFs*10)+1
  
  for (participant in 1:12){
    print(participant)
    
# download and process data if this has not been done already for this participant
    if (!file.exists(paste0(datadir,'P',150+participant,'summary.RData'))){   
      
      # if there is no directory for this participant's data
      if (!file.exists(paste0(rawdir,'P',150+participant))){
        dir.create(paste0(rawdir,'P',150+participant))}
      
      d <- dir(paste0(rawdir,'P',150+participant))
      
      if (length(d)==0){
        
        # if the tar file of this participant's data doesn't exist
        if (!file.exists(paste0(rawdir,'P',150+participant,'.tar'))){
          # download it from OSF
          if (!exists('tffiles')){
            osfnode <- 'mvpyz'
            osfproject <- osf_retrieve_node(osfnode)
            tffiles <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(tffiles$name==paste0('P',150+participant,'.tar'))
          osf_download(tffiles[fid,],rawdir,progress=TRUE)
        }
        
        # then unzip the tar file
        untar(paste0(rawdir,'P',150+participant,'.tar'),exdir=paste0(rawdir,'P',150+participant))
        
        # and delete the tar file to save storage space
        file.remove(paste0(rawdir,'P',150+participant,'.tar'))
      }
      
      d <- dir(paste0(rawdir,'P',150+participant),full.names=TRUE)
      
      EEGtargets <- array(0,dim=c(5,64,20,5))
      EEGspectra <- array(0,dim=c(5,64,20,500))
      
      psychopyfiles <- dir(path=paste0(rawdir,'P',150+participant), pattern=paste0('P',150+participant,'_CRFstudy'), full.names = TRUE)
      
      EEGfiles <- dir(path=paste0(rawdir,'P',150+participant), pattern='*_EEG.gz', full.names = TRUE)
      
      for (block in 1:length(EEGfiles)){
        
        psychoutput <- read.csv(psychopyfiles[block])
        
        condorder <- psychoutput$condition
        
        EEGdata <- read.csv(EEGfiles[block])
        electrodes <- colnames(EEGdata)
        
        triggertimes <- NULL
        counter <- 0
        lasttrigger <- -10000
        for (n in 1:nrow(EEGdata)){
          if(EEGdata$Trigger[n] %in% legaltriggers){
            if(n>(lasttrigger+10000)){
              counter <- counter + 1
              triggertimes[counter] <- n
              lasttrigger <- n
            }}
        }
        
        for (cond in 1:counter){
          for (ch in 1:64){
            trial <- EEGdata[(triggertimes[cond]+(2001:12000)),ch+2]
            fspec <- (fft(trial)/length(trial))
            EEGtargets[block,ch,condorder[cond],] <- fspec[targetindices]
            EEGspectra[block,ch,condorder[cond],1:500] <- fspec[1:500]
          }}
      }
      
      electrodeindices <- match(targetelectrodes,electrodes)-2
      
      cleanmeansE <- array(0,dim=c(2,5))
      meanspec <- array(0,dim=c(2,5,500))
      
      for (eye in 1:2){
        for (cond in 1:5){
          includedconds <- c(cond,cond+5) + (10*(eye-1))
          temp <- as.vector(EEGtargets[,electrodeindices,includedconds,cond])
          temp <- temp[which(!is.na(temp))]
          temp <- temp[which(abs(temp)>0)]  
          cleanmeansE[eye,cond] <- cleanup2D(temp)
          
          for (f in 2:500){
            temp <- as.vector(apply(EEGspectra[,electrodeindices,includedconds,f],c(1,3),mean))
            temp <- temp[which(!is.na(temp))]
            temp <- temp[which(abs(temp)>0)]  
            meanspec[eye,cond,f] <- cleanup2D(temp)
             
          }
        }
      }
      

    
    save(file=paste0(datadir,'P',150+participant,'summary.RData'),list=c('cleanmeansE','meanspec'))
    if (cleanupraw==1){file.remove(d)}  # delete raw data files to save space
    }
    
  }
  
}


```

```{r exp2groupanalysis, include=FALSE, results='hide'}

# load in the processed data from the temporal frequency experiment and average

if (processdata > 1){
  
  allspec <- array(0,dim=c(12,2,5,500))
  allmeans <- array(0,dim=c(12,2,5))
  allratios <- matrix(0,nrow=12,ncol=5)
  
      for (participant in 1:12){
         # if the summary file of this participant's data doesn't exist
         if (!file.exists(paste0(datadir,'P',150+participant,'summary.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '2qu6y'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name==paste0('P',150+participant,'summary.RData'))
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
         }
      }
  
  for (participant in 1:12){
    
    load(paste0(datadir,'P',150+participant,'summary.RData'))
    
    allmeans[participant,,] <- cleanmeansE
    allspec[participant,,,] <- meanspec
    allratios[participant,] <- 20*log10(abs(allmeans[participant,2,])/abs(allmeans[participant,1,]))
  }
  
meanratios <- NULL
meanratiosCI <- matrix(0,nrow=2,ncol=5)
cleanmeansTF <- matrix(0,nrow=2,ncol=5)
cleanmeansTFCI <- array(0,dim=c(2,2,5))
meanspectraTF <- array(0,dim=c(2,5,500))
meanspectraTFCI <- array(0,dim=c(2,2,5,500))

for (cond in 1:2){
  for (level in 1:5){
    
    temp <- allmeans[,cond,level]
    mbs <- bootstrap2D(temp)
    cleanmeansTF[cond,level] <- mbs$meanamp
    cleanmeansTFCI[1,cond,level] <- mbs$lowerCI
    cleanmeansTFCI[2,cond,level] <- mbs$upperCI
    
    meanratios[level] <- mean(allratios[,level])
    bspop <- NULL
    for (n in 1:nbootstraps){
      bspop[n] <- mean(sample(allratios[,level],nrow(allratios),replace=TRUE))
    }
    meanratiosCI[,level] <- quantile(bspop,c((1-0.68)/2,1-((1-0.68)/2)))
      
    for (f in 2:500){
  
        temp <- allspec[,cond,level,f]
        mbs <- bootstrap2D(temp)
meanspectraTF[cond,level,f] <- mbs$meanamp
meanspectraTFCI[1,cond,level,f] <- mbs$lowerCI
meanspectraTFCI[2,cond,level,f] <- mbs$upperCI
    }
  }
}

save(file=paste0(datadir,'AveragedataTF.RData'),list=c('cleanmeansTF','cleanmeansTFCI','meanspectraTF','meanspectraTFCI','meanratios','meanratiosCI'))

}

```

```{r createTFfig, include=FALSE, results='hide'}

# generate figure showing the TF data

if (processdata > 0){
  
         if (!file.exists(paste0(datadir,'AveragedataTF.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '2qu6y'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name=='AveragedataTF.RData')
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
         }
  
  load(paste0(datadir,'AveragedataTF.RData'))
  
  TFs <- c(2,4,8,16,30)
  TFsdB <- 20*log10(TFs)
  
  postscript("SpecTF.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 8, width = 5.5)

frequencies <- (0:499)/10

plotlims <- c(0,36,0,5) 
ticklocsx <- seq(0,36,6)    # locations of tick marks on x axis
ticklocsy <- seq(0,5,1)    # locations of tick marks on y axis
ticklabelsx <- 2^(0:6)        # set labels for x ticks
ticklabelsy <- c(0,1,'','','','')    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
title(xlab="Frequency (Hz)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude (ÂµV)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)


for (cond in 1:5){
  
lines(c(0,36),c(cond,cond)-1)  
polygon(20*log10(frequencies[c(11:490,490:11)]),(cond-1)+c(meanspectraTFCI[1,2,cond,11:490],meanspectraTFCI[2,2,cond,490:11]),col=colpal[cond],border=NA)

lines(20*log10(frequencies[11:490]),(cond-1)+abs(meanspectraTF[2,cond,11:490]), col=colpal[cond], lwd=2, cex=0.5) 
}

text(33,0.25,'2Hz',adj=0.5,cex=1.5,col=colpal[1])
text(33,1.25,'4Hz',adj=0.5,cex=1.5,col=colpal[2])
text(33,2.25,'8Hz',adj=0.5,cex=1.5,col=colpal[3])
text(33,3.25,'16Hz',adj=0.5,cex=1.5,col=colpal[4])
text(33,4.25,'30Hz',adj=0.5,cex=1.5,col=colpal[5])

text(1.5,4.8,'(a)',adj=0.5,cex=2.5)
text(18,4.8,'Binocular',adj=0.5,cex=2)

dev.off()
  
  
  
plotlims <- c(6,30,0,1)  
ticklocsx <- seq(6,30,6)    # locations of tick marks on x axis
ticklocsy <- seq(0,1,0.2)    # locations of tick marks on y axis
ticklabelsx <- 2^(1:5)        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

postscript("TF1.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Frequency (Hz)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude (ÂµV)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

for (cond in 1:2){
  lines(TFsdB,abs(cleanmeansTF[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  arrows(TFsdB,abs(cleanmeansTF[cond,]),TFsdB,cleanmeansTFCI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  arrows(TFsdB,abs(cleanmeansTF[cond,]),TFsdB,cleanmeansTFCI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  points(TFsdB,abs(cleanmeansTF[cond,]), pch = 20+cond, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves
}  
legend(20,1,c('Monocular','Binocular'),pch=21:22,pt.bg=colpal[1:2],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(7.5,0.92,'(b)',adj=0.5,cex=2.5)

dev.off()
  

plotlims <- c(6,30,-3,12)  
ticklocsy <- seq(-3,12,3)    # locations of tick marks on y axis
ticklabelsy <- c(expression(1/sqrt(2)),'1',expression(sqrt(2)),'2',expression(2*sqrt(2)),'4')

postscript("TF2.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Frequency (Hz)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Bin:Mon ratio", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

  lines(TFsdB,meanratios, col=colpal[3], lwd=3, cex=0.5)
  arrows(TFsdB,meanratios,TFsdB,meanratiosCI[1,],lwd=3,col=colpal[3],length=0.05,angle=90)
  arrows(TFsdB,meanratios,TFsdB,meanratiosCI[2,],lwd=3,col=colpal[3],length=0.05,angle=90)
  points(TFsdB,meanratios, pch = 20+3, col='black', bg=colpal[3], cex=1.6, lwd=3)   
 text(7.5,11,'(c)',adj=0.5,cex=2.5)

dev.off()


  PostScriptTrace('SpecTF.ps')
  p1 <- readPicture('SpecTF.ps.xml')
  PostScriptTrace('TF1.ps')
  p2 <- readPicture('TF1.ps.xml')
  PostScriptTrace('TF2.ps')
  p3 <- readPicture('TF2.ps.xml')
  
    for (n in 1:length(p1@paths)){
    temp <- class(p1@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(p1@paths[n]$path@rgb))<765){p1@paths[n]$path@rgb <- addalpha(p1@paths[n]$path@rgb,alpha=0.2)}}}
  
  pdf(paste0(figdir,"TFdata.pdf"), bg="transparent", height = 12, width = 15)
  par(mar=c(0.1,0.1,0.1,0.1))
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(0,1), ylim=c(0,1))
  
  grid.picture(p1,x=0.3,y=0.5,width=0.6,height=1)
  grid.picture(p2,x=0.78,y=0.74,width=0.4,height=1)
  grid.picture(p3,x=0.78,y=0.26,width=0.4,height=1)

  dev.off()
  
  file.remove(c('TF1.ps','TF2.ps','SpecTF.ps','TF1.ps.xml','TF2.ps.xml','SpecTF.ps.xml'))


}

```

Results from the temporal frequency experiment are shown in Figure \@ref(fig:TFdata). Figure \@ref(fig:TFdata)a shows the Fourier spectra for responses to binocular flicker at 5 different frequencies (2, 4, 8, 16, and 30 Hz). From 2 to 16 Hz, clear signals are observed at each fundamental frequency, and typically also their higher harmonics (integer multiples of the fundamental). However, at 30 Hz (upper row), the responses recorded were not demonstrably above the noise baseline. Figure \@ref(fig:TFdata)b compares the monocular and binocular responses at each stimulation frequency. Here we replicate the substantial summation effect across frequencies up to and including 16Hz (Fig. \@ref(fig:TFdata)c), demonstrating that strong binocular facilitation in the EEG data of Experiment 1 cannot be attributed to our use of 2Hz flicker.

```{r TFdata, fig.cap="Binocular facilitation at different temporal frequencies, measured using EEG. Panel (a) shows Fourier spectra for responses to binocular flicker at 5 different frequencies (offset vertically for clarity). Panel (b) shows the response at each stimulation frequency for monocular (red circles) and binocular (blue squares) presentation. Panel (c) shows the ratio of binocular to monocular responses. Error bars and shaded regions indicate bootstrapped standard errors across N=12 participants.", fig.align="center", echo=FALSE}

knitr::include_graphics(paste0(figdir,'TFdata.pdf'))

```

## Experiment 3

In Experiment 1 we found evidence of stronger binocular facilitation for cortical responses to luminance flicker (measured using EEG), compared with subcortical responses (measured using pupillometry; see Figure \@ref(fig:BSratios)). Since perception is dependent on cortical responses, these results provide a clear prediction for perceived contrast judgements indexed by psychophysical contrast matching paradigms [e.g. @Anstis1998; @Levelt1965; @Legge1981; @Quaia2018]. We therefore conducted such an experiment, in which participants judged which of two stimuli had the greater perceived amplitude of flicker. On each trial, one stimulus was a matching stimulus, that had a fixed binocular flicker amplitude of either 24\% or 48\% (temporal) contrast. The other stimulus was a target stimulus, the contrast of which was controlled by a staircase algorithm. We tested 9 ratios of target contrast between the left and right eyes.

The results from the matching experiment are shown in Figure \@ref(fig:matchingdata). Each data point indicates the contrast levels required in each eye that were perceptually equivalent to the binocular 24\% (red circles) and 48\% (blue circles) matching contrasts. At both matching contrasts, we see a very substantial increase in the physical contrast required for a monocular target (data points along the *x*- and *y*-axes), compared to a binocular target (points along the diagonal of *x*=*y*). For example with a 48\% match, the monocular targets required contrasts close to 100\%, whereas binocular targets required a contrast of around 50\%. The data points between these extremes also fall close to the predictions of a linear summation model (diagonal dotted lines), and are inconsistent with a winner-takes-all (or MAX) model (dashed lines). Overall, these matching results are consistent with the approximately linear summation effects observed in the EEG data of Experiment 1 (Figure \@ref(fig:EEGdata)c,f).

```{r exp3analysis, include=FALSE, results='hide'}

# (download and) analyse individual participant data for the matching experiment

ratiosL <- c(1, 1, 1, 1, 1, 0.75, 0.5, 0.25, 0)
ratiosR <- c(0, 0.25, 0.5, 0.75, 1, 1, 1, 1, 1)

if (processdata > 2){
  
if (!file.exists(paste0(datadir,'matchingdata.csv'))){
osfnode <- 'ey7rg'  
osfproject <- osf_retrieve_node(osfnode)
matchingfiles <- osf_ls_files(osfproject,n_max=300)
fid <- which(matchingfiles$name=='matchingdata.csv')
osf_download(matchingfiles[fid,],datadir,progress=TRUE)
}

matchingdata <- read.csv(paste0(datadir,'matchingdata.csv'))  

levels <- unique(matchingdata$allref)
subjects <- unique(matchingdata$Participant)

allthresh <- array(0,dim=c(length(subjects),length(levels),length(ratiosL)))
for (subj in 1:length(subjects)){
  thissubj <- subset(matchingdata,Participant==subj)  
  levels <- unique(thissubj$allref)
for (cond in 1:length(levels)){
  thiscond <- subset(thissubj,allref==levels[cond])
  contrast <- levels[cond]
  for (ll in 1:length(ratiosL)){
    Lratio <- ratiosL[ll]
    Rratio <- ratiosR[ll]
    thisL <- subset(thiscond, allLratio==Lratio)
    thisdata <- subset(thisL, allRratio==Rratio)
   
Ncorrect <- NULL
Ntrials <- NULL
Clevs <- sort(unique(thisdata$allcontrast))
for (lev in 1:length(Clevs)){
  temp <- subset(thisdata,allcontrast==Clevs[lev])
  Ncorrect[lev] <- sum(temp$correct)
  Ntrials[lev] <- nrow(temp)
}
CdB <- 20*log10(Clevs)
datatofit <- data.frame(CdB,Ncorrect,Ntrials)
fit <- quickpsy::quickpsy(datatofit, x=CdB, k=Ncorrect, n=Ntrials, guess=0, xmin=0, xmax=40, B = 0, fun=cum_normal_fun)
allthresh[subj,cond,ll] <- fit$thresholds$thre

# plot(datatofit$CdB,datatofit$Ncorrect/datatofit$Ntrials)
# points(datatofit$CdB,datatofit$Ncorrect/datatofit$Ntrials,pch=16)
# lines(fit$curves$x,fit$curves$y)

  }
}
}

allthresh[1,2,] <- NA   # exclude outliers
allthresh[2,2,2] <- NA  # exclude outliers
meanthresh <- apply(allthresh,2:3,mean,na.rm=TRUE)
SEthresh <- apply(allthresh,2:3,sd,na.rm=TRUE)/sqrt(apply(!is.na(allthresh),2:3,sum))

save(file=paste0(datadir,'meanmatching.RData'),list=c('meanthresh','SEthresh','allthresh'))

}

if (processdata > 0){
  
  
           if (!file.exists(paste0(datadir,'meanmatching.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '2qu6y'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name=='meanmatching.RData')
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
           }
  
load(paste0(datadir,'meanmatching.RData'))
  
pdf(paste0(figdir,"matchingdata.pdf"), bg="transparent", height = 5.5, width = 5.5)

plotlims <- c(0,125,0,125)  
ticklocs <- seq(0,125,25)   

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   
axis(1, at=ticklocs, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocs, tck=0.01, lab=F, lwd=2)
mtext(text = ticklocs, side = 1, at=ticklocs)     # add the tick labels
mtext(text = ticklocs, side = 2, at=ticklocs, line=0.2, las=1)
title(xlab="Right eye contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
title(ylab="Left eye contrast (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

lines(c(0,24),c(24,24),lty=2)
lines(c(0,48),c(48,48),lty=2)
lines(c(24,24),c(0,24),lty=2)
lines(c(48,48),c(0,48),lty=2)
lines(c(0,96),c(96,0),lty=3)
lines(c(0,48),c(48,0),lty=3)

for (matchlev in 1:2){
lines(ratiosR*10^(meanthresh[matchlev,]/20),ratiosL*10^(meanthresh[matchlev,]/20),pch=16,col=colpal[matchlev],lwd=3)}

# # these lines of code plot the individual participants' data for checking
# for (subj in 1:10){
# for (matchlev in 1:2){
#   lines(ratiosL*10^(allthresh[subj,matchlev,]/20),ratiosR*10^(allthresh[subj,matchlev,]/20),pch=16,col=colpal[matchlev],lwd=1)
# for (cond in 1:9){
#   points(ratiosL[cond]*10^(allthresh[subj,matchlev,cond]/20),ratiosR[cond]*10^(allthresh[subj,matchlev,cond]/20),pch=16,cex=1,col=colpal[matchlev])}}}


for (matchlev in 1:2){
for (cond in 1:9){
  points(ratiosR[cond]*10^(meanthresh[matchlev,cond]/20),ratiosL[cond]*10^(meanthresh[matchlev,cond]/20),pch=16,cex=2,col=colpal[matchlev])
  
  if ((SEthresh[matchlev,cond]+meanthresh[matchlev,cond])<42){
  arrows(ratiosR[cond]*10^(meanthresh[matchlev,cond]/20),ratiosL[cond]*10^(meanthresh[matchlev,cond]/20),ratiosR[cond]*10^((SEthresh[matchlev,cond]+meanthresh[matchlev,cond])/20),ratiosL[cond]*10^((SEthresh[matchlev,cond]+meanthresh[matchlev,cond])/20),length=0.015, angle=90, lwd=2)
  }
  
  # plot as an arrow if exceeding the axis limits
  if ((SEthresh[matchlev,cond]+meanthresh[matchlev,cond])>42){
  arrows(ratiosR[cond]*10^(meanthresh[matchlev,cond]/20),ratiosL[cond]*10^(meanthresh[matchlev,cond]/20),125,ratiosL[cond]*10^((SEthresh[matchlev,cond]+meanthresh[matchlev,cond])/20),length=0.035, angle=45, lwd=2)
  }
  
  arrows(ratiosR[cond]*10^(meanthresh[matchlev,cond]/20),ratiosL[cond]*10^(meanthresh[matchlev,cond]/20),ratiosR[cond]*10^((meanthresh[matchlev,cond]-SEthresh[matchlev,cond])/20),ratiosL[cond]*10^((meanthresh[matchlev,cond]-SEthresh[matchlev,cond])/20),length=0.015, angle=90, lwd=2)
}
}

legend(75,95,c('48% match','24% match'),pch=16,col=colpal[2:1],pt.cex=2,box.lwd=2)

legend(45.75,125,c('Winner-take-all','Linear summation'),lty=2:3,box.lwd=2)

dev.off()

}

```
  
```{r matchingdata, fig.cap="Contrast matching functions. Dotted and dashed lines are predictions of canonical summation models involving linear combination (dotted) or a winner-take-all rule (dashed). Error bars indicate the standard error across participants (N=10), and are constrained along radial lines converging at the origin. Note that, for the {48\\%} match, the data point on the x axis falls higher than {100\\%} contrast. This is because the psychometric function fits for some individuals were interpolated such that the PSE fell above {100\\%}, shifting the mean slightly above that value.", out.width = '50%', fig.align="center", echo=FALSE}

knitr::include_graphics(paste0(figdir,'matchingdata.pdf'))

```

## Computational modelling

We fitted a computational model to the data from Experiments 1 & 3 using a hierarchical Bayesian approach. The model behaviour is displayed in Figure \@ref(fig:modelfigure)e-h, with empirical data replotted in Figure \@ref(fig:modelfigure)a-d for comparison. In general, the model captures the key characteristics of the empirical data, with group-level parameter estimates provided in Table \@ref(tab:paramtable). We were particularly interested in comparing the weight of interocular suppression across data sets. We therefore plot the posterior distributions for this parameter for all four data sets (see Figure \@ref(fig:modelfigure)i). The key finding is that the pupillometry results (green distribution) display a much greater weight of interocular suppression compared with the other data sets (grey, purple and yellow distributions). There is no overlap between the pupillometry distribution and any of the other three. All four distributions are also meaningfully below a weight of 1 -- the value that previous work using grating stimuli would predict [@Meese2006; @Baker2017], and the peak location of our prior distribution (black curve). These results offer an explanation of the empirical data: the strong interocular suppression for the pupillometry data is consistent with the weak binocular facilitation, and measurable dichoptic masking observed using that method. The weaker suppression for the other experiments is consistent with the near-linear binocular facilitation effects, and absent dichoptic masking.

```{r makestanmodels, include=FALSE, results='hide'}

# create text objects for Stan models

CRFmodelstring = "
  data {
    int<lower=1> Nsubj ;
    int<lower=1> Ntotal ;
    real y[Ntotal] ;
    real x[Ntotal] ;
    real<lower=0> w[Ntotal] ;
    int<lower=1> c[Ntotal] ;
    int<lower=1> s[Ntotal] ;
  }
  parameters {
    real<lower=1> Z[Nsubj] ;
    real<lower=0> Rmax[Nsubj] ;
    real<lower=0> wt[Nsubj] ;
    real<lower=0> k[Nsubj] ;
    real<lower=0> sigma ;
    real<lower=1> Zmu ; 
    real<lower=0> Rmaxmu ; 
    real<lower=0> wtmu ; 
    real<lower=0> kmu ; 
    real<lower=0> Zsigma ;
    real<lower=0> Rmaxsigma ;
    real<lower=0> wtsigma ;
    real<lower=0> ksigma ;
    real<lower=0> nu ;
  }
  model {
    Zmu ~ normal( 5 , 2 ) ;
    Rmaxmu ~ normal( 1 , 0.5 ) ;
    wtmu ~ normal( 1 , 0.5 ) ;
    kmu ~ normal( 5 , 2 ) ;
    sigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    Zsigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    Rmaxsigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    wtsigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    ksigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    nu ~ exponential(1/30.0) ;
    Z ~ normal( Zmu , Zsigma ) ; // vectorized
    Rmax ~ normal( Rmaxmu , Rmaxsigma ) ; // vectorized
    wt ~ normal( wtmu , wtsigma ) ; // vectorized
    k ~ normal( kmu , ksigma ) ; // vectorized
    for ( i in 1:Ntotal ) {
    
    if (c[i]==1)  // monocular condition
       y[i] ~ student_t( 
                nu ,
                k[s[i]] + (Rmax[s[i]]*(pow(x[i],2))/(Z[s[i]] + x[i])) ,
                w[i]*sigma ) ;
                
     else if (c[i]==2)  // binocular condition 
       y[i] ~ student_t( 
                nu ,
                k[s[i]] + (Rmax[s[i]]*((pow(x[i],2))/(Z[s[i]] + x[i] + wt[s[i]]*x[i]) + (pow(x[i],2))/(Z[s[i]] + x[i] + wt[s[i]]*x[i]))),
                w[i]*sigma ) ;   
                
     else if (c[i]==3)  // dichoptic condition
       y[i] ~ student_t( 
                nu ,
                k[s[i]] + (Rmax[s[i]]*((pow(x[i],2))/(Z[s[i]] + x[i] + wt[s[i]]*48) + (pow(48,2))/(Z[s[i]] + 48 + wt[s[i]]*x[i]))),
                w[i]*sigma ) ;  
                
                
     else if (c[i]==4)  // binocular cross condition 
       y[i] ~ student_t( 
                nu ,
                k[s[i]] + (Rmax[s[i]]*(pow(x[i],2))/(Z[s[i]] + x[i] + wt[s[i]]*x[i])) ,
                w[i]*sigma ) ;                  
                
                
     else if (c[i]==5)  // dichoptic cross condition
       y[i] ~ student_t( 
                nu ,
                k[s[i]] + (Rmax[s[i]]*(pow(x[i],2))/(Z[s[i]] + x[i] + wt[s[i]]*48)) ,
                w[i]*sigma ) ;       
    }
  }

  " # close quote for CRFmodelstring


matchingmodelstring = "
  data {
    int<lower=1> Nsubj ;
    int<lower=1> Ntotal ;
    int correct[Ntotal] ;
    real allcontrast[Ntotal] ;
    real allref[Ntotal] ;
    real allLratio[Ntotal] ;
    real allRratio[Ntotal] ;    
    int<lower=1> s[Ntotal] ;
  }
  parameters {
    real<lower=0> Z[Nsubj] ;
    real<lower=0> k[Nsubj] ;
    real<lower=0> w[Nsubj] ;
    real<lower=0> sigma ;
    real<lower=0> Zmu ; 
    real<lower=0> kmu ; 
    real<lower=0> wmu ;     
    real<lower=0> Zsigma ;
    real<lower=0> ksigma ;
    real<lower=0> wsigma ;
    }
  model {
    Zmu ~ normal( 5 , 2 ) ;
    wmu ~ normal( 1 , 0.5 ) ;
    kmu ~ normal( 5 , 2 ) ;
    sigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    Zsigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    ksigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    wsigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    Z ~ normal( Zmu , Zsigma ) ; // vectorized
    k ~ normal( kmu , ksigma ) ; // vectorized
    w ~ normal( wmu , wsigma ) ; // vectorized  

    for ( i in 1:Ntotal ) {
    
      real standresp ;
      real matchrespL ;
      real matchrespR ;
      real matchresp ;
    
      standresp = 2 * pow(allref[i],2) / (Z[s[i]] + allref[i] + w[s[i]]*allref[i]);
      matchrespL = pow(allLratio[i]*allcontrast[i],2) / (Z[s[i]] + allLratio[i]*allcontrast[i] + w[s[i]]*allRratio[i]*allcontrast[i]);
      matchrespR = pow(allRratio[i]*allcontrast[i],2) / (Z[s[i]] + allRratio[i]*allcontrast[i] + w[s[i]]*allLratio[i]*allcontrast[i]);
      matchresp = matchrespL + matchrespR;
      correct[i] ~ bernoulli(((1 + erf((matchresp - standresp)/k[s[i]]))/2)*0.998 + 0.001) ;
    }
  }  
  " # close quote for matchingmodelstring


```

```{r runstanmodels, include=FALSE, results='hide'}

# do computational modelling

if (domodelling > 0){

if (!file.exists(paste0(datadir,'matchingdata.csv'))){
osfnode <- 'ey7rg'  
osfproject <- osf_retrieve_node(osfnode)
matchingfiles <- osf_ls_files(osfproject,n_max=300)
fid <- which(matchingfiles$name=='matchingdata.csv')
osf_download(matchingfiles[fid,],datadir,progress=TRUE)
}

matchingdata <- read.csv(paste0(datadir,'matchingdata.csv'))  

matchingdatalist = list(correct = matchingdata$correct, allLratio = matchingdata$allLratio, allRratio = matchingdata$allRratio, allcontrast = matchingdata$allcontrast, allref = matchingdata$allref, s = matchingdata$Participant, Nsubj = max(matchingdata$Participant), Ntotal = nrow(matchingdata))

for (participant in 1:30){
         # if the tar file of this participant's data doesn't exist
         if (!file.exists(paste0(datadir,'P',100+participant,'summary.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '2qu6y'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name==paste0('P',100+participant,'summary.RData'))
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
         }
}

d <- paste0('P',101:130,'summary.RData')

allmasksP <- array(0,dim=c(length(d),6,5))
allmeansP <- allmasksP
allmasksE <- array(0,dim=c(length(d),64,6,5))
allmeansE <- allmasksE
allmeansE2 <- allmeansE
allmasksE2 <- allmasksE

  for (s in 1:length(d)){
    
    load(paste0(datadir,d[s]))
    
  allmasksP[s,,] <- cleanmasksP
  allmeansP[s,,] <- cleanmeansP
  allmeansE[s,,,] <- cleanmeansE
  allmasksE[s,,,] <- cleanmasksE
  allmeansE2[s,,,] <- cleanmeansE2
  allmasksE2[s,,,] <- cleanmasksE2
    
  }
  electrodeindices <- match(targetelectrodes,electrodes)-2

  # THE DATA
  condlist <- c(1,2,3,5,6)
  contlist <- c(6,12,24,48,96)
  y <- NULL
  x <- NULL
  c <- NULL
  s <- NULL
  w <- NULL
  i <- 0
  for (subj in 1:dim(allmeansP)[1]){
    for (cond in 1:length(condlist)){
      for (cont in 1:length(contlist)){
        dp <- abs(allmeansP[subj,condlist[cond],cont])
        if (is.na(dp)==0){
          if (is.infinite(dp)==0){
          i <- i + 1
          x[i] <- contlist[cont]
          y[i] <- dp
          c[i] <- cond
          s[i] <- subj
          w[i] <- 1
          }
        }
      }
    }
  }

pupildatalist = list(x = x, y = y, s = s, w = w, c = c, Nsubj = max(s), Ntotal = length(y))

  y <- NULL
  x <- NULL
  c <- NULL
  s <- NULL
  w <- NULL
  i <- 0
  for (subj in 1:dim(allmeansE)[1]){
    for (cond in 1:length(condlist)){
      for (cont in 1:length(contlist)){
        dp <- abs(mean(allmeansE[subj,electrodeindices,condlist[cond],cont]))
        if (is.na(dp)==0){
          if (is.infinite(dp)==0){
            i <- i + 1
            x[i] <- contlist[cont]
            y[i] <- dp
            c[i] <- cond
            s[i] <- subj
            w[i] <- 1
          }
        }
      }
    }
  }
  
  EEG1Fdatalist = list(x = x, y = y, s = s, w = w, c = c, Nsubj = max(s), Ntotal = length(y))
  
  y <- NULL
  x <- NULL
  c <- NULL
  s <- NULL
  w <- NULL
  i <- 0
  for (subj in 1:dim(allmeansE)[1]){
    for (cond in 1:length(condlist)){
      for (cont in 1:length(contlist)){
        dp <- abs(mean(allmeansE2[subj,electrodeindices,condlist[cond],cont]))
        if (is.na(dp)==0){
          if (is.infinite(dp)==0){
            i <- i + 1
            x[i] <- contlist[cont]
            y[i] <- dp
            c[i] <- cond
            s[i] <- subj
            w[i] <- 1
          }
        }
      }
    }
  }
  
  EEG2Fdatalist = list(x = x, y = y, s = s, w = w, c = c, Nsubj = max(s), Ntotal = length(y))
  
  
# Translate Stan models to C++ and compile to DSO:
matchingmodel <- stan_model(model_code=matchingmodelstring)  
CRFmodel <- stan_model(model_code=CRFmodelstring)  


# Get MC sample of posterior:
pupilsamples <- sampling(object=CRFmodel, 
                    data = pupildatalist, 
                    chains = nChains,
                    iter = (ceiling(numSavedSteps/nChains)*thinSteps+burnInSteps), 
                    warmup = burnInSteps, 
                    thin = thinSteps,
                    cores = getOption("mc.cores", 1L))

EEG1Fsamples <- sampling(object=CRFmodel, 
                    data = EEG1Fdatalist, 
                    chains = nChains,
                    iter = (ceiling(numSavedSteps/nChains)*thinSteps+burnInSteps), 
                    warmup = burnInSteps, 
                    thin = thinSteps,
                    cores = getOption("mc.cores", 1L))

EEG2Fsamples <- sampling(object=CRFmodel, 
                    data = EEG2Fdatalist, 
                    chains = nChains,
                    iter = (ceiling(numSavedSteps/nChains)*thinSteps+burnInSteps), 
                    warmup = burnInSteps, 
                    thin = thinSteps,
                    cores = getOption("mc.cores", 1L))

matchingsamples <- sampling(object=matchingmodel, 
                    data = matchingdatalist, 
                    chains = nChains,
                    iter = (ceiling(numSavedSteps/nChains)*thinSteps+burnInSteps), 
                    warmup = burnInSteps, 
                    thin = thinSteps,
                    cores = getOption("mc.cores", 1L))

save(file=paste0(datadir,'modeloutput.RData'),list=c('pupilsamples','EEG1Fsamples','EEG2Fsamples','matchingsamples'))

}


```

```{r makemodelfigure, include=FALSE, results='hide'}

# create figure containing modelling results

if (!file.exists(paste0(datadir,'modeloutput.RData'))){
osfnode <- '2qu6y'  
osfproject <- osf_retrieve_node(osfnode)
osffilesP <- osf_ls_files(osfproject,n_max=300)
fid <- which(osffilesP$name=='modeloutput.RData')
osf_download(osffilesP[fid,],datadir,progress=TRUE)
}

  load(paste0(datadir,'modeloutput.RData'))
  
  nchains <- dim(pupilsamples)[2]
  pupilweightpop <- NULL
  pupilZpop <- NULL
  pupilKpop <- NULL
  pupilRpop <- NULL
  for (n in 1:nchains){
  pupilweightpop <- c(pupilweightpop,pupilsamples@sim$samples[[n]]$wtmu)
  pupilZpop <- c(pupilZpop,pupilsamples@sim$samples[[n]]$Zmu)
  pupilKpop <- c(pupilKpop,pupilsamples@sim$samples[[n]]$kmu)
  pupilRpop <- c(pupilRpop,pupilsamples@sim$samples[[n]]$Rmaxmu)
  }
  pupilW <- median(pupilweightpop)
  pupilZ <- median(pupilZpop)
  pupilK <- median(pupilKpop)
  pupilRmax <- median(pupilRpop)
  
  
  nchains <- dim(EEG1Fsamples)[2]
  EEGweightpop <- NULL
  EEGZpop <- NULL
  EEGKpop <- NULL
  EEGRpop <- NULL
  for (n in 1:nchains){
  EEGweightpop <- c(EEGweightpop,EEG1Fsamples@sim$samples[[n]]$wtmu)
  EEGZpop <- c(EEGZpop,EEG1Fsamples@sim$samples[[n]]$Zmu)
  EEGKpop <- c(EEGKpop,EEG1Fsamples@sim$samples[[n]]$kmu)
  EEGRpop <- c(EEGRpop,EEG1Fsamples@sim$samples[[n]]$Rmaxmu)
  }
  EEGW <- median(EEGweightpop)
  EEGZ <- median(EEGZpop)
  EEGK <- median(EEGKpop)
  EEGRmax <- median(EEGRpop)
  
  nchains <- dim(EEG2Fsamples)[2]
  EEG2weightpop <- NULL
  EEG2Zpop <- NULL
  EEG2Kpop <- NULL
  EEG2Rpop <- NULL
  for (n in 1:nchains){
  EEG2weightpop <- c(EEG2weightpop,EEG2Fsamples@sim$samples[[n]]$wtmu)
  EEG2Zpop <- c(EEG2Zpop,EEG2Fsamples@sim$samples[[n]]$Zmu)
  EEG2Kpop <- c(EEG2Kpop,EEG2Fsamples@sim$samples[[n]]$kmu)
  EEG2Rpop <- c(EEG2Rpop,EEG2Fsamples@sim$samples[[n]]$Rmaxmu)
  }
  EEG2W <- median(EEG2weightpop)
  EEG2Z <- median(EEG2Zpop)
  EEG2K <- median(EEG2Kpop)
  EEG2Rmax <- median(EEG2Rpop)

  nchains <- dim(matchingsamples)[2]
  matchingweightpop <- NULL
  matchingZpop <- NULL
  matchingKpop <- NULL
  for (n in 1:nchains){
  matchingweightpop <- c(matchingweightpop,matchingsamples@sim$samples[[n]]$wmu)
  matchingZpop <- c(matchingZpop,matchingsamples@sim$samples[[n]]$Zmu)
  matchingKpop <- c(matchingKpop,matchingsamples@sim$samples[[n]]$kmu)
  }
  matchingW <- median(matchingweightpop)
  matchingZ <- median(matchingZpop)
  matchingK <- median(matchingKpop)


  if (processdata > 0){
    
postscript('posteriors.ps', horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

plotlims <- c(-48,12,0,0.6) 
ticklocsx <- seq(-48,12,12)    
ticklocsy <- seq(0,0.6,0.1)    
ticklabelsx <- c('1/256','1/64','1/16','1/4','1','4')        
ticklabelsy <- ticklocsy    # set labels for y ticks

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)    
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)   
 
title(xlab="w", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
title(ylab="Probability", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

a <- density(20*log10(pupilweightpop),from=-48,to=12)   
polygon(c(-48,a$x,12), c(0,a$y,0), col=colpal[3],border=NA) 

a <- density(20*log10(EEGweightpop),from=-48,to=12)   
polygon(c(-48,a$x,12), c(0,a$y,0), col=colpal[4],border=NA) 

a <- density(20*log10(EEG2weightpop),from=-48,to=12)   
polygon(c(-48,a$x,12), c(0,a$y,0), col=colpal[5],border=NA) 

a <- density(20*log10(matchingweightpop),from=-48,to=12)   
polygon(c(-48,a$x,12), c(0,a$y,0), col=colpal[6],border=NA) 

prior <- dnorm(10^((-48:12)/20),1,0.5)
prior <- 0.5*prior/max(prior)
lines(-48:12,prior)

lines(20*log10(c(mean(pupilW),mean(pupilW))),c(0,0.6),lwd=3,col=colpal[3])
lines(20*log10(c(mean(EEGW),mean(EEGW))),c(0,0.6),lwd=3,col=colpal[4])
lines(20*log10(c(mean(EEG2W),mean(EEG2W))),c(0,0.6),lwd=3,col=colpal[5])
lines(20*log10(c(mean(matchingW),mean(matchingW))),c(0,0.6),lwd=3,col=colpal[6])

legend(-48,0.6,c('Prior','Pupillometry','EEG 1F','EEG 2F','Matching'),col=c('black',colpal[3:6]),lwd=c(1,3,3,3,3),lty=1, box.lwd=2, bg='white')

text(9,0.58,'(i)',cex=1.25,adj=0.5)

dev.off()


finex <- 10^(seq(20*log10(6),20*log10(96),length=100)/20)

w <- pupilW
Z <- pupilZ
k <- pupilRmax
n <- pupilK/sqrt(30)
q <- 2
modelA <- matrix(0,nrow=6,ncol=length(finex))
modelB <- matrix(0,nrow=6,ncol=length(finex))
# mon condition
R <- 0
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[1,] <- k*(Lresp + Rresp) + n
modelB[1,] <- n

# bin condition
R <- finex
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[2,] <- k*(Lresp + Rresp) + n
modelB[2,] <- n

# dich condition
R <- 48
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[3,] <- k*(Lresp + Rresp) + n
modelB[3,] <- n

# mon X condition
R <- 0
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[4,] <- n
modelB[4,] <- k*(Lresp + Rresp) + n

# bin X condition
R <- finex
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[5,] <- k*(Lresp) + n 
modelB[5,] <- k*(Rresp) + n  

# dich X condition
L <- finex
R <- 48
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[6,] <- k*(Lresp) + n 
modelB[6,] <- k*(Rresp) + n  



contrastsdB <- 20*log10(c(6,12,24,48,96))

plotlims <- c(15,40,0,0.04)
ticklocsx <- contrastsdB    # locations of tick marks on x axis
ticklabelsx <-c(6,12,24,48,96)        # set labels for x ticks
ticklocsy <- seq(0,0.04,0.01)    # locations of tick marks on y axis
ticklabelsy <- ticklocsy    # set labels for y ticks

postscript(paste("CRF1p.ps",sep=''), horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)    
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)    
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
title(ylab="Amplitude at 2Hz (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

condlist <- c(1,2,3,6)
for (cond in 1:4){lines(20*log10(finex),modelA[condlist[cond],], col=colpal[condlist[cond]], lwd=3, cex=0.5)}

legend(21,0.04,c('Monocular','Binocular','Dichoptic','Dichoptic cross'),lwd=3,col=colpal[condlist],box.lwd=2)

text(17,0.037,'(e)',adj=0.5,cex=2.5)

dev.off()  


w <- EEGW
Z <- EEGZ
k <- EEGRmax
n <- EEGK/sqrt(30)
q <- 2
modelA <- matrix(0,nrow=6,ncol=length(finex))
modelB <- matrix(0,nrow=6,ncol=length(finex))
# mon condition
R <- 0
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[1,] <- k*(Lresp + Rresp) + n
modelB[1,] <- n

# bin condition
R <- finex
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[2,] <- k*(Lresp + Rresp) + n
modelB[2,] <- n

# dich condition
R <- 48
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[3,] <- k*(Lresp + Rresp) + n
modelB[3,] <- n

# mon X condition
R <- 0
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[4,] <- n
modelB[4,] <- k*(Lresp + Rresp) + n

# bin X condition
R <- finex
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[5,] <- k*(Lresp) + n 
modelB[5,] <- k*(Rresp) + n  

# dich X condition
L <- finex
R <- 48
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[6,] <- k*(Lresp) + n 
modelB[6,] <- k*(Rresp) + n  

plotlims <- c(15,40,0,1)  
ticklocsy <- seq(0,1,0.2)    # locations of tick marks on y axis
ticklabelsy <- ticklocsy    # set labels for y ticks

postscript("CRF1e.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)    
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)    
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
title(ylab="Amplitude at 2Hz (ÂµV) ", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

condlist <- c(1,2,3,6)
for (cond in 1:4){lines(20*log10(finex),modelA[condlist[cond],], col=colpal[condlist[cond]], lwd=3, cex=0.5)}

# legend(21,0.8,c('Monocular','Binocular','Dichoptic','Dichoptic cross'),lwd=3,col=colpal[condlist],box.lwd=2)

text(17,0.95,'(f)',adj=0.5,cex=2.5)

dev.off()


w <- EEG2W
Z <- EEG2Z
k <- EEG2Rmax
n <- EEG2K/sqrt(30)
q <- 2
modelA <- matrix(0,nrow=6,ncol=length(finex))
modelB <- matrix(0,nrow=6,ncol=length(finex))
# mon condition
R <- 0
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[1,] <- k*(Lresp + Rresp) + n
modelB[1,] <- n

# bin condition
R <- finex
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[2,] <- k*(Lresp + Rresp) + n
modelB[2,] <- n

# dich condition
R <- 48
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[3,] <- k*(Lresp + Rresp) + n
modelB[3,] <- n

# mon X condition
R <- 0
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[4,] <- n
modelB[4,] <- k*(Lresp + Rresp) + n

# bin X condition
R <- finex
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[5,] <- k*(Lresp) + n 
modelB[5,] <- k*(Rresp) + n  

# dich X condition
L <- finex
R <- 48
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[6,] <- k*(Lresp) + n 
modelB[6,] <- k*(Rresp) + n  

plotlims <- c(15,40,0,1)  
ticklocsy <- seq(0,1,0.2)    # locations of tick marks on y axis
ticklabelsy <- ticklocsy    # set labels for y ticks

postscript("CRF2e.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)    
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)    
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude at 4Hz (ÂµV) ", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

condlist <- c(1,2,3,6)
for (cond in 1:4){lines(20*log10(finex),modelA[condlist[cond],], col=colpal[condlist[cond]], lwd=3, cex=0.5)}

# legend(21,0.8,c('Monocular','Binocular','Dichoptic','Dichoptic cross'),lwd=3,col=colpal[condlist],box.lwd=2)

text(17,0.95,'(g)',adj=0.5,cex=2.5)

dev.off()



# very finely sampled ratios to produce smooth curves
ratiosL <- seq(0,1,length=100)
ratiosR <- rep(1,100)

params <- c(2,matchingZ,matchingW)

binmodel <- function(L,R,p){
  # this is the two-stage model with a linear denominator and saturation constant
  stage1L <- (L^p[1])/(p[2] + L + p[3]*R)
  stage1R <- (R^p[1])/(p[2] + R + p[3]*L)
  resp <- stage1L + stage1R

  return(resp)}

getmatch <- function(L,R,ratios,p){
  standardresp <- binmodel(L,R,p)
  contrast <- 0
  matchresp <- 0
  while (matchresp<standardresp){
    contrast <- contrast + 0.1
    matchresp <- binmodel(contrast*ratios[1],contrast*ratios[2],p)
  }
  
  return(contrast)}

postscript("matchingmodel.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

plotlims <- c(0,125,0,125)  
ticklocs <- seq(0,125,25)   

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   
axis(1, at=ticklocs, tck=0.01, lab=F, lwd=2)
axis(2, at=ticklocs, tck=0.01, lab=F, lwd=2)
mtext(text = ticklocs, side = 1, at=ticklocs)     # add the tick labels
mtext(text = ticklocs, side = 2, at=ticklocs, line=0.2, las=1)
title(xlab="Right eye contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
title(ylab="Left eye contrast (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

standardcontrast <- 48

matchlist <- NULL
for (n in 1:length(ratiosL)){
  matchlist[n] <- getmatch(standardcontrast,standardcontrast,c(ratiosL[n],ratiosR[n]),params)
}

tempx <- c(matchlist*ratiosL, matchlist[100:1])
tempy <- c(matchlist, matchlist[100:1]*ratiosL[100:1])

lines(tempx,tempy,lwd=3,col=colpal[2])
lines(c(0,standardcontrast),c(standardcontrast,standardcontrast),lty=2)
lines(c(standardcontrast,standardcontrast),c(0,standardcontrast),lty=2)
lines(c(0,2*standardcontrast),c(2*standardcontrast,0),lty=3)

standardcontrast <- 24

matchlist <- NULL
for (n in 1:length(ratiosL)){
  matchlist[n] <- getmatch(standardcontrast,standardcontrast,c(ratiosL[n],ratiosR[n]),params)
}

tempx <- c(matchlist*ratiosL, matchlist[100:1])
tempy <- c(matchlist, matchlist[100:1]*ratiosL[100:1])
lines(tempx,tempy,lwd=3,col=colpal[1])

lines(c(0,standardcontrast),c(standardcontrast,standardcontrast),lty=2)
lines(c(standardcontrast,standardcontrast),c(0,standardcontrast),lty=2)
lines(c(0,2*standardcontrast),c(2*standardcontrast,0),lty=3)

legend(62,95,c('48% match','24% match'),col=colpal[2:1],lwd=3,pt.cex=2,box.lwd=2)

legend(45,125,c('Winner-take-all','Linear summation'),lty=2:3,box.lwd=2)

text(10,117.5,'(h)',adj=0.5,cex=2.5)

dev.off()


contrastsdB <- 20*log10(c(6,12,24,48,96))

         if (!file.exists(paste0(datadir,'Averagedata.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '2qu6y'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name=='Averagedata.RData')
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
         }

load(file=paste0(datadir,'Averagedata.RData'))
 

plotlims <- c(15,40,0,0.03) 
ticklocsx <- contrastsdB    # locations of tick marks on x axis
ticklocsy <- seq(0,0.03,0.01)    # locations of tick marks on y axis
ticklabelsx <-c(6,12,24,48,96)        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

postscript("pdata.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude at 2Hz (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansP[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  points(contrastsdB,abs(cleanmeansP[cond,]), pch = 20+cond, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves
}  
cond <- 6
  lines(contrastsdB,abs(cleanmeansP[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  points(contrastsdB,abs(cleanmeansP[cond,]), pch = 25, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves

legend(21,0.03,c('Monocular','Binocular','Dichoptic','Dichoptic cross'),pch=c(21:23,25),pt.bg=colpal[c(1:3,6)],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.028,'(a)',adj=0.5,cex=2.5)

dev.off()


plotlims <- c(15,40,0,1)  
ticklocsx <- contrastsdB    # locations of tick marks on x axis
ticklocsy <- seq(0,1,0.2)    # locations of tick marks on y axis
ticklabelsx <-c(6,12,24,48,96)        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

postscript("edata.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude (ÂµV) at 2Hz", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansEav[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  points(contrastsdB,abs(cleanmeansEav[cond,]), pch = 20+cond, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves
}  
cond <- 6
  lines(contrastsdB,abs(cleanmeansEav[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  points(contrastsdB,abs(cleanmeansEav[cond,]), pch = 25, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves

# legend(22,0.8,c('Monocular','Binocular','Dichoptic','Dichoptic cross'),pch=c(21:23,25),pt.bg=colpal[c(1:3,6)],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.95,'(b)',adj=0.5,cex=2.5)

dev.off()

postscript("edata2.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

plotlims <- c(15,40,0,1)  
ticklocsy <- seq(0,1,0.2)    # locations of tick marks on y axis
ticklabelsy <- ticklocsy    # set labels for y ticks

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude (ÂµV) at 4Hz", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansE2av[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  points(contrastsdB,abs(cleanmeansE2av[cond,]), pch = 20+cond, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves
}  
cond <- 6
  lines(contrastsdB,abs(cleanmeansE2av[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  points(contrastsdB,abs(cleanmeansE2av[cond,]), pch = 25, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves

# legend(22,0.8,c('Monocular','Binocular','Dichoptic','Dichoptic cross'),pch=c(21:23,25),pt.bg=colpal[c(1:3,6)],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.95,'(c)',adj=0.5,cex=2.5)

dev.off()

         if (!file.exists(paste0(datadir,'meanmatching.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '2qu6y'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name=='meanmatching.RData')
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
         }

load(paste0(datadir,'meanmatching.RData'))
  
postscript("matchingdata.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

plotlims <- c(0,125,0,125)  
ticklocs <- seq(0,125,25)   
ratiosL <- c(1, 1, 1, 1, 1, 0.75, 0.5, 0.25, 0)
ratiosR <- c(0, 0.25, 0.5, 0.75, 1, 1, 1, 1, 1)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   
axis(1, at=ticklocs, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocs, tck=0.01, lab=F, lwd=2)
mtext(text = ticklocs, side = 1, at=ticklocs)     # add the tick labels
mtext(text = ticklocs, side = 2, at=ticklocs, line=0.2, las=1)
title(xlab="Right eye contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
title(ylab="Left eye contrast (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

lines(c(0,24),c(24,24),lty=2)
lines(c(0,48),c(48,48),lty=2)
lines(c(24,24),c(0,24),lty=2)
lines(c(48,48),c(0,48),lty=2)
lines(c(0,96),c(96,0),lty=3)
lines(c(0,48),c(48,0),lty=3)

for (matchlev in 1:2){
lines(ratiosR*10^(meanthresh[matchlev,]/20),ratiosL*10^(meanthresh[matchlev,]/20),pch=16,col=colpal[matchlev],lwd=3)}

for (matchlev in 1:2){
for (cond in 1:9){
  points(ratiosR[cond]*10^(meanthresh[matchlev,cond]/20),ratiosL[cond]*10^(meanthresh[matchlev,cond]/20),pch=16,cex=2,col=colpal[matchlev])
  
  # if ((SEthresh[matchlev,cond]+meanthresh[matchlev,cond])<42){
  # arrows(ratiosR[cond]*10^(meanthresh[matchlev,cond]/20),ratiosL[cond]*10^(meanthresh[matchlev,cond]/20),ratiosR[cond]*10^((SEthresh[matchlev,cond]+meanthresh[matchlev,cond])/20),ratiosL[cond]*10^((SEthresh[matchlev,cond]+meanthresh[matchlev,cond])/20),length=0.015, angle=90, lwd=2)
  # }
  # 
  # # plot as an arrow if exceeding the axis limits
  # if ((SEthresh[matchlev,cond]+meanthresh[matchlev,cond])>42){
  # arrows(ratiosR[cond]*10^(meanthresh[matchlev,cond]/20),ratiosL[cond]*10^(meanthresh[matchlev,cond]/20),125,ratiosL[cond]*10^((SEthresh[matchlev,cond]+meanthresh[matchlev,cond])/20),length=0.035, angle=45, lwd=2)
  # }
  
  # arrows(ratiosR[cond]*10^(meanthresh[matchlev,cond]/20),ratiosL[cond]*10^(meanthresh[matchlev,cond]/20),ratiosR[cond]*10^((meanthresh[matchlev,cond]-SEthresh[matchlev,cond])/20),ratiosL[cond]*10^((meanthresh[matchlev,cond]-SEthresh[matchlev,cond])/20),length=0.015, angle=90, lwd=2)
}
}

text(10,117.5,'(d)',adj=0.5,cex=2.5)

legend(75,95,c('48% match','24% match'),pch=16,col=colpal[2:1],pt.cex=2,box.lwd=2)

legend(45.75,125,c('Winner-take-all','Linear summation'),lty=2:3,box.lwd=2)

dev.off()

  PostScriptTrace('CRF1p.ps')
  p1 <- readPicture('CRF1p.ps.xml')
  PostScriptTrace('CRF1e.ps')
  p2 <- readPicture('CRF1e.ps.xml')
  PostScriptTrace('CRF2e.ps')
  p3 <- readPicture('CRF2e.ps.xml')
  PostScriptTrace('matchingmodel.ps')
  p4 <- readPicture('matchingmodel.ps.xml')
  PostScriptTrace('posteriors.ps')
  p5 <- readPicture('posteriors.ps.xml')
  
  PostScriptTrace('pdata.ps')
  p6 <- readPicture('pdata.ps.xml')
  PostScriptTrace('edata.ps')
  p7 <- readPicture('edata.ps.xml')
  PostScriptTrace('edata2.ps')
  p8 <- readPicture('edata2.ps.xml')
  PostScriptTrace('matchingdata.ps')
  p9 <- readPicture('matchingdata.ps.xml')  
  
    for (n in 1:length(p5@paths)){
    temp <- class(p5@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(p5@paths[n]$path@rgb))<765){p5@paths[n]$path@rgb <- addalpha(p5@paths[n]$path@rgb,alpha=0.2)}}}

  
  pdf(paste0(figdir,"modelfigure.pdf"), bg="transparent", height = 10, width = 30)
  par(mar=c(0.1,0.1,0.1,0.1))
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(0,1), ylim=c(0,1))
  

  grid.picture(p1,x=1/12,y=0.25,width=1/6,height=1)
  grid.picture(p2,x=3/12,y=0.25,width=1/6,height=1)
  grid.picture(p3,x=5/12,y=0.25,width=1/6,height=1)
  grid.picture(p4,x=7/12,y=0.25,width=1/6,height=1)

  grid.picture(p5,x=5/6,y=0.5,width=1/3,height=1)

  grid.picture(p6,x=1/12,y=0.75,width=1/6,height=1)
  grid.picture(p7,x=3/12,y=0.75,width=1/6,height=1)
  grid.picture(p8,x=5/12,y=0.75,width=1/6,height=1)
  grid.picture(p9,x=7/12,y=0.75,width=1/6,height=1)
  
    
  dev.off()
  
  file.remove(c('CRF1e.ps','CRF2e.ps','CRF1p.ps','matchingmodel.ps','matchingdata.ps','pdata.ps','edata.ps','edata2.ps','posteriors.ps'))
  file.remove(c('CRF1e.ps.xml','CRF2e.ps.xml','CRF1p.ps.xml','matchingmodel.ps.xml','matchingdata.ps.xml','pdata.ps.xml','edata.ps.xml','edata2.ps.xml','posteriors.ps.xml'))

}

```

```{r modelfigure, fig.cap="Summary of computational modelling. Panels (a-d) show empirical data from key conditions, replotted from earlier figures for the pupillometry (a), first harmonic EEG responses (b), second harmonic EEG responses (c) and contrast matching (d) experiments. Panels (e-h) show model behaviour for the same conditions, generated using the median group-level parameter values.  Panel (i) shows the posterior probability distributions of the interocular suppression parameter for each of the four model fits. The pupillometry distribution (green) is centred about a substantially higher suppressive weight than for the other data types (note the logarithmic x-axis). The black curve shows the (scaled) prior distribution for the weight parameter.", fig.align="center", echo=FALSE}

knitr::include_graphics(paste0(figdir,'modelfigure.pdf'))

```

```{r paramtable, echo=FALSE}

exptnames <- c('Pupillometry','EEG 1F', 'EEG 2F', 'Matching')
zlist <- c(pupilZ,EEGZ,EEG2Z,matchingZ)
klist <- c(pupilK,EEGK,EEG2K,matchingK)
wlist <- c(pupilW,EEGW,EEG2W,matchingW)
Rlist <- c(round(c(pupilRmax,EEGRmax,EEG2Rmax),5),'-')
tabledata <- data.frame(exptnames,round(zlist,digits=2),round(klist,digits=2),round(wlist,digits=2),Rlist)

colnames(tabledata) <- c('Data set','Z','k','w','Rmax')
kable(tabledata, align='lcccc',caption = 'Summary of median parameter values.') 

```

# Discussion

Using a novel paradigm that combines EEG and pupillometry, we found surprising results for the binocular integration of flickering light. In the visual cortex response (indexed by EEG), the binocular combination of spatially-uniform temporal luminance modulations seems to happen approximately linearly, with no evidence of interocular suppression. Evidence for this comes from the substantial binocular facilitation effect when comparing monocular and binocular responses, and the lack of a dichoptic suppression effect when the two eyes were stimulated at different frequencies. In the subcortical pathway (indexed by pupillometry), binocular combination is more non-linear, with evidence of interocular suppression. This was evidenced by a weaker binocular facilitation, and stronger dichoptic suppression, relative to the EEG data. This pattern of results was confirmed by computational modelling, which showed a much greater suppressive weight for the pupillometry data compared to the EEG data. Additionally, we found that perception of flickering light is consistent with a near-linear binocular summation process, consistent with the cortical (EEG) responses.

The results of our main experiment were unexpected for both the pupillometry and the EEG measures. Previous studies investigating binocular combination of spatial patterns (i.e. sine wave grating stimuli) are generally consistent with strong interocular suppression and weak binocular facilitation at high contrasts [@Baker2017; @Moradi2009; @Meese2006] [however we note that facilitation as substantial as ours has been reported in previous EEG work by @Apkarian1981]. Our second experiment ruled out the possibility that these differences were due to the lower temporal frequency (2Hz) used here. However, there is evidence of more extensive binocular facilitation for a range of other stimuli. Using scleral search coils, @Quaia2018 observed a strong binocular facilitation (or 'supersummation') in the reflexive eye movement response to rapidly moving stimuli (also known as the ocular following response). @Spitschan2019 report a similar result in archival data on melatonin suppression due to light exposure (melatonin is a hormone released by the pineal gland that regulates sleep; its production is suppressed by light exposure and can be measured from saliva assays). Work on the accommodative response indicates that binocular combination there is approximately linear [@Flitcroft1992], and can even cancel when signals are in antiphase (we did not try this configuration here). In the auditory system, interaural suppression of amplitude modulation also appears to be weak when measured using a similar steady-state paradigm [@Baker2020]. Finally, psychophysical matching experiments using static stimuli also show near-linear behaviour for luminance increments [@Levelt1965; @Anstis1998; @Baker2012], though not for luminance decrements [@Anstis1998]. Overall, this suggests that strong interocular normalization may be specific to spatial pattern vision, and not a general feature of binocular signal combination (or combination across multiple inputs in other senses).

Given the above, where does this leave our understanding of the overarching purpose of signal combination? @Baker2017 point out that strong suppression between channels that are subsequently summed is equivalent to a Kalman filter, which is the optimal method for combining two noisy inputs [see also @Ernst2002]. Functionally, interocular suppression may therefore act to dynamically suppress noise, rendering binocular vision more stable. This account has intuitive appeal, and is consistent with other models that propose binocular combination as a means of redundancy reduction [@Li1994; @May2022]. One possibility is that optimal combination is useful for visual perception --- a critical system for interacting with the local environment --- and is therefore worth devoting the additional resource of inhibitory wiring between ocular channels. However the other examples of binocular combination discussed above are primarily physiological responses (pupil size, eye movements, hormone release) that may benefit more from an increased signal-to-noise ratio, or otherwise be phylogenetically older than binocular pattern vision. Conceptualised another way, the brain can repurpose a generic architecture for different situational demands by adjusting parameter values (here the weight of interocular suppression) to achieve different outcomes. Our future work in this area intends to compare binocular combination for specific photoreceptor pathways, including different cone classes, and intrinsically photoreceptive retinal ganglion cells. 

Pupil size affects the total amount of light falling on the retina. It is therefore the case that fluctuations in pupil diameter will have a downstream effect on the signals reaching cortex. We did not incorporate such interactions into our computational model, though in principle this might be worthwhile. However we anticipate than any such effects would be small, since pupil modulations at 2Hz are in the order of 2% of overall diameter [e.g. @Spitschan2014]. It is also the case that cortical activity can modulate pupil diameter, usually through arousal and attention mechanisms [e.g. @Bradley2008]. We think it unlikely that these temporally coarse processes would have a differential effect on e.g. monocular and binocular stimulation conditions in our experiment, and any fluctuations during an experimental session (perhaps owing to fatigue) will be equivalent for our comparisons of interest. Therefore we make the simplifying assumption that the pupil and perceptual pathways are effectively distinct, but hope to investigate this more directly in future neuroimaging work. Using fMRI to simultaneously image cortical and subcortical brain regions will also allow us to check that the differences we report here are not a consequence of the different measurement techniques we used (pupillometry and EEG).

Classic studies investigating the neurophysiological architecture of V1 reported that cells in cytochrome-oxidase 'blobs' [@Horton1981; @Livingstone1984] are biased towards low spatial frequencies [@Tootell1988; @Edwards1995], and relatively insensitive to stimulus orientation [@Horton1981; @Livingstone1984; though see @Economides2011]. As the blob regions are embedded within ocular dominance columns [@Horton1981], they are also largely monocular [@Livingstone1984; @Tychsen2004]. More recent work has reported psychophysical evidence for unoriented chromatic [@Gheiratmand2013] and achromatic [@Meese2011] mechanisms, that also appear to be monocular. Our use of luminance flicker might preferentially stimulate these mechanisms, perhaps explaining why our EEG data show little evidence of binocular interactions. Indeed, our EEG results could potentially be explained by a model involving entirely non-interacting monocular channels, with the binocular facilitation effects we find (e.g. Figures \@ref(fig:BSratios) \& \@ref(fig:TFdata)) owing to additivity of the electrophysiological response across independent monocular cells, rather than within binocular neurons. We therefore performed an additional analysis to investigate this possibility.

In the steady-state literature, one hallmark of a nonlinear system that pools inputs is the presence of intermodulation responses at the sums and differences of the fundamental flicker frequencies [@Baitch1988; @Tsai2012]. In Figure \@ref(fig:IMfig) we plot the amplitude spectra of conditions from Experiment 1 in which the two eyes were stimulated at different frequencies (2Hz and 1.6Hz) but at the same contrast (48\%; these correspond to the binocular cross and dichoptic cross conditions in Figures \@ref(fig:pupildata)d,e and \@ref(fig:EEGdata)d,e). Figure \@ref(fig:IMfig)a reveals a strong intermodulation difference response at 0.4Hz (red dashed line), and Figure \@ref(fig:IMfig)b reveals an intermodulation sum response at 3.6Hz (red dashed line). It seems likely that the absence of a sum response for pupillometry data, and of a difference responses for the EEG data, is a consequence of the temporal constraints of these methods. The presence of  intermodulation terms is predicted by nonlinear gain control models of the type considered here [@Tsai2012; @Baker2017], and indicates that the processing of monocular flicker signals is not fully linear prior to the point at which they are combined across the eyes. Indeed, our model architecture [@Meese2006] makes specific predictions about the location of interocular suppression - it impacts before binocular combination, consistent with results from primate physiology [@Dougherty2019].

``` {r createIMfig, include=FALSE, results='hide'}

# generate plot showing the bin:mon ratio for three data sets

if (processdata>0){
         if (!file.exists(paste0(datadir,'Averagedata.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '2qu6y'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name=='Averagedata.RData')
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
         }

load(file=paste0(datadir,'Averagedata.RData'))

frequencies <- (0:299)/10

pdf("Figures/IMresponse.pdf", onefile = FALSE, paper = "special", height = 8, width = 6)

par(mfcol = c(2,1))
par(mar=c(3,4,0.5,1))

plotlims <- c(0,6,0,0.06) 
ticklocsx <- seq(0,6,1)    # locations of tick marks on x axis
ticklocsy <- seq(0,0.05,0.01)    # locations of tick marks on y axis
ticklabelsx <-ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
title(xlab="Frequency (Hz)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude (mm)", col.lab=rgb(0,0,0), line=2, cex.lab=1.5)

lines(c(0.4,0.4),c(0,0.05),lty=2,lwd=2,col='red')
lines(c(2,2),c(0,0.05),lty=2,lwd=2,col='black')
lines(c(1.6,1.6),c(0,0.05),lty=2,lwd=2,col='darkgreen')

polygon(frequencies[c(2:61,61:2)],c(meanspectraPCI_IM[1,2:61],meanspectraPCI_IM[2,61:2]),col=addalpha(colpal[2],0.2),border=NA)

lines(frequencies[2:61],abs(meanspectraP_IM[2:61]), col=colpal[2], lwd=3, cex=0.5) 

text(5.6,0.05,'(a)',adj=0.5,cex=1.5)
text(0.4,0.053,'F1-F2',cex=1.2,adj=0.5,col='red')
text(2,0.053,'F1',cex=1.2,adj=0.5,col='black')
text(1.6,0.053,'F2',cex=1.2,adj=0.5,col='darkgreen')


par(mar=c(3,4,0.5,1))
plotlims <- c(0,6,0,0.35) 
ticklocsx <- seq(0,6,1)    # locations of tick marks on x axis
ticklocsy <- seq(0,0.3,0.1)    # locations of tick marks on y axis
ticklabelsx <-ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
title(xlab="Frequency (Hz)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude (ÂµV)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

lines(c(3.6,3.6),c(0,0.3),lty=2,lwd=2,col='red')
lines(c(2,2),c(0,0.3),lty=2,lwd=2,col='black')
lines(c(1.6,1.6),c(0,0.3),lty=2,lwd=2,col='darkgreen')

polygon(frequencies[c(3:61,61:3)],c(meanspectraECI_IM[1,3:61],meanspectraECI_IM[2,61:3]),col=addalpha(colpal[2],0.2),border=NA)

lines(frequencies[3:61],abs(meanspectraE_IM[3:61]), col=colpal[2], lwd=3, cex=0.5) 


text(5.6,0.3,'(b)',adj=0.5,cex=1.5)
text(3.6,0.32,'F1+F2',cex=1.2,adj=0.5,col='red')
text(2,0.32,'F1',cex=1.2,adj=0.5,col='black')
text(1.6,0.32,'F2',cex=1.2,adj=0.5,col='darkgreen')

dev.off()
}

```

```{r IMfig, fig.cap="Summary of intermodulation responses in pupillometry (a) and EEG (b) data. The data are pooled across the binocular cross and dichoptic cross conditions of Experiment 1, with a target contrast of 48\\%. Vertical dashed lines indicate the fundamental flicker frequencies of 2Hz (F1; black) and 1.6Hz (F2; green), and the intermodulation difference (F1-F2 = 0.4Hz) and sum (F1+F2 = 3.6Hz) frequencies (red). Data are averaged across N = 30 participants, and shaded regions indicate Â±1 standard error.", out.width = '50%', fig.align="center", echo=FALSE}

knitr::include_graphics(paste0(figdir,'IMresponse.pdf'))

```

# Conclusions

We have demonstrated that binocular combination of flickering light differs between cortical and subcortical pathways. Flicker was also associated with substantially weaker interocular suppression, and stronger binocular facilitation, compared to combination of spatial luminance modulations in visual cortex. Our computational framework for understanding signal combination permits direct comparisons between disparate experimental paradigms and data types. We anticipate that this will help elucidate the constraints the brain faces when combining different types of signals to govern perception, action and biological function.

# Acknowledgements

Supported by Biotechnology and Biological Sciences Research Council grant BB/V007580/1 awarded to DHB and ARW, and Wellcome Trust grant 213616/Z/18/Z to AB.

# Author contributions

**Federico Segala**: Methodology, software, formal analysis, investigation, data curation, writing - original draft, writing - review & editing, visualization. **Aurelio Bruno**: Conceptualization, writing - review & editing, supervision, project administration, funding acquisition. **Joel Martin**: Software, resources, writing - review & editing. **Myat Aung**: Software, resources, writing - review & editing. **Alex Wade**: Conceptualization, methodology, resources, writing - review & editing, supervision, project administration, funding acquisition. **Daniel Baker**: Conceptualization, methodology, software, formal analysis, investigation, resources, data curation, writing - original draft, writing - review & editing, visualization, supervision, project administration, funding acquisition.

# Declaration of interests

The authors declare no competing interests.

# References

<div id="refs"></div>

# Appendix 1

\beginsupplement

```{r repindividualanalysis, include=FALSE, results='hide'}

# (download and) analyse individual participant data for replication expt

if (processdata > 2){
  
legaltriggers <- 1:55

timeseq <- seq(1/120,10,length.out=120*10)
timeseq2 <- seq(1/120,14,length.out=120*14)
EEGtimes <- seq(1/1000,10,1/1000)
targetindex <- (2*10)+1
maskindex <- (1.6*10)+1
targetindex2 <- (2*2*10)+1
maskindex2 <- (2*1.6*10)+1

  for (participant in 1:12){
    
    # only download and process data if this has not been done already for this participant
    if (!file.exists(paste0(datadir,'P',200+participant,'summary.RData'))){   

      # if there is no directory for this participant's data
      if (!file.exists(paste0(rawdir,'P',200+participant))){
        dir.create(paste0(rawdir,'P',200+participant))
        
       d <- dir(paste0(rawdir,'P',200+participant))
       
       if (length(d)==0){
         
         # if the tar file of this participant's data doesn't exist
         if (!file.exists(paste0(rawdir,'P',200+participant,'.tar'))){
           # download it from OSF
           if (!exists('osffiles')){
           osfnode <- 'sjymf'
           osfproject <- osf_retrieve_node(osfnode)
          osffiles <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffiles$name==paste0('P',200+participant,'.tar'))
          osf_download(osffiles[fid,],rawdir,progress=TRUE)
         }
         
         # then unzip the tar file
         untar(paste0(rawdir,'P',200+participant,'.tar'),exdir=paste0(rawdir,'P',200+participant))
         
         # and delete the tar file to save storage space
         file.remove(paste0(rawdir,'P',200+participant,'.tar'))
       }
      }
      
      d <- dir(paste0(rawdir,'P',200+participant),full.names=TRUE)
       
pupiltargets <- array(0,dim=c(3,2,60))
pupiltargets2 <- array(0,dim=c(3,2,60))
pupilmasks <- pupiltargets
pupilmasks2 <- pupiltargets
pupilwaveforms <- array(0,dim=c(3,2,60,120*14))
pupilspectra <- array(0,dim=c(3,2,60,300))
EEGtargets <- array(0,dim=c(3,64,60))
EEGmasks <- EEGtargets
EEGtargets2 <- EEGtargets
EEGmasks2 <- EEGtargets
EEGwaveforms <- array(0,dim=c(3,64,60,1000*14))
EEGspectra <- array(0,dim=c(3,64,60,300))
repcounterP <- 0*(1:60)

psychopyfiles <- dir(path=paste0(rawdir,'P',200+participant),pattern='_block_', full.names = TRUE)
infofiles <- dir(path=paste0(rawdir,'P',200+participant),pattern='*_info.csv', full.names = TRUE)
EEGfiles <- dir(path=paste0(rawdir,'P',200+participant),pattern='*_EEG.csv.gz', full.names = TRUE)
pupilfiles <- dir(path=paste0(rawdir,'P',200+participant),pattern='*_pupil_positions.csv', full.names = TRUE)
annfiles <- dir(path=paste0(rawdir,'P',200+participant),pattern='*_annotations.csv', full.names = TRUE)

for (block in 1:length(EEGfiles)){
  
    infofile <- read.csv(infofiles[block])
  temp <- substr(as.character(infofile[7,2]),1,16)
  localstarttime <- as.numeric(temp)
  adata <- read.csv(annfiles[block])
  
    EEGdata <- read.csv(EEGfiles[block])
    electrodes <- colnames(EEGdata)
  
    triggertimes <- NULL
    trialtypes <- NULL
    counter <- 0
    lasttrigger <- -10000
    for (n in 1:nrow(EEGdata)){
      if(EEGdata$Trigger[n] %in% legaltriggers){
        if(n>(lasttrigger+10000)){
        counter <- counter + 1
        triggertimes[counter] <- n
        trialtypes[counter] <- EEGdata$Trigger[n]
        lasttrigger <- n
      }}
    }
  
    trialtypes[which(trialtypes>15)] <- trialtypes[which(trialtypes>15)] + 5
    inclist <- NULL
    for (t in 11:15){
      i <- which(trialtypes==t)
      inclist[t-10] <- i[2]
    }
    inclist <- inclist[which(!is.na(inclist))]
    trialtypes[inclist] <- trialtypes[inclist] + 5   
    
    for (cond in 1:60){
      for (ch in 1:64){
        trial <- EEGdata[(triggertimes[cond]+(2001:12000)),ch+2]
        fspec <- (fft(trial)/length(trial))
        EEGtargets[block,ch,trialtypes[cond]] <- fspec[targetindex]
        EEGmasks[block,ch,trialtypes[cond]] <- fspec[maskindex]
        EEGtargets2[block,ch,trialtypes[cond]] <- fspec[targetindex2]
        EEGmasks2[block,ch,trialtypes[cond]] <- fspec[maskindex2]
        EEGspectra[block,ch,trialtypes[cond],1:300] <- fspec[1:300]
        
        trial <- EEGdata[(triggertimes[cond]+(-999:13000)),ch+2]
        EEGwaveforms[block,ch,trialtypes[cond],] <- trial - mean(trial[1:1000])
      }}
    
 trialtypes <- adata$condition_code[seq(1,120,2)]   
 trialtimes <- (adata$timestamp[seq(1,120,2)] + adata$timestamp[seq(2,120,2)])/2
    
    trialtypes[which(trialtypes>15)] <- trialtypes[which(trialtypes>15)] + 5
    inclist <- NULL
    for (t in 11:15){
      i <- which(trialtypes==t)
      inclist[t-10] <- i[2]
    }
    inclist <- inclist[which(!is.na(inclist))]
    trialtypes[inclist] <- trialtypes[inclist] + 5
    
  pdata <- read.csv(pupilfiles[block])
  pdata2 <- pdata[,c(1,3,4,14)]
  pdata2 <- pdata2[which(pdata2[,3]>0.2),]
    
    for (trialno in 1:length(trialtypes)){
      repcounterP[trialtypes[trialno]] <- repcounterP[trialtypes[trialno]] + 1
      for (eye in 1:2){
        eyedata <- pdata2[which(pdata2[,2]==(2-eye)),]      
        a <- which(eyedata[,1]>trialtimes[trialno]+2)
        b <- which(eyedata[,1]<(trialtimes[trialno]+12))
        i <- intersect(a,b)
        trial <- eyedata[i,]
        trial <- trial[which(!is.na(trial[,4])),]
        trial[,1] <- trial[,1] - trial[1,1]
        if (nrow(trial)>3){
          resampled <- interp1(trial[,1],trial[,4],timeseq,method='linear',extrap=TRUE)
          fspec <- (fft(resampled)/length(resampled))
          pupilspectra[repcounterP[trialtypes[trialno]],eye,trialtypes[trialno],1:300] <- fspec[1:300]
          pupiltargets[repcounterP[trialtypes[trialno]],eye,trialtypes[trialno]] <- fspec[targetindex]
          pupilmasks[repcounterP[trialtypes[trialno]],eye,trialtypes[trialno]] <- fspec[maskindex]
          pupiltargets2[repcounterP[trialtypes[trialno]],eye,trialtypes[trialno]] <- fspec[targetindex2]
          pupilmasks2[repcounterP[trialtypes[trialno]],eye,trialtypes[trialno]] <- fspec[maskindex2]
        }
        
      a <- which(eyedata[,1]>(trialtimes[trialno]-1))
      b <- which(eyedata[,1]<(trialtimes[trialno]+13))
      i <- intersect(a,b)
      trial <- eyedata[i,]
      trial <- trial[which(!is.na(trial[,4])),]
      trial[,1] <- trial[,1] - trial[1,1]
      if (nrow(trial)>3){
        resampled <- interp1(trial[,1],trial[,4],timeseq2,method='linear',extrap=TRUE)
        pupilwaveforms[repcounterP[trialtypes[trialno]],eye,trialtypes[trialno],] <- resampled - mean(resampled[1:120])
      }        
          
      }
    }
    
}

cleanmeansP <- matrix(0,nrow=6,ncol=5)
cleanmasksP <- matrix(0,nrow=6,ncol=5)
cleanmeansE <- array(0,dim=c(64,6,5))
cleanmasksE <- array(0,dim=c(64,6,5))
cleanmeansE2 <- array(0,dim=c(64,6,5))
cleanmasksE2 <- array(0,dim=c(64,6,5))

for (cond in 1:6){
  startindex <- (10*(cond-1))
  for (level in 1:5){
    temp <- c(pupiltargets[,,startindex+level],pupiltargets[,,startindex+level+5])
    cleanmeansP[cond,level] <- cleanup2D(temp)

    temp <- c(pupilmasks[,,startindex+level],pupilmasks[,,startindex+level+5])
    cleanmasksP[cond,level] <- cleanup2D(temp)

    for (ch in 1:64){
    temp <- c(EEGtargets[,ch,startindex+level],EEGtargets[,ch,startindex+level+5])
    cleanmeansE[ch,cond,level] <- cleanup2D(temp)
    
    temp <- c(EEGmasks[,ch,startindex+level],EEGmasks[,ch,startindex+level+5])
    cleanmasksE[ch,cond,level] <- cleanup2D(temp)
    
    temp <- c(EEGtargets2[,ch,startindex+level],EEGtargets2[,ch,startindex+level+5])
    cleanmeansE2[ch,cond,level] <- cleanup2D(temp)
    
    temp <- c(EEGmasks2[,ch,startindex+level],EEGmasks2[,ch,startindex+level+5])
    cleanmasksE2[ch,cond,level] <- cleanup2D(temp) 
    }
}
}

electrodeindices <- match(targetelectrodes,electrodes)-2

meanwavesP <- apply(pupilwaveforms[,,c(15,20),],4,mean,na.rm=TRUE)
meanwavesE <- apply(EEGwaveforms[,electrodeindices,c(15,20),],4,mean,na.rm=TRUE)
meanspectraP <- apply(pupilspectra[,,c(15,20),],4,mean,na.rm=TRUE)
meanspectraE <- apply(EEGspectra[,electrodeindices,c(15,20),],4,mean,na.rm=TRUE)
save(file=paste(datadir,'P',200+participant,'summary.RData',sep=''),list=c('cleanmeansP','cleanmeansE','cleanmeansE2','cleanmasksP','cleanmasksE','cleanmasksE2','meanspectraP','meanspectraE','meanwavesP','meanwavesE','electrodes'))

 if (cleanupraw==1){file.remove(d)} # delete raw data files to save space

      }
        
        
      }
      
    
  }
  
```

```{r repgroupanalysis, include=FALSE, results='hide'}

# load in individual participant data and average, save group data

if (processdata > 1){

         if (!file.exists(paste0(datadir,'headerfile.csv'))){
           # download it from OSF
           if (!exists('osffiles')){
           osfnode <- 'x8u4v'
           osfproject <- osf_retrieve_node(osfnode)
          osffiles <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffiles$name=='headerfile.csv')
          osf_download(osffiles[fid,],datadir,progress=TRUE)
          } 
  
  hdata <- read.csv(paste0(datadir,'headerfile.csv'))  

for (participant in 1:12){
         # if the summary file of this participant's data doesn't exist
         if (!file.exists(paste0(datadir,'P',200+participant,'summary.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '2qu6y'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name==paste0('P',200+participant,'summary.RData'))
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
         }
}

 
d <- paste0('P',201:212,'summary.RData')

allmasksP <- array(0,dim=c(length(d),6,5))
allmeansP <- allmasksP
allmasksE <- array(0,dim=c(length(d),64,6,5))
allmeansE <- allmasksE
allmeansE2 <- allmeansE
allmasksE2 <- allmasksE
allspectraP <- array(0,dim=c(length(d),300))
allspectraE <- array(0,dim=c(length(d),300))
allwavesP <- array(0,dim=c(length(d),1680))
allwavesE <- array(0,dim=c(length(d),14000))

  for (s in 1:length(d)){
    
    load(paste0(datadir,d[s]))
    
  allmasksP[s,,] <- cleanmasksP
  allmeansP[s,,] <- cleanmeansP
  allspectraP[s,] <- meanspectraP
  allspectraE[s,] <- meanspectraE
  allwavesP[s,] <- meanwavesP
  allwavesE[s,] <- meanwavesE
  allmeansE[s,,,] <- cleanmeansE
  allmasksE[s,,,] <- cleanmasksE
  allmeansE2[s,,,] <- cleanmeansE2
  allmasksE2[s,,,] <- cleanmasksE2
    
  }

electrodeindices <- match(targetelectrodes,electrodes)-2

cleanmeansP <- matrix(0,nrow=6,ncol=5)
cleanmeansPCI <- array(0,c(2,6,5))
cleanmasksP <- matrix(0,nrow=6,ncol=5)
cleanmasksPCI <- array(0,c(2,6,5))
cleanmeansEav <- matrix(0,nrow=6,ncol=5)
cleanmeansEavCI <- array(0,c(2,6,5))
cleanmasksEav <- matrix(0,nrow=6,ncol=5)
cleanmasksEavCI <- array(0,c(2,6,5))
cleanmeansE2av <- matrix(0,nrow=6,ncol=5)
cleanmeansE2avCI <- array(0,c(2,6,5))
cleanmasksE2av <- matrix(0,nrow=6,ncol=5)
cleanmasksE2avCI <- array(0,c(2,6,5))
cleanmeansE <- array(0,dim=c(64,6,5))
cleanmeansECI <- array(0,c(2,64,6,5))
cleanmasksE <- array(0,dim=c(64,6,5))
cleanmasksECI <- array(0,c(2,64,6,5))
cleanmeansE2 <- array(0,dim=c(64,6,5))
cleanmeansE2CI <- array(0,c(2,64,6,5))
cleanmasksE2 <- array(0,dim=c(64,6,5))
cleanmasksE2CI <- array(0,c(2,64,6,5))


for (cond in 1:6){
  for (level in 1:5){
    
    temp <- allmeansP[,cond,level]
    mbs <- bootstrap2D(temp)
    cleanmeansP[cond,level] <- mbs$meanamp
    cleanmeansPCI[1,cond,level] <- mbs$lowerCI
    cleanmeansPCI[2,cond,level] <- mbs$upperCI
      
    temp <- allmasksP[,cond,level]
    mbs <- bootstrap2D(temp)
    cleanmasksP[cond,level] <- mbs$meanamp
    cleanmasksPCI[1,cond,level] <- mbs$lowerCI
    cleanmasksPCI[2,cond,level] <- mbs$upperCI

      temp <- apply(allmeansE[,electrodeindices,cond,level],1,mean)
      mbs <- bootstrap2D(temp)
    cleanmeansEav[cond,level] <- mbs$meanamp
    cleanmeansEavCI[1,cond,level] <- mbs$lowerCI
    cleanmeansEavCI[2,cond,level] <- mbs$upperCI
      
temp <- apply(allmasksE[,electrodeindices,cond,level],1,mean)
mbs <- bootstrap2D(temp)
    cleanmasksEav[cond,level] <- mbs$meanamp
    cleanmasksEavCI[1,cond,level] <- mbs$lowerCI
    cleanmasksEavCI[2,cond,level] <- mbs$upperCI

temp <- apply(allmeansE2[,electrodeindices,cond,level],1,mean)
mbs <- bootstrap2D(temp)
    cleanmeansE2av[cond,level] <- mbs$meanamp
    cleanmeansE2avCI[1,cond,level] <- mbs$lowerCI
    cleanmeansE2avCI[2,cond,level] <- mbs$upperCI

      temp <- apply(allmasksE2[,electrodeindices,cond,level],1,mean)
      mbs <- bootstrap2D(temp)
    cleanmasksE2av[cond,level] <- mbs$meanamp
    cleanmasksE2avCI[1,cond,level] <- mbs$lowerCI
    cleanmasksE2avCI[2,cond,level] <- mbs$upperCI

    for (ch in 1:64){
      
      temp <- allmeansE[,ch,cond,level]
      mbs <- bootstrap2D(temp)
    cleanmeansE[ch,cond,level] <- mbs$meanamp
    cleanmeansECI[1,ch,cond,level] <- mbs$lowerCI
    cleanmeansECI[2,ch,cond,level] <- mbs$upperCI

      temp <- allmasksE[,ch,cond,level]
      mbs <- bootstrap2D(temp)
    cleanmasksE[ch,cond,level] <- mbs$meanamp
    cleanmasksECI[1,ch,cond,level] <- mbs$lowerCI
    cleanmasksECI[2,ch,cond,level] <- mbs$upperCI

      temp <- allmeansE2[,ch,cond,level]
      mbs <- bootstrap2D(temp)
    cleanmeansE2[ch,cond,level] <- mbs$meanamp
    cleanmeansE2CI[1,ch,cond,level] <- mbs$lowerCI
    cleanmeansE2CI[2,ch,cond,level] <- mbs$upperCI
      
      temp <- allmasksE2[,ch,cond,level]
      mbs <- bootstrap2D(temp)
    cleanmasksE2[ch,cond,level] <- mbs$meanamp
    cleanmasksE2CI[1,ch,cond,level] <- mbs$lowerCI
    cleanmasksE2CI[2,ch,cond,level] <- mbs$upperCI
      
    }}}

meanspectraP <- (1:300)*0
meanspectraE <- (1:300)*0
meanspectraPCI <- array(0,c(2,300))
meanspectraECI <- array(0,c(2,300))

for (f in 2:300){
  
        temp <- allspectraP[,f]
        mbs <- bootstrap2D(temp)
meanspectraP[f] <- mbs$meanamp
meanspectraPCI[1,f] <- mbs$lowerCI
meanspectraPCI[2,f] <- mbs$upperCI
      
        temp <- allspectraE[,f]
        mbs <- bootstrap2D(temp)
meanspectraE[f] <- mbs$meanamp
meanspectraECI[1,f] <- mbs$lowerCI
meanspectraECI[2,f] <- mbs$upperCI

}

meanwavesP <- NULL
meanwavesE <- NULL
meanwavesPCI <- array(0,dim=c(2,dim(allwavesP)[2]))
meanwavesECI <- array(0,dim=c(2,dim(allwavesE)[2]))
nsubjs <- dim(allwavesP)[1]
for (t in 1:dim(allwavesP)[2]){
  temp <- allwavesP[,t]
  i <- which(abs(temp-mean(temp))<(SDthresh*sd(temp)))
  meanwavesP[t] <- mean(temp[i])
  bspop <- NULL
  for (s in 1:nbootstraps){bspop[s] <- mean(sample(temp[i],length(i),replace=TRUE))}
  meanwavesPCI[,t] <- quantile(bspop,c(0.16,0.84),na.rm=TRUE)
}

for (t in 1:dim(allwavesE)[2]){
    temp <- allwavesE[,t]
  i <- which(abs(temp-mean(temp))<(SDthresh*sd(temp)))
  meanwavesE[t] <- mean(temp[i])
  bspop <- NULL
  for (s in 1:nbootstraps){bspop[s] <- mean(sample(temp[i],length(i),replace=TRUE))}
  meanwavesECI[,t] <- quantile(bspop,c(0.16,0.84),na.rm=TRUE)
}

save(file=paste0(datadir,'Replicationdata.RData'),list=c('cleanmeansP','cleanmeansPCI','cleanmasksP','cleanmasksPCI','cleanmeansEav','cleanmeansEavCI','cleanmasksEav','cleanmasksEavCI','cleanmeansE2av','cleanmeansE2avCI','cleanmasksE2av','cleanmasksE2avCI','cleanmeansE','cleanmeansECI','cleanmasksECI','cleanmeansE2','cleanmeansE2CI','cleanmasksE2','cleanmasksE2CI','meanspectraP','meanspectraPCI','meanspectraE','meanspectraECI','meanwavesP','meanwavesE','meanwavesPCI','meanwavesECI','electrodes','allmeansP','allmeansE','allmeansE2'))

}

```

```{r createfigA1, include=FALSE, results='hide'}

# generate plot showing the group pupillometry data

         if (!file.exists(paste0(datadir,'Replicationdata.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '2qu6y'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name=='Replicationdata.RData')
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
         }

load(file=paste0(datadir,'Replicationdata.RData'))

if (processdata > 0){

contrastsdB <- 20*log10(c(6,12,24,48,96))

plotlims <- c(15,40,0,0.03) 
ticklocsx <- contrastsdB    # locations of tick marks on x axis
ticklocsy <- seq(0,0.03,0.01)    # locations of tick marks on y axis
ticklabelsx <-c(6,12,24,48,96)        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

postscript("CRF1p.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude at 2Hz (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansP[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  arrows(contrastsdB,abs(cleanmeansP[cond,]),contrastsdB,cleanmeansPCI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansP[cond,]),contrastsdB,cleanmeansPCI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  points(contrastsdB,abs(cleanmeansP[cond,]), pch = 20+cond, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves
}  
legend(22,0.03,c('Monocular','Binocular','Dichoptic'),pch=21:23,pt.bg=colpal[1:3],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.028,'(c)',adj=0.5,cex=2.5)

dev.off()

postscript("CRF2p.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)   
title(ylab="Amplitude at 2Hz (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

condlist <- c(1,5,6)
pointlist <- c(21,24,25)
for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansP[condlist[cond],]), col=colpal[condlist[cond]], lwd=3, cex=0.5)  
  arrows(contrastsdB,abs(cleanmeansP[condlist[cond],]),contrastsdB,cleanmeansPCI[1,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansP[condlist[cond],]),contrastsdB,cleanmeansPCI[2,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)  
  points(contrastsdB,abs(cleanmeansP[condlist[cond],]), pch = pointlist[cond], col='black', bg=colpal[condlist[cond]], cex=1.6, lwd=3)   
}  
legend(22,0.03,c('Monocular','Binocular cross','Dichoptic cross'),pch=pointlist,pt.bg=colpal[condlist],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.028,'(d)',adj=0.5,cex=2.5)

dev.off()


postscript("CRF3p.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

plotlims <- c(15,40,0,0.04) 
ticklocsy <- seq(0,0.04,0.01)    # locations of tick marks on y axis
ticklabelsy <- ticklocsy    # set labels for y ticks

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude at 1.6Hz (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

for (cond in 4:6){
  lines(contrastsdB,abs(cleanmasksP[cond,]), col=colpal[cond], lwd=3, cex=0.5)   
  arrows(contrastsdB,abs(cleanmasksP[cond,]),contrastsdB,cleanmasksPCI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmasksP[cond,]),contrastsdB,cleanmasksPCI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)    
  points(contrastsdB,abs(cleanmasksP[cond,]), pch = pointlist[cond-3], col='black', bg=colpal[cond], cex=1.6, lwd=3) 
}
legend(22,0.04,c('Monocular 1.6Hz','Binocular cross','Dichoptic cross'),pch=pointlist,pt.bg=colpal[4:6],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.038,'(e)',adj=0.5,cex=2.5)

dev.off()


postscript("SpecP.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 8)

frequencies <- (0:299)/10

plotlims <- c(1,6,0,0.03) 
ticklocsx <- seq(1,6,1)    # locations of tick marks on x axis
ticklocsy <- seq(0,0.03,0.01)    # locations of tick marks on y axis
ticklabelsx <-ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
title(xlab="Frequency (Hz)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

polygon(frequencies[c(11:61,61:11)],c(meanspectraPCI[1,11:61],meanspectraPCI[2,61:11]),col=colpal[2],border=NA)

lines(frequencies[11:61],abs(meanspectraP[11:61]), col=colpal[2], lwd=3, cex=0.5) 

text(1.1,0.028,'(b)',adj=0.5,cex=2.5)

dev.off()



postscript("timecourseP.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 8)

times <- seq((1/120)-1,13,1/120)
sinewave <- sin(2*times * 2*pi)
sinewave[1:120] <- 0
sinewave[1560:1680] <- 0

plotlims <- c(-1,13,-1,0.5) 
ticklocsx <- seq(-1,13,1)    # locations of tick marks on x axis
ticklocsy <- seq(-1,0.5,0.5)    # locations of tick marks on y axis
ticklabelsx <- ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
title(xlab="Time (s)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Relative amplitude (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)


filt <- butter(3,0.083)
filtwaveP <- signal::filter(filt, meanwavesP)
filtL <- signal::filter(filt,meanwavesPCI[1,])
filtU <- signal::filter(filt,meanwavesPCI[2,])
filtU[which(filtU>0.5)] <- 0.5  # crop upper error region at y-maximum
polygon(times[c(1:length(times),length(times):1)],c(filtL,filtU[length(filtU):1]),col=colpal[2],border=NA)

lines(times, filtwaveP, col=colpal[2], lwd=1.5) 

lines(times, (sinewave/10)-0.9, col='black', lwd=3) 

text(-0.7,0.4,'(a)',adj=0.5,cex=2.5)

dev.off()


  PostScriptTrace('CRF1p.ps')
  p1 <- readPicture('CRF1p.ps.xml')
  PostScriptTrace('CRF2p.ps')
  p2 <- readPicture('CRF2p.ps.xml')
  PostScriptTrace('CRF3p.ps')
  p3 <- readPicture('CRF3p.ps.xml')
  PostScriptTrace('SpecP.ps')
  p4 <- readPicture('SpecP.ps.xml')
  PostScriptTrace('timecourseP.ps')
  p5 <- readPicture('timecourseP.ps.xml')
  
    for (n in 1:length(p4@paths)){
    temp <- class(p4@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(p4@paths[n]$path@rgb))<765){p4@paths[n]$path@rgb <- addalpha(p4@paths[n]$path@rgb,alpha=0.2)}}}
  
      for (n in 1:length(p5@paths)){
    temp <- class(p5@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(p5@paths[n]$path@rgb))<765){p5@paths[n]$path@rgb <- addalpha(p5@paths[n]$path@rgb,alpha=0.2)}}}

  
  pdf(paste0(figdir,"pupildataRep.pdf"), bg="transparent", height = 10, width = 15)
  par(mar=c(0.1,0.1,0.1,0.1))
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(0,1), ylim=c(0,1))
  
  grid.picture(p1,x=0.17,y=0.25,width=0.32,height=1)
  grid.picture(p2,x=0.5,y=0.25,width=0.32,height=1)
  grid.picture(p3,x=0.83,y=0.25,width=0.32,height=1)
  grid.picture(p5,x=0.25,y=0.7,width=0.5,height=1)
  grid.picture(p4,x=0.75,y=0.7,width=0.5,height=1)
  
  text(0.5,0.98,'Pupillometry',cex=4)
  
  dev.off()
  
  file.remove(c('CRF1p.ps','CRF2p.ps','CRF3p.ps','SpecP.ps','timecourseP.ps'))
  file.remove(c('CRF1p.ps.xml','CRF2p.ps.xml','CRF3p.ps.xml','SpecP.ps.xml','timecourseP.ps.xml'))

}

```

```{r createfigA2, include=FALSE, results='hide'}

# generate plot showing the group EEG data

contrastsdB <- 20*log10(c(6,12,24,48,96))

         if (!file.exists(paste0(datadir,'headerfile.csv'))){
           # download it from OSF
           if (!exists('osffiles')){
           osfnode <- 'x8u4v'
           osfproject <- osf_retrieve_node(osfnode)
          osffiles <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffiles$name=='headerfile.csv')
          osf_download(osffiles[fid,],datadir,progress=TRUE)
          } 
hdata <- read.csv(paste0(datadir,'headerfile.csv'))  

         if (!file.exists(paste0(datadir,'Replicationdata.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '2qu6y'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name=='Replicationdata.RData')
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
         }

load(file=paste0(datadir,'Replicationdata.RData'))

electrodeindices <- match(targetelectrodes,electrodes)-2

if (processdata > 0){

plotlims <- c(15,40,0,0.5)  
ticklocsx <- contrastsdB    # locations of tick marks on x axis
ticklocsy <- seq(0,0.5,0.1)    # locations of tick marks on y axis
ticklabelsx <-c(6,12,24,48,96)        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

postscript("CRF1e.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude (ÂµV) at 2Hz", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansEav[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  arrows(contrastsdB,abs(cleanmeansEav[cond,]),contrastsdB,cleanmeansEavCI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansEav[cond,]),contrastsdB,cleanmeansEavCI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  points(contrastsdB,abs(cleanmeansEav[cond,]), pch = 20+cond, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves
}  
legend(22,0.5,c('Monocular','Binocular','Dichoptic'),pch=21:23,pt.bg=colpal[1:3],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.475,'(c)',adj=0.5,cex=2.5)

dev.off()

postscript("CRF2e.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)   
title(ylab="Amplitude (ÂµV) at 2Hz", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

condlist <- c(1,5,6)
pointlist <- c(21,24,25)
for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansEav[condlist[cond],]), col=colpal[condlist[cond]], lwd=3, cex=0.5)  
  arrows(contrastsdB,abs(cleanmeansEav[condlist[cond],]),contrastsdB,cleanmeansEavCI[1,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansEav[condlist[cond],]),contrastsdB,cleanmeansEavCI[2,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  points(contrastsdB,abs(cleanmeansEav[condlist[cond],]), pch = pointlist[cond], col='black', bg=colpal[condlist[cond]], cex=1.6, lwd=3)   
}  
legend(22,0.5,c('Monocular','Binocular cross','Dichoptic cross'),pch=pointlist,pt.bg=colpal[condlist],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.475,'(d)',adj=0.5,cex=2.5)

dev.off()


postscript("CRF3e.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude (ÂµV) at 1.6Hz", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

for (cond in 4:6){
  lines(contrastsdB,abs(cleanmasksEav[cond,]), col=colpal[cond], lwd=3, cex=0.5)   
  arrows(contrastsdB,abs(cleanmasksEav[cond,]),contrastsdB,cleanmasksEavCI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmasksEav[cond,]),contrastsdB,cleanmasksEavCI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  points(contrastsdB,abs(cleanmasksEav[cond,]), pch = pointlist[cond-3], col='black', bg=colpal[cond], cex=1.6, lwd=3) 
}
legend(22,0.5,c('Monocular 1.6Hz','Binocular cross','Dichoptic cross'),pch=pointlist,pt.bg=colpal[4:6],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.475,'(e)',adj=0.5,cex=2.5)

dev.off()


postscript("CRF1e2.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude (ÂµV) at 4Hz", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansE2av[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  arrows(contrastsdB,abs(cleanmeansE2av[cond,]),contrastsdB,cleanmeansE2avCI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)

  arrows(contrastsdB,abs(cleanmeansE2av[cond,]),contrastsdB,cleanmeansE2avCI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  
  points(contrastsdB,abs(cleanmeansE2av[cond,]), pch = 20+cond, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves
}  
legend(22,0.5,c('Monocular','Binocular','Dichoptic'),pch=21:23,pt.bg=colpal[1:3],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.475,'(f)',adj=0.5,cex=2.5)

dev.off()

postscript("CRF2e2.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)   
title(ylab="Amplitude (ÂµV) at 4Hz", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

condlist <- c(1,5,6)
pointlist <- c(21,24,25)
for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansE2av[condlist[cond],]), col=colpal[condlist[cond]], lwd=3, cex=0.5)  
  arrows(contrastsdB,abs(cleanmeansE2av[condlist[cond],]),contrastsdB,cleanmeansE2avCI[1,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansE2av[condlist[cond],]),contrastsdB,cleanmeansE2avCI[2,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  points(contrastsdB,abs(cleanmeansE2av[condlist[cond],]), pch = pointlist[cond], col='black', bg=colpal[condlist[cond]], cex=1.6, lwd=3)   
}  
legend(22,0.5,c('Monocular','Binocular cross','Dichoptic cross'),pch=pointlist,pt.bg=colpal[condlist],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.475,'(g)',adj=0.5,cex=2.5)

dev.off()


postscript("CRF3e2.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude (ÂµV) at 3.2Hz", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

for (cond in 4:6){
  lines(contrastsdB,abs(cleanmasksE2av[cond,]), col=colpal[cond], lwd=3, cex=0.5)   
  arrows(contrastsdB,abs(cleanmasksE2av[cond,]),contrastsdB,cleanmasksE2avCI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmasksE2av[cond,]),contrastsdB,cleanmasksE2avCI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  points(contrastsdB,abs(cleanmasksE2av[cond,]), pch = pointlist[cond-3], col='black', bg=colpal[cond], cex=1.6, lwd=3) 
}
legend(22,0.5,c('Monocular 1.6Hz','Binocular cross','Dichoptic cross'),pch=pointlist,pt.bg=colpal[4:6],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.475,'(h)',adj=0.5,cex=2.5)

dev.off()


postscript("SpecE.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 8)

frequencies <- (0:299)/10

plotlims <- c(1,6,0,1) 
ticklocsx <- seq(1,6,1)    # locations of tick marks on x axis
ticklocsy <- seq(0,1,0.2)    # locations of tick marks on y axis
ticklabelsx <-ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
title(xlab="Frequency (Hz)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude (ÂµV)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

polygon(frequencies[c(11:61,61:11)],c(meanspectraECI[1,11:61],meanspectraECI[2,61:11]),col=colpal[2],border=NA)

lines(frequencies[11:61],abs(meanspectraE[11:61]), col=colpal[2], lwd=3, cex=0.5) 

text(1.1,0.95,'(b)',adj=0.5,cex=2.5)

dev.off()



postscript("timecourseE.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 8)

times <- seq((1/1000)-1,13,1/1000)
sinewave <- sin(2*times * 2*pi)
sinewave[1:1000] <- 0
sinewave[13001:14000] <- 0

plotlims <- c(-1,13,-10,20) 
ticklocsx <- seq(-1,13,1)    # locations of tick marks on x axis
ticklocsy <- seq(-10,20,10)    # locations of tick marks on y axis
ticklabelsx <- ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
title(xlab="Time (s)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude (ÂµV)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

filt <- butter(3,0.083*0.12)
filtwaveE <- signal::filter(filt, meanwavesE)
filtU <- signal::filter(filt,meanwavesECI[1,])
filtL <- signal::filter(filt,meanwavesECI[2,])
polygon(times[c(1:length(times),length(times):1)],c(filtL,filtU[length(filtU):1]),col=colpal[2],border=NA)

lines(times, filtwaveE, col=colpal[2], lwd=1.5) 

lines(times, (sinewave*2.5)-7.5, col='black', lwd=3) 

text(-0.7,18,'(a)',adj=0.5,cex=2.5)

dev.off()


xpos <- 1:64
ypos <- 1:64
montageE <- toupper(as.character(hdata$Electrode))
for (ch in 1:64){
  i <- match(toupper(electrodes[ch+2]),montageE)
  xpos[ch] <- hdata$X_position[i]
  ypos[ch] <- hdata$Y_position[i]
}

ramp2 <- colorRamp(c("white",colpal[2]))  # create a ramp from one colour to another
colmatrix2 <- rgb(ramp2(seq(0, 1, length = 101)), max = 255)

## Create data frame to be used for interpolation - the function needs columns labelled x, y, and z
rmax <- 0.55   #specify a maximum boundary for the grid
gridRes <- 100 #specify the interpolation grid resolution

toplot <- abs(cleanmeansE[,2,5])
toplot[which(is.na(toplot))] <- 0
testDat<- data.frame(x = xpos, y = -ypos, z = toplot)

#Create the interpolation grid
xo <- seq(min(-rmax, testDat$x), max(rmax, testDat$x), length = gridRes)
yo <- seq(max(rmax, testDat$y), min(-rmax, testDat$y), length = gridRes)

interpV4 <- v4Interp(testDat, xo, yo, rmax, gridRes)

zo2 <- as.matrix(interpV4[,2:ncol(interpV4)])

xo2 <- matrix(rep(xo,length(yo)),nrow = length(xo),ncol = length(yo))
yo2 <- t(matrix(rep(yo,length(xo)),nrow = length(yo),ncol = length(xo)))
outsidecircle <- sqrt(xo2^2 + yo2^2) > 0.51
zo2[outsidecircle] <- 0

tiff("head1.tiff", height = 600, width = 600, units="px", bg="white")

plotlims <- c(-rmax,rmax,-rmax,rmax) 
par(pty="s")  # make axis square
plot(x=NULL,y=NULL,ann=FALSE, axes=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
image(xo,xo,zo2,col=colmatrix2,zlim=c(0,1),add=TRUE,useRaster=TRUE)
maskx <- c(hdata$OutlineX[1:51]*2.2,hdata$OutlineX[51:1])
masky <- c(hdata$OutlineY[1:51]*2.2,hdata$OutlineY[51:1])
polygon(maskx,masky,border=NA,col="white")
maskx <- c(hdata$OutlineX[51:101]*2.2,hdata$OutlineX[101:51])
masky <- c(hdata$OutlineY[51:101]*2.2,hdata$OutlineY[101:51])
polygon(maskx,masky,border=NA,col="white")

blackelectrodes <- match(toupper(targetelectrodes),toupper(as.character(electrodes[3:66])))
points(xpos[blackelectrodes],ypos[blackelectrodes],pch=16,col="black",cex=2)

lines(hdata$OutlineX,hdata$OutlineY,col="black",lwd=2)
lines(hdata$NoseX,hdata$NoseY,col="black",lwd=2)
lines(hdata$LearX,hdata$LearY,col="black",lwd=2)
lines(hdata$RearX,hdata$RearY,col="black",lwd=2)

dev.off()


toplot <- abs(cleanmeansE2[,2,5])
toplot[which(is.na(toplot))] <- 0
testDat<- data.frame(x = xpos, y = -ypos, z = toplot)

#Create the interpolation grid
xo <- seq(min(-rmax, testDat$x), max(rmax, testDat$x), length = gridRes)
yo <- seq(max(rmax, testDat$y), min(-rmax, testDat$y), length = gridRes)

interpV4 <- v4Interp(testDat, xo, yo, rmax, gridRes)

zo2 <- as.matrix(interpV4[,2:ncol(interpV4)])

xo2 <- matrix(rep(xo,length(yo)),nrow = length(xo),ncol = length(yo))
yo2 <- t(matrix(rep(yo,length(xo)),nrow = length(yo),ncol = length(xo)))
outsidecircle <- sqrt(xo2^2 + yo2^2) > 0.51
zo2[outsidecircle] <- 0
zo2[which(zo2>1)] <- 1

tiff("head2.tiff", height = 600, width = 600, units="px", bg="white")

plotlims <- c(-rmax,rmax,-rmax,rmax) 
par(pty="s")  # make axis square
plot(x=NULL,y=NULL,ann=FALSE, axes=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
image(xo,xo,zo2,col=colmatrix2,zlim=c(0,1),add=TRUE,useRaster=TRUE)
maskx <- c(hdata$OutlineX[1:51]*2.2,hdata$OutlineX[51:1])
masky <- c(hdata$OutlineY[1:51]*2.2,hdata$OutlineY[51:1])
polygon(maskx,masky,border=NA,col="white")
maskx <- c(hdata$OutlineX[51:101]*2.2,hdata$OutlineX[101:51])
masky <- c(hdata$OutlineY[51:101]*2.2,hdata$OutlineY[101:51])
polygon(maskx,masky,border=NA,col="white")

blackelectrodes <- match(toupper(targetelectrodes),toupper(as.character(electrodes[3:66])))
points(xpos[blackelectrodes],ypos[blackelectrodes],pch=16,col="black",cex=2)

lines(hdata$OutlineX,hdata$OutlineY,col="black",lwd=2)
lines(hdata$NoseX,hdata$NoseY,col="black",lwd=2)
lines(hdata$LearX,hdata$LearY,col="black",lwd=2)
lines(hdata$RearX,hdata$RearY,col="black",lwd=2)

dev.off()


  PostScriptTrace('CRF1e.ps')
  p1 <- readPicture('CRF1e.ps.xml')
  PostScriptTrace('CRF2e.ps')
  p2 <- readPicture('CRF2e.ps.xml')
  PostScriptTrace('CRF3e.ps')
  p3 <- readPicture('CRF3e.ps.xml')
  PostScriptTrace('SpecE.ps')
  p4 <- readPicture('SpecE.ps.xml')
  PostScriptTrace('timecourseE.ps')
  p5 <- readPicture('timecourseE.ps.xml')
  PostScriptTrace('CRF1e2.ps')
  p6 <- readPicture('CRF1e2.ps.xml')
  PostScriptTrace('CRF2e2.ps')
  p7 <- readPicture('CRF2e2.ps.xml')
  PostScriptTrace('CRF3e2.ps')
  p8 <- readPicture('CRF3e2.ps.xml')
  
    for (n in 1:length(p4@paths)){
    temp <- class(p4@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(p4@paths[n]$path@rgb))<765){p4@paths[n]$path@rgb <- addalpha(p4@paths[n]$path@rgb,alpha=0.2)}}}

      for (n in 1:length(p5@paths)){
    temp <- class(p5@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(p5@paths[n]$path@rgb))<765){p5@paths[n]$path@rgb <- addalpha(p5@paths[n]$path@rgb,alpha=0.2)}}}

    
  h1 <- readTIFF('head1.tiff')
  h2 <- readTIFF('head2.tiff')
  
  pdf(paste0(figdir,"EEGdataRep.pdf"), bg="transparent", height = 15, width = 15)
  par(mar=c(0.1,0.1,0.1,0.1))
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(0,1), ylim=c(0,1))
  
  # insert the head plots first so the white border doesn't overlap the other graphs
    aspratio <- 1  # this is the aspect ratio of the output pdf
  imwidth <- 0.16
  xstart <- 0.65
  ystart <- 0.82
  rasterImage(h1,xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth) 
  xstart <- 0.82
  ystart <- 0.82
  rasterImage(h2,xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth)

  grid.picture(p5,x=0.25,y=0.8,width=0.5,height=1)
  grid.picture(p4,x=0.75,y=0.8,width=0.5,height=1)
  grid.picture(p1,x=0.17,y=0.5,width=0.32,height=1)
  grid.picture(p2,x=0.5,y=0.5,width=0.32,height=1)
  grid.picture(p3,x=0.83,y=0.5,width=0.32,height=1)
  grid.picture(p6,x=0.17,y=0.175,width=0.32,height=1)
  grid.picture(p7,x=0.5,y=0.175,width=0.32,height=1)
  grid.picture(p8,x=0.83,y=0.175,width=0.32,height=1)
  
    text(0.5,1,'Electroencephalography',cex=4)

  dev.off()
  
  file.remove(c('CRF1e.ps','CRF2e.ps','CRF3e.ps','CRF1e2.ps','CRF2e2.ps','CRF3e2.ps','SpecE.ps','timecourseE.ps','head1.tiff','head2.tiff'))
  file.remove(c('CRF1e.ps.xml','CRF2e.ps.xml','CRF3e.ps.xml','CRF1e2.ps.xml','CRF2e2.ps.xml','CRF3e2.ps.xml','SpecE.ps.xml','timecourseE.ps.xml'))

}

```

We conducted a conceptual replication of Experiment 1 using an alternative system. A pair of Spectra Tune Lab multiprimary devices (LEDmotive Technologies LLC, Barcelona, Spain) were coupled to a binocular headset using liquid light guides. The light was imaged onto a circular diffuser for each eye (field size 30 deg) with the central 8 degrees masked off using a black occluder. Therefore the replication experiment involved peripheral stimulation, unlike the main experiment which stimulated the central ~4 degrees of the visual field. All conditions were otherwise as described for the main experiment, and we tested 12 participants in total.

The pupillometry results are shown in Figure \@ref(fig:appendixfig1) and correspond closely to those from the main experiment (Figure \@ref(fig:pupildata)). The ratio of binocular to monocular responses in Figure \@ref(fig:appendixfig1)c is similar, and suppression is evident in Figure \@ref(fig:appendixfig1)d,e. Of particular interest is the existence of a slight response at the second harmonic (4Hz, Figure \@ref(fig:appendixfig1)b), which was not present in our original data. This may be because the driving signal is stronger when stimulating the periphery (note the clear waveform in Figure \@ref(fig:appendixfig1)a), or more robust to eye movements, or it might indicate additional nonlinearities not present at the fovea.

```{r appendixfig1, fig.cap="Summary of pupillometry results for N = 12 participants, for peripheral stimulation. See Figure 2 for a description of each panel.", fig.align="center", echo=FALSE}

knitr::include_graphics(paste0(figdir,'pupildataRep.pdf'))

```

The EEG results are shown in Figure \@ref(fig:appendixfig2). These still show a strong binocular facilitation effect at the highest contrast levels (Figure \@ref(fig:appendixfig2)c,f), but the contrast response function is less clear at both the first and second harmonics. We suspect that this is because the cortical representation of the peripheral visual field is primarily along the calcarine sulcus, which results in some cancellation of the steady-state signal. This results in weaker signals than we obtained for foveal stimulation (represented at the occipital pole) in the main experiment (see Figure \@ref(fig:EEGdata)).

```{r appendixfig2, fig.cap="Summary of steady-state EEG results for N = 12 participants, for peripheral stimulation. See Figure 3 for a description of each panel.", fig.align="center", echo=FALSE}

knitr::include_graphics(paste0(figdir,'EEGdataRep.pdf'))

```
