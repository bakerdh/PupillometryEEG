---
title: "Different rules for binocular combination of luminance flicker in cortical and subcortical pathways"
author: "Federico G. Segala, Aurelio Bruno, Myat T. Aung, Alex R. Wade &  Daniel H. Baker"
date: "`r Sys.Date()`"
output:
  bookdown::pdf_document2:
    fig_caption: yes
    toc: no
    keep_tex: yes
  word_document: default
  pdf_document:
    toc: no
  html_document: default
bibliography: references.bib
csl: elife.csl
---

```{r setup, include=FALSE}

processdata <- 0  # this flag determines the amount of processing, with 4 levels:
# 0 - do no processing, generate the pdf using existing versions of all figures
# 1 - generate figures using the processed group data
# 2 - average data across participants, do bootstrapping and modelling
# 3 - download all raw data and analyse (requires 48GB of storage)

# check which packages are installed, install the missing ones, and activate
packagelist <- c('knitr','remotes','tictoc','R.matlab','bookdown','grImport','png','tiff','pals','ez','gtools','signal','boot','quickpsy','rstan','coda','parallel','osfr') # list of CRAN packages
missingpackages <- packagelist[!packagelist %in% installed.packages()[,1]]
if (length(missingpackages)>0){install.packages(missingpackages)}
if (!'FourierStats' %in% installed.packages()[,1]){remotes::install_github("bakerdh/FourierStats")}
packagelist <- c(packagelist,'FourierStats')
toinstall <- packagelist[which(!packagelist %in% (.packages()))]
invisible(lapply(toinstall,library,character.only=TRUE))

knitr::opts_chunk$set(echo = TRUE)

# helper function to make colours transparent
addalpha <- function(col, alpha=1){apply(sapply(col, col2rgb)/255, 2, function(x) rgb(x[1], x[2], x[3], alpha=alpha))}

v4Interp <- function(df, xo, yo, rmax = .75, gridRes = 67) {
  ## Create a function to perform Matlab's v4 interpolation.
  ## Takes as input a data-frame with columns x, y, and z (x co-ordinates, y co-ordinates, and amplitude)
  ## and variables xo and yo, the co-ordinates which will be use to create a grid for interpolation
  xo <- matrix(rep(xo,length(yo)),nrow = length(xo),ncol = length(yo))
  yo <- t(matrix(rep(yo,length(xo)),nrow = length(yo),ncol = length(xo)))
  xy <- df$x + df$y*sqrt(as.complex(-1))
  d <- matrix(rep(xy,length(xy)),nrow = length(xy), ncol = length(xy))
  d <- abs(d - t(d))
  diag(d) <- 1
  g <- (d^2) * (log(d)-1)   # Green's function.
  diag(g) <- 0
  weights <- qr.solve(g,df$z)
  xy <- t(xy)
  outmat <- matrix(nrow = gridRes,ncol = gridRes)
  for (i in 1:gridRes){
    for (j in 1:gridRes) {
      test4 <- abs((xo[i,j] + sqrt(as.complex(-1))*yo[i,j]) - xy)
      g <- (test4^2) * (log(test4)-1)
      outmat[i,j] <- g %*% weights}}
  outDf <- data.frame(x = xo[,1],outmat)
  names(outDf)[1:length(yo[1,])+1] <- yo[1,]
  return(outDf)}

anovacirc2way <- function(data, groupA=NULL, groupB=NULL, participant=NULL){
  
  grouplabelsA <- groupA
  grouplabelsB <- groupB
  participantlabels <- participant
  datavals <- data

  grouplabelsA <- as.factor(grouplabelsA)
  factorlistA <- levels(grouplabelsA)
  grouplabelsB <- as.factor(grouplabelsB)
  factorlistB <- levels(grouplabelsB)
  participantlabels <- as.factor(participantlabels)
  participantlist <- levels(participantlabels)
  
  grandmean <- mean(datavals)
  grandvar <- sum(abs(datavals - grandmean)^2)/(length(datavals)-1)
  
    SST <- grandvar*(length(datavals) - 1)
    
    SSW <- 0
    for (n in 1:nlevels(participantlabels)){SSW <- SSW + sum(abs(datavals[which(participantlabels==participantlist[n])] - mean(datavals[which(participantlabels==participantlist[n])]))^2)}
    dfW <- 2*(nlevels(participantlabels)*(nlevels(grouplabelsA)*nlevels(grouplabelsB)-1))
    
    SSBet <- SST - SSW  # between subjects SS - not actually used
    SSM <- 0
    for (a in 1:nlevels(grouplabelsA)){
      for (b in 1:nlevels(grouplabelsB)){
        i <- as.numeric(((grouplabelsA==grouplabelsA[a])))
        j <- as.numeric(((grouplabelsB==grouplabelsB[b])))
        indices <- which((i*j)>0)
        SSM <- SSM + (nlevels(participantlabels)*sum(abs(datavals[indices] - grandmean)^2))
      }
    }
    dfM <- 2*((nlevels(grouplabelsA)*nlevels(grouplabelsB))-1)
    
    SSR <- 0
    for (a in 1:nlevels(grouplabelsA)){
      for (b in 1:nlevels(grouplabelsB)){
        i <- as.numeric(((grouplabelsA==grouplabelsA[a])))
        j <- as.numeric(((grouplabelsB==grouplabelsB[b])))
        indices <- which((i*j)>0)
        condvar <- sum(abs(datavals[indices] - mean(datavals[indices]))^2)/(length(indices)-1)
        SSR <- SSR + (nlevels(participantlabels)-1)*condvar
      }
    }    
    dfR <- 2*(nlevels(participantlabels)-1)*(nlevels(grouplabelsA)*nlevels(grouplabelsB))
    
    groupmeansA <- NULL
    for (n in 1:nlevels(grouplabelsA)){groupmeansA[n] <- mean(datavals[which(grouplabelsA==factorlistA[n])])}
    SSA <- 0
    for (n in 1:nlevels(grouplabelsA)){SSA <- SSA + length(which(grouplabelsA==factorlistA[n]))*abs(groupmeansA[n]-grandmean)^2}
    dfA <- 2*(nlevels(grouplabelsA)-1)
    
    groupmeansB <- NULL
    for (n in 1:nlevels(grouplabelsB)){groupmeansB[n] <- mean(datavals[which(grouplabelsB==factorlistB[n])])}
    SSB <- 0
    for (n in 1:nlevels(grouplabelsB)){SSB <- SSB + length(which(grouplabelsB==factorlistB[n]))*abs(groupmeansB[n]-grandmean)^2}
    dfB <- 2*(nlevels(grouplabelsB)-1)
    
    SSAB <- SSW - (SSA + SSB)
    dfAB <- 2 * (nlevels(grouplabelsA)-1) * (nlevels(grouplabelsB)-1)
    
    MSA <- SSA/dfA
    MSB <- SSB/dfB
    MSAB <- SSAB/dfAB
    MSR <- SSR/dfR
    
    FratioA <- MSA/MSR
    pvalA <- pf(FratioA,df1=dfA,df2=dfR,lower.tail=FALSE)
    FratioB <- MSB/MSR
    pvalB <- pf(FratioB,df1=dfB,df2=dfR,lower.tail=FALSE)
    FratioAB <- MSAB/MSR
    pvalAB <- pf(FratioAB,df1=dfAB,df2=dfR,lower.tail=FALSE)
    
    method <- 'Factorial repeated measures ANOVA^2-circ'
    output <- data.frame(FratioA,pvalA,FratioB,pvalB,FratioAB,pvalAB,dfA,dfB,dfAB,dfR,method)
  
  return(output)
}


colpal <- c('#FE5000','#8783CF','#228B22','#808080','#6d008b','#8B8000')
targetelectrodes <- c('Oz','POz','O1','O2')

localdir <- 'local/'    # all files are stored in the project directory /local/ which git is told to ignore
if (!file.exists(localdir)){dir.create(localdir)}   # create a local directory to store data and outputs
rawdir <- 'local/rawdata/'
if (!file.exists(rawdir)){dir.create(rawdir)}   # create a local directory to store raw data
figdir <- 'Figures/'
if (!file.exists(figdir)){dir.create(figdir)}   # create a local directory to store figures
datadir <- 'local/processeddata/'
if (!file.exists(datadir)){dir.create(datadir)}   # create a local directory to store processed data

# cut off for data inclusion (Mahalanobis distance for complex data)
SDthresh <- 3
nbootstraps <- 1000

```

# Abstract

We investigated the rules of binocular combination of temporal flickering stimuli. Using EEG and pupillometry simultaneously, we investigated the combination of light discs at five temporal contrast levels flickering at 2 Hz in the cortical and subcortical pathways. Results showed a strong binocular facilitation in the visual cortex and a non-linear combination process with evidence of suppression in the subcortical pathways. Following these findings, we performed a matching experiment using the same type of stimuli and found equivalent linear summation effects. Using a Bayesian approach, all our data were fitted to a computational model that showed a stronger interocular suppression for the pupillometry data compared with the EEG and matching data.

---
OK, some pointers for the introduction: I think we need to draw a distinction between binocular summation at threshold (on which there is a big literature) and binocular facilitation above threshold. Much of the introduction is focussed on threshold measures, but actually I think our focus here is more about suprathreshold conditions where we usually see little facilitation. I think it will help the reader if we use the term summation only to refer to threshold phenomena, and facilitation in the more general case (I’ve tried to do this elsewhere in the paper).
The key points should be:
1. For grating stimuli, there are summation effects at threshold, but these are lost at high contrasts.
2. Binocular combination happens in multiple pathways, including the pupil pathway. (This is a good place to mention the Quaia paper).
3. We don’t know much about the pupil response, though it is clearly binocular because of the consensual response (convergence and divergence seem to be other ways of saying the same thing, so not sure they are worth mentioning).
4. Actually there’s not much work on temporal binocular combination even in the primary visual
pathway.
5. We have developed a novel paradigm that allows us to probe both cortical and subcortical pathways simultaneously for flickering light.
I wouldn’t say too much about models, or about the matching experiment, at this stage.

# Introduction

Binocular combination provides a higher visual sensitivity than monocular viewing. At threshold, this superiority is known as binocular summation, while, above threshold, we refer to this as binocular facilitation. Binocular summation is defined by the binocular summation ratio (BSR). This was originally believed to be around $\sqrt{2}$ ($\approx1.4$) for grating stimuli at detection threshold [@Campbell1965]. In other words, a monocular grating can elicit the same response as a binocular grating if it has a contrast that is 1.4 times higher. This led Legge to develop a widely accepted explanation that used quadratic summation to describe binocular combination for grating stimuli [@Legge1984]: monocular signals from the right (R) and the left (L) eyes are squared before being summed together and the binocular response (B) is given by the square root of the output (B = $\sqrt{R^2 + L^2}$, when R and L are equal to 1, the output is $\sqrt{2}$). However, subsequent research has shown that these explanations are not fully adequate to account for binocular facilitation above threshold, as this summation effects are lost for gratings at high contrast. Both of these accounts constitute single channel models, and this type of model has been shown to not being able to account for contrast detection in the presence of noise [@Anderson1989]. Moreover, more recent research has shown that the summation ratio can vary greatly between $\sqrt{2}$ and 2 depending on factors such as the spatial and temporal frequency of a stimulus or the sensitivity difference between the eyes [@Baker2018]. These observations led to the development of multistage gain control models, which combine binocular summation and interocular suppression, and can account for contrast matching, detection and discrimination for spatial contrast [@Ding2006; @Meese2006].

In general, it seems that the mechanisms behind spatial binocular combination have been thoroughly studied, as have been the anatomical pathways behind it: light enters the eye though the pupil and signals are sent from the left and right retinae to the primary visual cortex, remaining anatomically isolated while passing through the lateral geniculate nucleus (LGN) until they reach V1, where they are binocularly combined [@Purves2008]. However, there is an eye component that is often underestimated in its role to determine the quality of visual information: the pupil. The pupils are openings found in the centre of the eyes that appear to be black and allow light to enter the eyes. Their size determines how much light will reach the retina and it is usually determined by the ambient levels of light: in brightness the pupils will constrict and in darkness they will dilate. This is known as the pupillary light response (PLR). The anatomical pathways that regulate this response are well understood and are very clearly and extensively described in the literature [@Angee2021; @Mathot2018; @McDougal2010; @Wang2015]. However, they are anatomically distinct from the LGN-V1 pathway meaning that binocular combination occurs separately in anatomically distinct pathways. Given this, not much is known about the computational processes behind the PLR although there is some evidence of binocular interaction and binocular combination happening at the level of the pupil pathways. Evidence of binocular interaction is provided by the presence of a consensual response in the pupils: when only one pupil is stimulated, an equivalent response will be recorded in the unstimulated pupil [@Wyatt1981]. Evidence of binocular combination is provided by the binocular facilitation observed for the ocular following eye movements in response to fast moving stimuli: when comparing the amplitude of the responses to monocular and binocular stimuli, the binocular response will be more than twice the monocular response [@Quaia2018].

With this in mind, we designed an experiment that simultaneously recorded electrophysiological and pupillometric responses using changes in the temporal contrast of a flickering light. This is a novel paradigm that we developed that allowed us to probe both cortical (using EEG) and subcortical (using a binocular eyetracker) pathways simultaneously for flickering light. The results should offer new insight about basic neural circuits and information on how they might be affected in clinical disorders of vision (e.g. amblyopia). Based on previous literature, we expected to find a non-linear combination of the responses in the visual cortex, as described by the gain control mechanisms used to describe spatial contrast combination, and a more linear combination of the responses and a greater binocular response at the level of the pupils. Additionally, we decided to follow up on our results from this first experiments to test whether perception of flickering light is consistent with the results that we observed in the cortical pathways (visual cortex). We therefore conducted a contrast matching experiment using the same type of flickering stimuli used in our first experiment.

# Methods

## Participants

Thirty, twelve and ten participants were recruited for Experiments 1, 2 and 3 respectively. All participants had normal or corrected to normal binocular vision, and gave written informed consent.

## Apparatus & stimuli

The stimuli were two discs of flickering light with a diameter of 3.74 degrees, presented on a black background. The same stimuli were used for all three experiments. Four dark red lines were added around both discs to help with their fusion into one binocular disc (see insert in Figure \@ref(fig:pupildata)b for an example of the fused stimulus). The discs were viewed through a four-mirror stereoscope, which used front silvered mirrors to avoid internal reflections, and meant that participants saw a single fused disc. The use of a stereoscope allowed us to modulate the stimuli in three different ocular configurations: monocular, binocular, and dichoptic. Note that during monocular presentation of flicker, the unstimulated eye still saw the static (non-flickering) disc of mean luminance.

All stimuli were displayed at a mean luminance of 42 cd/m$^2$ on an Iiyama Vision Master™ Pro 510 display (800 x 600 pixels, 60 Hz refresh rate), which was gamma corrected using a Minolta LS-110 (Minolta Camera Co. Ltd., Japan). For experiments 1 and 2, the stimuli were presented using Psychopy (v3.0.7). For experiment 3, the stimuli were presented using Psychopy (v2022.1.1).

EEG data were collected for Experiments 1 and 2 using a 64-electrode ANT WaveGuard cap and the signals were recorded at 1 kHz using the ASA software (ANT Neuro, Netherlands). Pupillometry data were collected for Experiment 1 using a binocular Pupil Core eye-tracker (Pupil Labs GmbH, Berlin, Germany; @Kassner2014) running at 120 Hz, and the signals were recorded with the Pupil Capture software.

## Procedure

Before each experiment, participants calibrated the stereoscope by adjusting the angle of the mirrors. This was done so that they would perceive the two discs as one fused disc when looking at the screen through the stereoscope.

### Experiment 1: simultaneous EEG and pupillometry

The experiment was conducted in a windowless room, in which the only light source was the monitor. The participants sat at 99 cm from the monitor and the total optical viewing distance (through the stereoscope) was 107 cm. The experiment was carried out in one session lasting 45 minutes in total, divided in three blocks of 15 minutes each. In each block, there were 60 trials in total lasting 15 seconds each (12s of stimulus presentation, with an interstimulus interval of 3s). The participants were given no specific task instructions, but were asked to look at the fixation crosses in the middle of the two discs while trying to minimise their blinking during the presentation period. 
We included six distinct ocular conditions, each at five temporal target contrast levels (combined factorially) relative to the mean luminance: 6, 12, 24, 48 and 96\%. In the first three conditions, the discs flickered at 2 Hz, in either a monocular, binocular, or dichoptic arrangement. In the dichoptic condition the non-target eye saw a fixed luminance contrast of 48\%. In the remaining three conditions (termed the cross-frequency conditions) one eye's disc flickered at 1.6Hz, and the other eye's disc flickered at 2Hz. We also tested monocular (one eye sees 1.6Hz flicker, the other sees mean luminance), binocular (one eye sees each frequency at the target contrast) and dichoptic (target stimulus flickering at 2Hz, mask contrast of 48\% at 1.6Hz in the other eye) arrangements. The rationale for flickering both eyes at 2Hz is that we can then measure summation behaviour between the eyes in the pupil and EEG response at 2Hz. The rationale for flickering the eyes at different frequencies is that this permits measurement of suppression between the eyes (i.e. the reduction in the 2Hz response when a 1.6Hz mask component is added to the other eye). We counterbalanced presentation of the target stimulus across the left and right eyes.

### Experiment 2: EEG responses across temporal frequency

This experiment used the same equipment set up as Experiment 1, except that the eye tracker was not used. Unlike the first experiment, only one contrast level was used (96\%) and the discs were set to flicker at five different frequencies (2, 4, 8, 16 and 30 Hz). Only two ocular configurations, monocular and binocular, were used, with the latter having both discs flickering at the same frequency. The experiment was carried out in one session lasting 25 minutes in total, divided into five blocks of 5 minutes each. In each block, there were 20 trials in total with the same timing as for Experiment 1.

### Experiment 3: temporal contrast matching

The experiment was conducted in a darkened room with a blacked-out window. The display equipment (monitor and stereoscope) were the same as for the two previous experiments, but no EEG or pupillometry data were collected. A two-interval contrast matching procedure was used to collect data. In one interval, participants were presented with a standard fused disc that flickered at a set contrast level (either 24 or 48\%), which was selected by the experimenter at the beginning of each block. In the other interval, a target disc flickering at varying contrast levels was displayed. The contrast level of the target was controlled by a 1-up, 1-down staircase moving in logarithmic (dB) steps of contrast. The ratio of flicker amplitudes in the left and right eyes was varied across blocks and was set to be 0, 0.25, 0.5, 0.75 or 1 (9 distinct conditions). The standard and target discs were displayed for 1 second each, with an interstimulus interval of 0.5 seconds. After the discs appeared on screen, the participants had to indicate which interval they perceived as having the more intense flicker. The intervals were randomly ordered, and all discs flickered at a frequency of 2 Hz (two cycles in sine phase).

Due to its long duration (approximately 3 hours in total), the participants completed the experiment across multiple sessions initiated at their own convenience The experiment was divided into 54 blocks (3 repetitions $\times$ 2 standard contrasts $\times$ 9 target ratios), which lasted on average 3 minutes each, depending on the response speed of the participant. In each block, there were a total of 50 trials. No auditory feedback was given for this subjective task.

## Data analysis

EEG data were converted from the ANT-EEProbe format to a compressed csv text file using a custom Matlab script and components of the EEGlab toolbox [@Delorme2004]. The data for each participant were then loaded into R for analysis where a ten-second waveform for each trial at each electrode was extracted (omitting the first two seconds). The fast Fourier transform was calculated for each waveform, and the spectrum stored in a matrix. All repetitions of each condition were then averaged for each electrode. They were then averaged across four occipital electrodes (\emph{POz}, \emph{Oz}, \emph{O1}, \emph{O2}), to obtain individual results. Finally, these were averaged across participants to obtain the group results. All averaging retained the phase information (i.e. coherent averaging), and at each stage we excluded data points with a Mahalanobis distance exceeding $D$ = `r SDthresh` from the complex-valued mean [see @Baker2021]. For statistical comparisons of complex-valued data, we use the $ANOVA^2_{circ}$ statistic described by @Baker2021. This is a multivariate extension of ANOVA that assumes equal variance of the real and imaginary Fourier components, or equivalently, an extension of the $T^2_{circ}$ statistic of @Victor1991 that can compare more than two conditions.

A similar analysis pipeline was adopted for the pupillometry data. The data were converted from mp4 videos to a csv text file using the Pupil Player software [@Kassner2014], which estimated pupil diameter for each eye on each frame using a 3D model of the eyeball. The individual data were then loaded into R for analysis, where again a ten-second waveform for each trial in each eye was extracted (excluding the first two seconds after stimulus onset). We interpolated across any dropped or missing frames to ensure regular and continuous sampling over time. The fast Fourier transform was calculated for each waveform, and all repetitions of each condition were pooled across eye and then averaged. Finally, data were averaged across all participants to obtain the group results. Again, we used coherent averaging, and excluded outlying data points in the same way as for the EEG data. Note that previous pupillometry studies using luminance flicker have tended to fit sine-waves to the data, rather than using Fourier analysis [e.g. @Spitschan2014]. The Fourier approach is more robust to noise at other frequencies and has already been used in some previous studies [see @Barrionuevo2014; @Barrionuevo2016]. Additionally, it makes the pupillometry analysis consistent with standard practice in steady-state EEG analysis [e.g. @Figueira2022]

To analyse the matching data, we pooled the trial responses across all repetitions of a given condition for each participant. We then fitted a cumulative normal psychometric function to estimate the point of subjective equality at the 50\% level. Thresholds were averaged across participants in logarithmic (dB) units. 

For all experiments, we used a bootstrapping procedure with `r nbootstraps` iterations to estimate standard errors across participants. All analysis and figure construction was conducted using a single R-script, available online, making this study fully computationally reproducible.

## Computational model and parameter estimation

To describe our data, we chose a model of binocular contrast gain control with the same general form as the first stage of the model proposed by @Meese2006. The second gain control stage was omitted [consistent with @Baker2017] to simplify the model and reduce the number of free parameters. The response of the left eye's channel is given by:

\begin{equation}
\label{eq:respL}
Resp_L = \frac{L^2}{Z + L + wR},
\end{equation}

with an equivalent expression for the right eye:

\begin{equation}
\label{eq:respR}
Resp_R = \frac{R^2}{Z + R + wL}.
\end{equation}

In both equations, _L_ and _R_ are the contrast signals from the left and right eyes, _Z_ is a saturation constant that shifts the contrast-response function laterally, and _w_ is the weight of suppression from the other eye.

The responses from the two eyes are then summed binocularly:

\begin{equation}
\label{eq:respB}
Resp_B = R_{max}(Resp_L + Resp_R) + n,
\end{equation}

where _n_ is a noise parameter, and $R_{max}$ scales the overall response amplitude. The $R_{max}$ parameter was omitted when modelling the contrast matching data, as it had no effect in this paradigm.

Despite being derived from the model proposed by @Meese2006, the simplifications applied to this architecture make it very similar to other models [e.g. @Ding2006; @Legge1984; @Schrodinger1926]. In particular we fixed the numerator exponent at 2 in our model, because otherwise this value tends to trade off with the weight of interocular suppression [see @Baker2012; @Kingdom2015]. Our key parameter of interest is the weight of interocular suppression. Large values around $w$ = 1 result in a very small or nonexistent binocular advantage at suprathreshold contrasts, consistent with previous work using grating stimuli [@Baker2017]. Low values around $w$ = 0 produce substantial, near-linear binocular facilitation [@Baker2020].

We implemented the model within a Bayesian framework using the Stan software [@Carpenter2017]. This allowed us to estimate group-level posterior parameter distributions for the weight of interocular suppression, $w$, and the other free model parameters $R_{max}$, $Z$ and $n$. The prior distributions for all parameters were Gaussian, with means and standard deviations of 1 and 0.5 for $w$ and $R_{max}$, and 5 and 2 for $Z$ and $n$. We sampled from a Student's t-distribution for the amplitudes in the pupillometry and EEG experiments, and from a Bernoulli distribution for the single trial matching data. The models were fit using the individual data across all participants, independently for each data set. Because we used coherent averaging across participants, the group average amplitudes are shifted vertically relative to the model predictions, which are based on hierarchical fits to the individual participant amplitudes (put another way, the model does not implement coherent averaging). However it is clear that the character of the model in all cases gives a good representation of the data. We sampled over a million steps for each data set, using a computer cluster, and retained 10\% of samples for plotting.

## Preregistration, data and code availability

We initially preregistered our main hypotheses and analysis intentions for the first experiment. We then conducted a pilot study with N=12 participants, before making some minor changes to the stimulus (we added dim red lines to aid binocular fusion). We then ran the main experiment, followed by two additional experiments that were not preregistered. The preregistration document, raw data files, and experimental and analysis code, are available on the project repository: https://osf.io/tbema/.

# Results

## Experiment 1

```{r include=FALSE, results='hide'}

# (download and) analyse individual participant data for experiment 1

if (processdata > 2){
  
legaltriggers <- 1

timeseq <- seq(1/120,10,length.out=120*10)
timeseq2 <- seq(1/120,14,length.out=120*14)
EEGtimes <- seq(1/1000,10,1/1000)
targetindex <- (2*10)+1
maskindex <- (1.6*10)+1
targetindex2 <- (2*2*10)+1
maskindex2 <- (2*1.6*10)+1

  for (participant in 1:30){
    
    # only download and process data if this has not been done already for this participant
    if (!file.exists(paste0(datadir,'P',100+participant,'summary.RData'))){   

      # if there is no directory for this participant's data
      if (!file.exists(paste0(rawdir,'P',100+participant))){
        dir.create(paste0(rawdir,'P',100+participant))
        
       d <- dir(paste0(rawdir,'P',100+participant))
       
       if (length(d)==0){
         
         # if the tar file of this participant's data doesn't exist
         if (!file.exists(paste0(rawdir,'P',100+participant,'.tar'))){
           # download it from OSF
           if (!exists('osffiles')){
           osfnode <- 'x8u4v'
           osfproject <- osf_retrieve_node(osfnode)
          osffiles <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffiles$name==paste0('P',100+participant,'.tar'))
          osf_download(osffiles[fid,],rawdir,progress=TRUE)
         }
         
         # then unzip the tar file
         untar(paste0(rawdir,'P',100+participant,'.tar'),exdir=paste0(rawdir,'P',100+participant))
         
         # and delete the tar file to save storage space
         file.remove(paste0(rawdir,'P',100+participant,'.tar'))
       }
      
      d <- dir(paste0(rawdir,'P',100+participant),full.names=TRUE)
       
      pupiltargets <- array(0,dim=c(3,2,60))
pupilmasks <- pupiltargets
pupilwaveforms <- array(0,dim=c(3,2,60,120*14))
pupilspectra <- array(0,dim=c(3,2,60,300))
EEGtargets <- array(0,dim=c(3,64,60))
EEGmasks <- EEGtargets
EEGtargets2 <- EEGtargets
EEGmasks2 <- EEGtargets
EEGwaveforms <- array(0,dim=c(3,64,60,1000*14))
EEGspectra <- array(0,dim=c(3,64,60,300))

psychopyfiles <- dir(path=paste0(rawdir,'P',100+participant),pattern=paste0('P',100+participant,'_CRFstudy'), full.names = TRUE)
infofiles <- dir(path=paste0(rawdir,'P',100+participant),pattern='*_info.csv', full.names = TRUE)
EEGfiles <- dir(path=paste0(rawdir,'P',100+participant),pattern='*_EEG.csv.gz', full.names = TRUE)
pupilfiles <- dir(path=paste0(rawdir,'P',100+participant),pattern='*_pupil_positions.csv', full.names = TRUE)

for (block in 1:length(EEGfiles)){
  
    infofile <- read.csv(infofiles[block])
  pupilstarttime <- as.numeric(as.character(infofile[4,2]))
  localstarttime <- as.numeric(as.character(infofile[5,2]))
  
  psychoutput <- read.csv(psychopyfiles[block])

  trialtimes <- psychoutput$trialonset - pupilstarttime
  condorder <- psychoutput$condition
  
    EEGdata <- read.csv(EEGfiles[block])
  electrodes <- colnames(EEGdata)
  
      triggertimes <- NULL
    counter <- 0
    lasttrigger <- -10000
    for (n in 1:nrow(EEGdata)){
      if(EEGdata$Trigger[n] %in% legaltriggers){
        if(n>(lasttrigger+10000)){
        counter <- counter + 1
        triggertimes[counter] <- n
        lasttrigger <- n
      }}
    }
  
    for (cond in 1:60){
      for (ch in 1:64){
        trial <- EEGdata[(triggertimes[cond]+(2001:12000)),ch+2]
        fspec <- (fft(trial)/length(trial))
        EEGtargets[block,ch,condorder[cond]] <- fspec[targetindex]
        EEGmasks[block,ch,condorder[cond]] <- fspec[maskindex]
        EEGtargets2[block,ch,condorder[cond]] <- fspec[targetindex2]
        EEGmasks2[block,ch,condorder[cond]] <- fspec[maskindex2]
        EEGspectra[block,ch,condorder[cond],1:300] <- fspec[1:300]
        
        trial <- EEGdata[(triggertimes[cond]+(-999:13000)),ch+2]
        EEGwaveforms[block,ch,condorder[cond],] <- trial - mean(trial[1:1000])
      }}
    
    
  pdata <- read.csv(pupilfiles[block])
  pdata2 <- pdata[,c(1,3,4,14)]
  pdata2[,1] <- pdata2[,1] - localstarttime
  pdata2 <- pdata2[which(pdata2[,3]>0.0),]

  for (eye in 1:2){
    eyedata <- pdata2[which(pdata2[,2]==(2-eye)),]
    for (cond in 1:60){
      a <- which(eyedata[,1]>trialtimes[cond]+2)
      b <- which(eyedata[,1]<(trialtimes[cond]+12))
      i <- intersect(a,b)
      trial <- eyedata[i,]
      trial[,1] <- trial[,1] - trial[1,1]
      if (nrow(trial)>3){
        resampled <- interp1(trial[,1],trial[,4],timeseq,method='linear',extrap=TRUE)
        fspec <- (fft(resampled)/length(resampled))
        pupiltargets[block,eye,condorder[cond]] <- fspec[targetindex]
        pupilmasks[block,eye,condorder[cond]] <- fspec[maskindex]
        pupilspectra[block,eye,condorder[cond],1:300] <- fspec[1:300]
      }
      
      a <- which(eyedata[,1]>(trialtimes[cond]-1))
      b <- which(eyedata[,1]<(trialtimes[cond]+13))
      i <- intersect(a,b)
      trial <- eyedata[i,]
      trial[,1] <- trial[,1] - trial[1,1]
      if (nrow(trial)>3){
        resampled <- interp1(trial[,1],trial[,4],timeseq2,method='linear',extrap=TRUE)
        pupilwaveforms[block,eye,condorder[cond],] <- resampled - mean(resampled[1:120])
      }
      
      }}
  
}

cleanmeansP <- matrix(0,nrow=6,ncol=5)
cleanmasksP <- matrix(0,nrow=6,ncol=5)
cleanmeansE <- array(0,dim=c(64,6,5))
cleanmasksE <- array(0,dim=c(64,6,5))
cleanmeansE2 <- array(0,dim=c(64,6,5))
cleanmasksE2 <- array(0,dim=c(64,6,5))

for (cond in 1:6){
  startindex <- (10*(cond-1))
  for (level in 1:5){
    temp <- c(pupiltargets[,,startindex+level],pupiltargets[,,startindex+level+5])
        cartdata <- data.frame(Re(temp),Im(temp))
    if (sum(cartdata)!=0){
      D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
      i <- which(D<SDthresh) 
    cleanmeansP[cond,level] <- mean(temp[i])}

    temp <- c(pupilmasks[,,startindex+level],pupiltargets[,,startindex+level+5])
        cartdata <- data.frame(Re(temp),Im(temp))
    if (sum(cartdata)!=0){
      D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
      i <- which(D<SDthresh) 
    cleanmasksP[cond,level] <- mean(temp[i])}

    for (ch in 1:64){
    temp <- c(EEGtargets[,ch,startindex+level],EEGtargets[,ch,startindex+level+5])
            cartdata <- data.frame(Re(temp),Im(temp))
    if (sum(cartdata)!=0){
      D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
      i <- which(D<SDthresh) 
    cleanmeansE[ch,cond,level] <- mean(temp[i])}
    
    temp <- c(EEGmasks[,ch,startindex+level],EEGmasks[,ch,startindex+level+5])
                cartdata <- data.frame(Re(temp),Im(temp))
    if (sum(cartdata)!=0){
      D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
      i <- which(D<SDthresh) 
    cleanmasksE[ch,cond,level] <- mean(temp[i])}
    
    temp <- c(EEGtargets2[,ch,startindex+level],EEGtargets2[,ch,startindex+level+5])
                cartdata <- data.frame(Re(temp),Im(temp))
    if (sum(cartdata)!=0){
      D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
      i <- which(D<SDthresh) 
    cleanmeansE2[ch,cond,level] <- mean(temp[i])}
    
    temp <- c(EEGmasks2[,ch,startindex+level],EEGmasks2[,ch,startindex+level+5])
                cartdata <- data.frame(Re(temp),Im(temp))
    if (sum(cartdata)!=0){
      D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
      i <- which(D<SDthresh) 
    cleanmasksE2[ch,cond,level] <- mean(temp[i])}   
    }

  }
}

electrodeindices <- match(targetelectrodes,electrodes)-2

meanwavesP <- apply(pupilwaveforms[,,c(15,20),],4,mean,na.rm=TRUE)
meanwavesE <- apply(EEGwaveforms[,electrodeindices,c(15,20),],4,mean,na.rm=TRUE)
meanspectraP <- apply(pupilspectra[,,c(15,20),],4,mean,na.rm=TRUE)
meanspectraE <- apply(EEGspectra[,electrodeindices,c(15,20),],4,mean,na.rm=TRUE)
save(file=paste(datadir,'P',100+participant,'summary.RData',sep=''),list=c('cleanmeansP','cleanmeansE','cleanmeansE2','cleanmasksP','cleanmasksE','cleanmasksE2','meanspectraP','meanspectraE','meanwavesP','meanwavesE','electrodes'))

      }
        
        
      }
      
    
    }
  }
  


```

```{r include=FALSE, results='hide'}

# load in individual participant data and average, save group data

if (processdata > 1){

         if (!file.exists(paste0(datadir,'headerfile.csv'))){
           # download it from OSF
           if (!exists('osffiles')){
           osfnode <- 'x8u4v'
           osfproject <- osf_retrieve_node(osfnode)
          osffiles <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffiles$name=='headerfile.csv')
          osf_download(osffiles[fid,],datadir,progress=TRUE)
          } 
  
  hdata <- read.csv(paste0(datadir,'headerfile.csv'))  

for (participant in 1:30){
         # if the summary file of this participant's data doesn't exist
         if (!file.exists(paste0(datadir,'P',100+participant,'summary.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '2qu6y'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name==paste0('P',100+participant,'summary.RData'))
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
         }
}

 
d <- dir(datadir,pattern='*summary.RData',full.names=TRUE)

allmasksP <- array(0,dim=c(length(d),6,5))
allmeansP <- allmasksP
allmasksE <- array(0,dim=c(length(d),64,6,5))
allmeansE <- allmasksE
allmeansE2 <- allmeansE
allmasksE2 <- allmasksE
allspectraP <- array(0,dim=c(length(d),300))
allspectraE <- array(0,dim=c(length(d),300))
allwavesP <- array(0,dim=c(length(d),1680))
allwavesE <- array(0,dim=c(length(d),14000))

  for (s in 1:length(d)){
    
    load(d[s])
    
  allmasksP[s,,] <- cleanmasksP
  allmeansP[s,,] <- cleanmeansP
  allspectraP[s,] <- meanspectraP
  allspectraE[s,] <- meanspectraE
  allwavesP[s,] <- meanwavesP
  allwavesE[s,] <- meanwavesE
  allmeansE[s,,,] <- cleanmeansE
  allmasksE[s,,,] <- cleanmasksE
  allmeansE2[s,,,] <- cleanmeansE2
  allmasksE2[s,,,] <- cleanmasksE2
    
  }

electrodeindices <- match(targetelectrodes,electrodes)-2

allspectraP <- allspectraP[-c(2,4,13,20,26),]

cleanmeansP <- matrix(0,nrow=6,ncol=5)
cleanmeansPCI <- array(0,c(2,6,5))
cleanmasksP <- matrix(0,nrow=6,ncol=5)
cleanmasksPCI <- array(0,c(2,6,5))
cleanmeansEav <- matrix(0,nrow=6,ncol=5)
cleanmeansEavCI <- array(0,c(2,6,5))
cleanmasksEav <- matrix(0,nrow=6,ncol=5)
cleanmasksEavCI <- array(0,c(2,6,5))
cleanmeansE2av <- matrix(0,nrow=6,ncol=5)
cleanmeansE2avCI <- array(0,c(2,6,5))
cleanmasksE2av <- matrix(0,nrow=6,ncol=5)
cleanmasksE2avCI <- array(0,c(2,6,5))
cleanmeansE <- array(0,dim=c(64,6,5))
cleanmeansECI <- array(0,c(2,64,6,5))
cleanmasksE <- array(0,dim=c(64,6,5))
cleanmasksECI <- array(0,c(2,64,6,5))
cleanmeansE2 <- array(0,dim=c(64,6,5))
cleanmeansE2CI <- array(0,c(2,64,6,5))
cleanmasksE2 <- array(0,dim=c(64,6,5))
cleanmasksE2CI <- array(0,c(2,64,6,5))


for (cond in 1:6){
  for (level in 1:5){
    
    temp <- allmeansP[,cond,level]
    cartdata <- data.frame(Re(temp),Im(temp))
    if (sum(cartdata)!=0){
      D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
      i <- which(D<SDthresh) 
    mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
    cleanmeansP[cond,level] <- mbs$meanamp
    cleanmeansPCI[1,cond,level] <- mbs$lowerCI
    cleanmeansPCI[2,cond,level] <- mbs$upperCI
    }    
      
    temp <- allmasksP[,cond,level]
    cartdata <- data.frame(Re(temp),Im(temp))
    if (sum(cartdata)!=0){
      D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
      i <- which(D<SDthresh) 
          mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
    cleanmasksP[cond,level] <- mbs$meanamp
    cleanmasksPCI[1,cond,level] <- mbs$lowerCI
    cleanmasksPCI[2,cond,level] <- mbs$upperCI
}
  
    
      temp <- apply(allmeansE[,electrodeindices,cond,level],1,mean)
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh) 
    mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
    cleanmeansEav[cond,level] <- mbs$meanamp
    cleanmeansEavCI[1,cond,level] <- mbs$lowerCI
    cleanmeansEavCI[2,cond,level] <- mbs$upperCI
      }
      
temp <- apply(allmasksE[,electrodeindices,cond,level],1,mean)
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh) 
mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
    cleanmasksEav[cond,level] <- mbs$meanamp
    cleanmasksEavCI[1,cond,level] <- mbs$lowerCI
    cleanmasksEavCI[2,cond,level] <- mbs$upperCI
        }

temp <- apply(allmeansE2[,electrodeindices,cond,level],1,mean)
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh) 
    mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
    cleanmeansE2av[cond,level] <- mbs$meanamp
    cleanmeansE2avCI[1,cond,level] <- mbs$lowerCI
    cleanmeansE2avCI[2,cond,level] <- mbs$upperCI
        }

      temp <- apply(allmasksE2[,electrodeindices,cond,level],1,mean)
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh) 
    mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
    cleanmasksE2av[cond,level] <- mbs$meanamp
    cleanmasksE2avCI[1,cond,level] <- mbs$lowerCI
    cleanmasksE2avCI[2,cond,level] <- mbs$upperCI
        }
      
    for (ch in 1:64){
      
      temp <- allmeansE[,ch,cond,level]
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh) 
    mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
    cleanmeansE[ch,cond,level] <- mbs$meanamp
    cleanmeansECI[1,ch,cond,level] <- mbs$lowerCI
    cleanmeansECI[2,ch,cond,level] <- mbs$upperCI
}

      temp <- allmasksE[,ch,cond,level]
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh) 
mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
    cleanmasksE[ch,cond,level] <- mbs$meanamp
    cleanmasksECI[1,ch,cond,level] <- mbs$lowerCI
    cleanmasksECI[2,ch,cond,level] <- mbs$upperCI
        }

      temp <- allmeansE2[,ch,cond,level]
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh) 
    mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
    cleanmeansE2[ch,cond,level] <- mbs$meanamp
    cleanmeansE2CI[1,ch,cond,level] <- mbs$lowerCI
    cleanmeansE2CI[2,ch,cond,level] <- mbs$upperCI
        }
      
      temp <- allmasksE2[,ch,cond,level]
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh) 
    mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
    cleanmasksE2[ch,cond,level] <- mbs$meanamp
    cleanmasksE2CI[1,ch,cond,level] <- mbs$lowerCI
    cleanmasksE2CI[2,ch,cond,level] <- mbs$upperCI
        }
      
    }}}

meanspectraP <- (1:300)*0
meanspectraE <- (1:300)*0
meanspectraPCI <- array(0,c(2,300))
meanspectraECI <- array(0,c(2,300))

for (f in 2:300){
  
        temp <- allspectraP[,f]
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh) 
mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
meanspectraP[f] <- mbs$meanamp
meanspectraPCI[1,f] <- mbs$lowerCI
meanspectraPCI[2,f] <- mbs$upperCI
      }
      
        temp <- allspectraE[,f]
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh) 
mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
meanspectraE[f] <- mbs$meanamp
meanspectraECI[1,f] <- mbs$lowerCI
meanspectraECI[2,f] <- mbs$upperCI
      }
}

meanwavesP <- NULL
meanwavesE <- NULL
meanwavesPCI <- array(0,dim=c(2,dim(allwavesP)[2]))
meanwavesECI <- array(0,dim=c(2,dim(allwavesE)[2]))
nsubjs <- dim(allwavesP)[1]
for (t in 1:dim(allwavesP)[2]){
  temp <- allwavesP[,t]
  i <- which(abs(temp-mean(temp))<(SDthresh*sd(temp)))
  meanwavesP[t] <- mean(temp[i])
  bspop <- NULL
  for (s in 1:nbootstraps){bspop[s] <- mean(sample(temp[i],length(i),replace=TRUE))}
  meanwavesPCI[,t] <- quantile(bspop,c(0.16,0.84),na.rm=TRUE)
}

for (t in 1:dim(allwavesE)[2]){
    temp <- allwavesE[,t]
  i <- which(abs(temp-mean(temp))<(SDthresh*sd(temp)))
  meanwavesE[t] <- mean(temp[i])
  bspop <- NULL
  for (s in 1:nbootstraps){bspop[s] <- mean(sample(temp[i],length(i),replace=TRUE))}
  meanwavesECI[,t] <- quantile(bspop,c(0.16,0.84),na.rm=TRUE)
}

save(file=paste0(datadir,'Averagedata.RData'),list=c('cleanmeansP','cleanmeansPCI','cleanmasksP','cleanmasksPCI','cleanmeansEav','cleanmeansEavCI','cleanmasksEav','cleanmasksEavCI','cleanmeansE2av','cleanmeansE2avCI','cleanmasksE2av','cleanmasksE2avCI','cleanmeansE','cleanmeansECI','cleanmasksECI','cleanmeansE2','cleanmeansE2CI','cleanmasksE2','cleanmasksE2CI','meanspectraP','meanspectraPCI','meanspectraE','meanspectraECI','meanwavesP','meanwavesE','meanwavesPCI','meanwavesECI','electrodes','allmeansP','allmeansE','allmeansE2'))

}

```

```{r include=FALSE, results='hide'}

# generate plot showing the group pupillometry data

         if (!file.exists(paste0(datadir,'Averagedata.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '2qu6y'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name=='Averagedata.RData')
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
         }

load(file=paste0(datadir,'Averagedata.RData'))

if (processdata > 0){

contrastsdB <- 20*log10(c(6,12,24,48,96))

plotlims <- c(15,40,0,0.03) 
ticklocsx <- contrastsdB    # locations of tick marks on x axis
ticklocsy <- seq(0,0.03,0.01)    # locations of tick marks on y axis
ticklabelsx <-c(6,12,24,48,96)        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

postscript("CRF1p.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude at 2Hz (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansP[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  arrows(contrastsdB,abs(cleanmeansP[cond,]),contrastsdB,cleanmeansPCI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansP[cond,]),contrastsdB,cleanmeansPCI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  points(contrastsdB,abs(cleanmeansP[cond,]), pch = 20+cond, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves
}  
legend(22,0.03,c('Monocular','Binocular','Dichoptic'),pch=21:23,pt.bg=colpal[1:3],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.028,'(c)',adj=0.5,cex=2.5)

dev.off()

postscript("CRF2p.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)   
title(ylab="Amplitude at 2Hz (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

condlist <- c(1,5,6)
pointlist <- c(21,24,25)
for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansP[condlist[cond],]), col=colpal[condlist[cond]], lwd=3, cex=0.5)  
  arrows(contrastsdB,abs(cleanmeansP[condlist[cond],]),contrastsdB,cleanmeansPCI[1,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansP[condlist[cond],]),contrastsdB,cleanmeansPCI[2,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)  
  points(contrastsdB,abs(cleanmeansP[condlist[cond],]), pch = pointlist[cond], col='black', bg=colpal[condlist[cond]], cex=1.6, lwd=3)   
}  
legend(22,0.03,c('Monocular','Binocular cross','Dichoptic cross'),pch=pointlist,pt.bg=colpal[condlist],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.028,'(d)',adj=0.5,cex=2.5)

dev.off()


postscript("CRF3p.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude at 1.6Hz (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

for (cond in 4:6){
  lines(contrastsdB,abs(cleanmasksP[cond,]), col=colpal[cond], lwd=3, cex=0.5)   
  arrows(contrastsdB,abs(cleanmasksP[cond,]),contrastsdB,cleanmasksPCI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmasksP[cond,]),contrastsdB,cleanmasksPCI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)    
  points(contrastsdB,abs(cleanmasksP[cond,]), pch = pointlist[cond-3], col='black', bg=colpal[cond], cex=1.6, lwd=3) 
}
legend(22,0.03,c('Monocular 1.6Hz','Binocular cross','Dichoptic cross'),pch=pointlist,pt.bg=colpal[4:6],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.028,'(e)',adj=0.5,cex=2.5)

dev.off()


postscript("SpecP.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 8)

frequencies <- (0:299)/10

plotlims <- c(1,6,0,0.03) 
ticklocsx <- seq(1,6,1)    # locations of tick marks on x axis
ticklocsy <- seq(0,0.03,0.01)    # locations of tick marks on y axis
ticklabelsx <-ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
title(xlab="Frequency (Hz)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

polygon(frequencies[c(11:61,61:11)],c(meanspectraPCI[1,11:61],meanspectraPCI[2,61:11]),col=colpal[2],border=NA)

lines(frequencies[11:61],abs(meanspectraP[11:61]), col=colpal[2], lwd=3, cex=0.5) 

text(1.1,0.028,'(b)',adj=0.5,cex=2.5)

dev.off()



postscript("timecourseP.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 8)

times <- seq((1/120)-1,13,1/120)
sinewave <- sin(2*times * 2*pi)
sinewave[1:120] <- 0
sinewave[1560:1680] <- 0

plotlims <- c(-1,13,-1,0.5) 
ticklocsx <- seq(-1,13,1)    # locations of tick marks on x axis
ticklocsy <- seq(-1,0.5,0.5)    # locations of tick marks on y axis
ticklabelsx <- ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
title(xlab="Time (s)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

filt <- butter(3,0.083)
filtwaveP <- signal::filter(filt, meanwavesP)
filtU <- signal::filter(filt,meanwavesPCI[1,])
filtL <- signal::filter(filt,meanwavesPCI[2,])
polygon(times[c(1:length(times),length(times):1)],c(filtL,filtU[length(filtU):1]),col=colpal[2],border=NA)

lines(times, filtwaveP, col=colpal[2], lwd=1.5) 

lines(times, (sinewave/10)-0.9, col='black', lwd=3) 

text(-0.7,0.4,'(a)',adj=0.5,cex=2.5)

dev.off()

         if (!file.exists(paste0(localdir,'StimulusExample.png'))){
           # download it from OSF
           if (!exists('osffiles')){
           osfnode <- 'tbema'
           osfproject <- osf_retrieve_node(osfnode)
          osffiles <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffiles$name=='StimulusExample.png')
          osf_download(osffiles[fid,],localdir,progress=TRUE)
         } 

stim <- readPNG('local/StimulusExample.png')

  PostScriptTrace('CRF1p.ps')
  p1 <- readPicture('CRF1p.ps.xml')
  PostScriptTrace('CRF2p.ps')
  p2 <- readPicture('CRF2p.ps.xml')
  PostScriptTrace('CRF3p.ps')
  p3 <- readPicture('CRF3p.ps.xml')
  PostScriptTrace('SpecP.ps')
  p4 <- readPicture('SpecP.ps.xml')
  PostScriptTrace('timecourseP.ps')
  p5 <- readPicture('timecourseP.ps.xml')
  
    for (n in 1:length(p4@paths)){
    temp <- class(p4@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(p4@paths[n]$path@rgb))<765){p4@paths[n]$path@rgb <- addalpha(p4@paths[n]$path@rgb,alpha=0.2)}}}
  
      for (n in 1:length(p5@paths)){
    temp <- class(p5@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(p5@paths[n]$path@rgb))<765){p5@paths[n]$path@rgb <- addalpha(p5@paths[n]$path@rgb,alpha=0.2)}}}

  
  pdf(paste0(figdir,"pupildata.pdf"), bg="transparent", height = 10, width = 15)
  par(mar=c(0.1,0.1,0.1,0.1))
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(0,1), ylim=c(0,1))
  
  aspratio <- 10/15  # this is the aspect ratio of the output pdf
  imwidth <- 0.2
  xstart <- 0.85
  ystart <- 0.72
  rasterImage(stim,xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth) 
  
  grid.picture(p1,x=0.17,y=0.25,width=0.32,height=1)
  grid.picture(p2,x=0.5,y=0.25,width=0.32,height=1)
  grid.picture(p3,x=0.83,y=0.25,width=0.32,height=1)
  grid.picture(p5,x=0.25,y=0.7,width=0.5,height=1)
  grid.picture(p4,x=0.75,y=0.7,width=0.5,height=1)
  
  text(0.5,0.98,'Pupillometry',cex=4)
  
  dev.off()
  
  file.remove(c('CRF1p.ps','CRF2p.ps','CRF3p.ps','SpecP.ps','timecourseP.ps'))
  file.remove(c('CRF1p.ps.xml','CRF2p.ps.xml','CRF3p.ps.xml','SpecP.ps.xml','timecourseP.ps.xml'))

}

```

```{r include=FALSE, results='hide'}

# do statistics on the pupillometry data

alldata <- NULL
groupID <- NULL
allP <- NULL
counter <- 0
for (cont in 1:dim(allmeansP)[3]){
  for (p in 1:dim(allmeansP)[1]){
    counter <- counter + 1
    alldata[counter] <- allmeansP[p,3,cont]
    groupID[counter] <- cont
    allP[counter] <- p
  }
}
dichA2c <- anovacirc.test(alldata,group=groupID,participant=allP)
# groupID <- as.factor(groupID)
# participantID <- as.factor(participantID)
# adata <- data.frame(dichdata,groupID,participantID)
# dichA2c <- ezANOVA(data = adata, dv = dichdata, within=groupID, wid=participantID)


alldata <- NULL
allgroupA <- NULL
allgroupB <- NULL
allP <- NULL
counter <- 0
for (p in 1:30){
  for (lev in 1:5){
    for (cond in 1:2){
    counter <- counter + 1
    alldata[counter] <- allmeansP[p,cond,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- cond
    allP[counter] <- p
    }
  }
}
monbinPstats <- anovacirc2way(alldata,allgroupA,allgroupB,allP)
# allgroupA <- as.factor(allgroupA)
# allgroupB <- as.factor(allgroupB)
# allP <- as.factor(allP)
# alldata <- abs(alldata)
# adata <- data.frame(alldata,allgroupA,allgroupB,allP)
# monbinPstats <- ezANOVA(data = adata, dv = alldata, within=c(allgroupA,allgroupB), wid=allP)


alldata <- NULL
allgroupA <- NULL
allgroupB <- NULL
allP <- NULL
counter <- 0
for (p in 1:30){
  for (lev in 1:5){
    counter <- counter + 1
    alldata[counter] <- allmeansP[p,1,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- 1
    allP[counter] <- p

    counter <- counter + 1
    alldata[counter] <- allmeansP[p,3,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- 2
    allP[counter] <- p
  }
}
mondichPstats <- anovacirc2way(alldata,allgroupA,allgroupB,allP)
# allgroupA <- as.factor(allgroupA)
# allgroupB <- as.factor(allgroupB)
# allP <- as.factor(allP)
# alldata <- abs(alldata)
# adata <- data.frame(alldata,allgroupA,allgroupB,allP)
# mondichPstats <- ezANOVA(data = adata, dv = alldata, within=c(allgroupA,allgroupB), wid=allP)


alldata <- NULL
allgroupA <- NULL
allgroupB <- NULL
allP <- NULL
counter <- 0
for (p in 1:30){
  for (lev in 1:5){
    counter <- counter + 1
    alldata[counter] <- allmeansP[p,1,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- 1
    allP[counter] <- p

    counter <- counter + 1
    alldata[counter] <- allmeansP[p,5,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- 2
    allP[counter] <- p
  }
}

monbinPstatsX <- anovacirc2way(alldata,allgroupA,allgroupB,allP)
# allgroupA <- as.factor(allgroupA)
# allgroupB <- as.factor(allgroupB)
# allP <- as.factor(allP)
# alldata <- abs(alldata)
# adata <- data.frame(alldata,allgroupA,allgroupB,allP)
# monbinPstatsX <- ezANOVA(data = adata, dv = alldata, within=c(allgroupA,allgroupB), wid=allP)

alldata <- NULL
allgroupA <- NULL
allgroupB <- NULL
allP <- NULL
counter <- 0
for (p in 1:30){
  for (lev in 1:5){
    counter <- counter + 1
    alldata[counter] <- allmeansP[p,1,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- 1
    allP[counter] <- p

    counter <- counter + 1
    alldata[counter] <- allmeansP[p,6,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- 2
    allP[counter] <- p
  }
}

mondichPstatsX <- anovacirc2way(alldata,allgroupA,allgroupB,allP)
# allgroupA <- as.factor(allgroupA)
# allgroupB <- as.factor(allgroupB)
# allP <- as.factor(allP)
# alldata <- abs(alldata)
# adata <- data.frame(alldata,allgroupA,allgroupB,allP)
# mondichPstatsX <- ezANOVA(data = adata, dv = alldata, within=c(allgroupA,allgroupB), wid=allP)

```

The pupillometry results are summarised in Figure \@ref(fig:pupildata). The group average waveform for binocular presentation is shown in Figure \@ref(fig:pupildata)a. There is a substantial pupil constriction at stimulus onset, followed by visible oscillations at the flicker frequency (2Hz, see waveform at foot). The average Fourier spectrum is displayed in Figure \@ref(fig:pupildata)b, and shows a substantial spike at 2 Hz, but no evidence of a second harmonic response at 4Hz. These results demonstrate that our paradigm can evoke measurable steady-state pupil responses at 2Hz.

```{r pupildata, fig.cap="Summary of pupillometry results for N=30 participants. Panel (a) shows a group average waveform for binocular presentation (low pass filtered at 5Hz), with the driving signal plotted at the foot. Panel (b) shows the average Fourier spectrum, with an inset image illustrating the stimulus appearance (upper right). Panels (c,d) show contrast response functions at 2Hz for different conditions. Panel (e) shows contrast response functions at 1.6Hz for three conditions. Shaded regions and error bars indicate bootstrapped standard errors.", fig.align="center", echo=FALSE}

knitr::include_graphics(paste0(figdir,'pupildata.pdf'))

```

Figure \@ref(fig:pupildata)c shows contrast response functions in response to stimuli flickering only at 2Hz. Response amplitudes increased monotonically with target contrast, confirming that our paradigm is suitable for measuring contrast-dependent differences in response (to our knowledge this is the first time this has been demonstrated). The amplitude of the binocular condition (blue squares) is consistently greater than that of the monocular condition (red circles) across all target contrasts. A $2\times5$ repeated measures $ANOVA^2_{circ}$ [@Baker2021] comparing these conditions revealed a significant main effect of target contrast (F(`r monbinPstats$dfA`,`r monbinPstats$dfR`) = `r round(monbinPstats$FratioA,digits=2)`, $p$ < 0.001), a significant effect of condition (F(`r monbinPstats$dfB`,`r monbinPstats$dfR`) = `r round(monbinPstats$FratioB,digits=2)`, $p$ < 0.001), and a significant interaction (F(`r monbinPstats$dfAB`,`r monbinPstats$dfR`) = `r round(monbinPstats$FratioAB,digits=2)`, $p$ < 0.001). The dichoptic condition begins at a much higher amplitude, owing to binocular combination of the target and high (48%) contrast mask, and then increases slightly with increasing target contrast (main effect of target contrast: F(`r dichA2c$dfM`,`r dichA2c$dfR`) = `r round(dichA2c$Fratio,digits=2)`, $p$ < `r round(dichA2c$pval,digits=3)`).

In Figure \@ref(fig:pupildata)d, we plot responses to monocular target stimuli flickering at 2Hz, when the other eye viewed stimuli flickering at 1.6Hz (the red monocular-only data are replotted from Figure \@ref(fig:pupildata)c for comparison). When the 1.6Hz component had the same contrast as the target (the binocular cross condition, shown in purple) responses were facilitated slightly at low contrasts, and suppressed at the highest target contrasts (interaction between contrast and condition: F(`r monbinPstatsX$dfAB`,`r monbinPstatsX$dfR`) = `r round(monbinPstatsX$FratioAB,digits=2)`, $p$ < 0.001). When the 1.6Hz component had a fixed contrast of 48% (the dichoptic cross condition, shown in yellow), responses were suppressed slightly across the contrast range (interaction between contrast and condition: F(`r mondichPstatsX$dfAB`,`r mondichPstatsX$dfR`) = `r round(mondichPstatsX$FratioAB,digits=2)`, $p$ < 0.001).

Figure \@ref(fig:pupildata)e shows responses at 1.6Hz, for the same conditions, as well as for a condition in which a monocular stimulus flickered at 1.6Hz (grey circles). Surprisingly there appears to be a slight facilitation effect in the binocular cross condition, particularly at lower contrasts. The dichoptic cross condition does not show clear modulation with target contrast.

Figure \@ref(fig:EEGdata) shows equivalent results, measured contemporaneously using EEG. Figure \@ref(fig:EEGdata)a shows the group average waveform for binocular presentation, and Figure \@ref(fig:EEGdata)b shows the Fourier spectrum for binocular presentation, both averaged across four posterior electrodes (_Oz_, _POz_, _O1_ and _O2_, marked on the inset scalp plots). Unlike for the pupillometry data, there are clear responses at both the first harmonic frequency (2Hz), and also the second harmonic frequency (4Hz). We therefore calculated contrast response functions at both first and second harmonic frequencies.

```{r include=FALSE, results='hide'}

# generate plot showing the group EEG data


contrastsdB <- 20*log10(c(6,12,24,48,96))

         if (!file.exists(paste0(datadir,'headerfile.csv'))){
           # download it from OSF
           if (!exists('osffiles')){
           osfnode <- 'x8u4v'
           osfproject <- osf_retrieve_node(osfnode)
          osffiles <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffiles$name=='headerfile.csv')
          osf_download(osffiles[fid,],datadir,progress=TRUE)
          } 
hdata <- read.csv(paste0(datadir,'headerfile.csv'))  

         if (!file.exists(paste0(datadir,'Averagedata.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '2qu6y'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name=='Averagedata.RData')
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
         }

load(file=paste0(datadir,'Averagedata.RData'))

electrodeindices <- match(targetelectrodes,electrodes)-2

if (processdata > 0){

plotlims <- c(15,40,0,0.8)  
ticklocsx <- contrastsdB    # locations of tick marks on x axis
ticklocsy <- seq(0,0.8,0.2)    # locations of tick marks on y axis
ticklabelsx <-c(6,12,24,48,96)        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

postscript("CRF1e.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude (µV) at 2Hz", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansEav[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  arrows(contrastsdB,abs(cleanmeansEav[cond,]),contrastsdB,cleanmeansEavCI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansEav[cond,]),contrastsdB,cleanmeansEavCI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  points(contrastsdB,abs(cleanmeansEav[cond,]), pch = 20+cond, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves
}  
legend(22,0.8,c('Monocular','Binocular','Dichoptic'),pch=21:23,pt.bg=colpal[1:3],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.75,'(c)',adj=0.5,cex=2.5)

dev.off()

postscript("CRF2e.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)   
title(ylab="Amplitude (µV) at 2Hz", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

condlist <- c(1,5,6)
pointlist <- c(21,24,25)
for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansEav[condlist[cond],]), col=colpal[condlist[cond]], lwd=3, cex=0.5)  
  arrows(contrastsdB,abs(cleanmeansEav[condlist[cond],]),contrastsdB,cleanmeansEavCI[1,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansEav[condlist[cond],]),contrastsdB,cleanmeansEavCI[2,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  points(contrastsdB,abs(cleanmeansEav[condlist[cond],]), pch = pointlist[cond], col='black', bg=colpal[condlist[cond]], cex=1.6, lwd=3)   
}  
legend(22,0.8,c('Monocular','Binocular cross','Dichoptic cross'),pch=pointlist,pt.bg=colpal[condlist],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.75,'(d)',adj=0.5,cex=2.5)

dev.off()


postscript("CRF3e.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude (µV) at 1.6Hz", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

for (cond in 4:6){
  lines(contrastsdB,abs(cleanmasksEav[cond,]), col=colpal[cond], lwd=3, cex=0.5)   
  arrows(contrastsdB,abs(cleanmasksEav[cond,]),contrastsdB,cleanmasksEavCI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmasksEav[cond,]),contrastsdB,cleanmasksEavCI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  points(contrastsdB,abs(cleanmasksEav[cond,]), pch = pointlist[cond-3], col='black', bg=colpal[cond], cex=1.6, lwd=3) 
}
legend(22,0.8,c('Monocular 1.6Hz','Binocular cross','Dichoptic cross'),pch=pointlist,pt.bg=colpal[4:6],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.75,'(e)',adj=0.5,cex=2.5)

dev.off()


postscript("CRF1e2.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude (µV) at 4Hz", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansE2av[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  arrows(contrastsdB,abs(cleanmeansE2av[cond,]),contrastsdB,cleanmeansE2avCI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  if (cond!=2){
  arrows(contrastsdB,abs(cleanmeansE2av[cond,]),contrastsdB,cleanmeansE2avCI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)}
  
  # plot an arrow for the final binocular target contrast level that is above 0.8
  if (cond==2){
  arrows(contrastsdB[1:4],abs(cleanmeansE2av[cond,1:4]),contrastsdB[1:4],cleanmeansE2avCI[2,cond,1:4],lwd=3,col=colpal[cond],length=0.05,angle=90)   
  arrows(contrastsdB[5],abs(cleanmeansE2av[cond,5]),contrastsdB[5],0.8,lwd=3,col=colpal[cond],length=0.05,angle=45)    
  }
  
  points(contrastsdB,abs(cleanmeansE2av[cond,]), pch = 20+cond, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves
}  
legend(22,0.8,c('Monocular','Binocular','Dichoptic'),pch=21:23,pt.bg=colpal[1:3],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.75,'(f)',adj=0.5,cex=2.5)

dev.off()

postscript("CRF2e2.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)   
title(ylab="Amplitude (µV) at 4Hz", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

condlist <- c(1,5,6)
pointlist <- c(21,24,25)
for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansE2av[condlist[cond],]), col=colpal[condlist[cond]], lwd=3, cex=0.5)  
  arrows(contrastsdB,abs(cleanmeansE2av[condlist[cond],]),contrastsdB,cleanmeansE2avCI[1,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansE2av[condlist[cond],]),contrastsdB,cleanmeansE2avCI[2,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  points(contrastsdB,abs(cleanmeansE2av[condlist[cond],]), pch = pointlist[cond], col='black', bg=colpal[condlist[cond]], cex=1.6, lwd=3)   
}  
legend(22,0.8,c('Monocular','Binocular cross','Dichoptic cross'),pch=pointlist,pt.bg=colpal[condlist],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.75,'(g)',adj=0.5,cex=2.5)

dev.off()


postscript("CRF3e2.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude (µV) at 3.2Hz", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

for (cond in 4:6){
  lines(contrastsdB,abs(cleanmasksE2av[cond,]), col=colpal[cond], lwd=3, cex=0.5)   
  arrows(contrastsdB,abs(cleanmasksE2av[cond,]),contrastsdB,cleanmasksE2avCI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmasksE2av[cond,]),contrastsdB,cleanmasksE2avCI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  points(contrastsdB,abs(cleanmasksE2av[cond,]), pch = pointlist[cond-3], col='black', bg=colpal[cond], cex=1.6, lwd=3) 
}
legend(22,0.8,c('Monocular 1.6Hz','Binocular cross','Dichoptic cross'),pch=pointlist,pt.bg=colpal[4:6],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.75,'(h)',adj=0.5,cex=2.5)

dev.off()


postscript("SpecE.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 8)

frequencies <- (0:299)/10

plotlims <- c(1,6,0,1) 
ticklocsx <- seq(1,6,1)    # locations of tick marks on x axis
ticklocsy <- seq(0,1,0.2)    # locations of tick marks on y axis
ticklabelsx <-ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
title(xlab="Frequency (Hz)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude (µV)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

polygon(frequencies[c(11:61,61:11)],c(meanspectraECI[1,11:61],meanspectraECI[2,61:11]),col=colpal[2],border=NA)

lines(frequencies[11:61],abs(meanspectraE[11:61]), col=colpal[2], lwd=3, cex=0.5) 

text(1.1,0.95,'(b)',adj=0.5,cex=2.5)

dev.off()



postscript("timecourseE.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 8)

times <- seq((1/1000)-1,13,1/1000)
sinewave <- sin(2*times * 2*pi)
sinewave[1:1000] <- 0
sinewave[13001:14000] <- 0

plotlims <- c(-1,13,-10,20) 
ticklocsx <- seq(-1,13,1)    # locations of tick marks on x axis
ticklocsy <- seq(-10,20,10)    # locations of tick marks on y axis
ticklabelsx <- ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
title(xlab="Time (s)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude (µV)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

filt <- butter(3,0.083*0.12)
filtwaveE <- signal::filter(filt, meanwavesE)
filtU <- signal::filter(filt,meanwavesECI[1,])
filtL <- signal::filter(filt,meanwavesECI[2,])
polygon(times[c(1:length(times),length(times):1)],c(filtL,filtU[length(filtU):1]),col=colpal[2],border=NA)

lines(times, filtwaveE, col=colpal[2], lwd=1.5) 

lines(times, (sinewave*2.5)-7.5, col='black', lwd=3) 

text(-0.7,18,'(a)',adj=0.5,cex=2.5)

dev.off()


xpos <- 1:64
ypos <- 1:64
montageE <- toupper(as.character(hdata$Electrode))
for (ch in 1:64){
  i <- match(toupper(electrodes[ch+2]),montageE)
  xpos[ch] <- hdata$X_position[i]
  ypos[ch] <- hdata$Y_position[i]
}

ramp2 <- colorRamp(c("white",colpal[2]))  # create a ramp from one colour to another
colmatrix2 <- rgb(ramp2(seq(0, 1, length = 101)), max = 255)

## Create data frame to be used for interpolation - the function needs columns labelled x, y, and z
rmax <- 0.55   #specify a maximum boundary for the grid
gridRes <- 100 #specify the interpolation grid resolution

toplot <- abs(cleanmeansE[,2,5])
toplot[which(is.na(toplot))] <- 0
testDat<- data.frame(x = xpos, y = -ypos, z = toplot)

#Create the interpolation grid
xo <- seq(min(-rmax, testDat$x), max(rmax, testDat$x), length = gridRes)
yo <- seq(max(rmax, testDat$y), min(-rmax, testDat$y), length = gridRes)

interpV4 <- v4Interp(testDat, xo, yo, rmax, gridRes)

zo2 <- as.matrix(interpV4[,2:ncol(interpV4)])

xo2 <- matrix(rep(xo,length(yo)),nrow = length(xo),ncol = length(yo))
yo2 <- t(matrix(rep(yo,length(xo)),nrow = length(yo),ncol = length(xo)))
outsidecircle <- sqrt(xo2^2 + yo2^2) > 0.51
zo2[outsidecircle] <- 0

tiff("head1.tiff", height = 600, width = 600, units="px", bg="white")

plotlims <- c(-rmax,rmax,-rmax,rmax) 
par(pty="s")  # make axis square
plot(x=NULL,y=NULL,ann=FALSE, axes=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
image(xo,xo,zo2,col=colmatrix2,zlim=c(0,1),add=TRUE,useRaster=TRUE)
maskx <- c(hdata$OutlineX[1:51]*2.2,hdata$OutlineX[51:1])
masky <- c(hdata$OutlineY[1:51]*2.2,hdata$OutlineY[51:1])
polygon(maskx,masky,border=NA,col="white")
maskx <- c(hdata$OutlineX[51:101]*2.2,hdata$OutlineX[101:51])
masky <- c(hdata$OutlineY[51:101]*2.2,hdata$OutlineY[101:51])
polygon(maskx,masky,border=NA,col="white")

blackelectrodes <- match(toupper(targetelectrodes),toupper(as.character(electrodes[3:66])))
points(xpos[blackelectrodes],ypos[blackelectrodes],pch=16,col="black",cex=2)

lines(hdata$OutlineX,hdata$OutlineY,col="black",lwd=2)
lines(hdata$NoseX,hdata$NoseY,col="black",lwd=2)
lines(hdata$LearX,hdata$LearY,col="black",lwd=2)
lines(hdata$RearX,hdata$RearY,col="black",lwd=2)

dev.off()


toplot <- abs(cleanmeansE2[,2,5])
toplot[which(is.na(toplot))] <- 0
testDat<- data.frame(x = xpos, y = -ypos, z = toplot)

#Create the interpolation grid
xo <- seq(min(-rmax, testDat$x), max(rmax, testDat$x), length = gridRes)
yo <- seq(max(rmax, testDat$y), min(-rmax, testDat$y), length = gridRes)

interpV4 <- v4Interp(testDat, xo, yo, rmax, gridRes)

zo2 <- as.matrix(interpV4[,2:ncol(interpV4)])

xo2 <- matrix(rep(xo,length(yo)),nrow = length(xo),ncol = length(yo))
yo2 <- t(matrix(rep(yo,length(xo)),nrow = length(yo),ncol = length(xo)))
outsidecircle <- sqrt(xo2^2 + yo2^2) > 0.51
zo2[outsidecircle] <- 0
zo2[which(zo2>1)] <- 1

tiff("head2.tiff", height = 600, width = 600, units="px", bg="white")

plotlims <- c(-rmax,rmax,-rmax,rmax) 
par(pty="s")  # make axis square
plot(x=NULL,y=NULL,ann=FALSE, axes=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
image(xo,xo,zo2,col=colmatrix2,zlim=c(0,1),add=TRUE,useRaster=TRUE)
maskx <- c(hdata$OutlineX[1:51]*2.2,hdata$OutlineX[51:1])
masky <- c(hdata$OutlineY[1:51]*2.2,hdata$OutlineY[51:1])
polygon(maskx,masky,border=NA,col="white")
maskx <- c(hdata$OutlineX[51:101]*2.2,hdata$OutlineX[101:51])
masky <- c(hdata$OutlineY[51:101]*2.2,hdata$OutlineY[101:51])
polygon(maskx,masky,border=NA,col="white")

blackelectrodes <- match(toupper(targetelectrodes),toupper(as.character(electrodes[3:66])))
points(xpos[blackelectrodes],ypos[blackelectrodes],pch=16,col="black",cex=2)

lines(hdata$OutlineX,hdata$OutlineY,col="black",lwd=2)
lines(hdata$NoseX,hdata$NoseY,col="black",lwd=2)
lines(hdata$LearX,hdata$LearY,col="black",lwd=2)
lines(hdata$RearX,hdata$RearY,col="black",lwd=2)

dev.off()


  PostScriptTrace('CRF1e.ps')
  p1 <- readPicture('CRF1e.ps.xml')
  PostScriptTrace('CRF2e.ps')
  p2 <- readPicture('CRF2e.ps.xml')
  PostScriptTrace('CRF3e.ps')
  p3 <- readPicture('CRF3e.ps.xml')
  PostScriptTrace('SpecE.ps')
  p4 <- readPicture('SpecE.ps.xml')
  PostScriptTrace('timecourseE.ps')
  p5 <- readPicture('timecourseE.ps.xml')
  PostScriptTrace('CRF1e2.ps')
  p6 <- readPicture('CRF1e2.ps.xml')
  PostScriptTrace('CRF2e2.ps')
  p7 <- readPicture('CRF2e2.ps.xml')
  PostScriptTrace('CRF3e2.ps')
  p8 <- readPicture('CRF3e2.ps.xml')
  
    for (n in 1:length(p4@paths)){
    temp <- class(p4@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(p4@paths[n]$path@rgb))<765){p4@paths[n]$path@rgb <- addalpha(p4@paths[n]$path@rgb,alpha=0.2)}}}

      for (n in 1:length(p5@paths)){
    temp <- class(p5@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(p5@paths[n]$path@rgb))<765){p5@paths[n]$path@rgb <- addalpha(p5@paths[n]$path@rgb,alpha=0.2)}}}

    
  h1 <- readTIFF('head1.tiff')
  h2 <- readTIFF('head2.tiff')
  
  pdf(paste0(figdir,"EEGdata.pdf"), bg="transparent", height = 15, width = 15)
  par(mar=c(0.1,0.1,0.1,0.1))
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(0,1), ylim=c(0,1))
  
  # insert the head plots first so the white border doesn't overlap the other graphs
    aspratio <- 1  # this is the aspect ratio of the output pdf
  imwidth <- 0.16
  xstart <- 0.65
  ystart <- 0.82
  rasterImage(h1,xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth) 
  xstart <- 0.82
  ystart <- 0.82
  rasterImage(h2,xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth)

  grid.picture(p5,x=0.25,y=0.8,width=0.5,height=1)
  grid.picture(p4,x=0.75,y=0.8,width=0.5,height=1)
  grid.picture(p1,x=0.17,y=0.5,width=0.32,height=1)
  grid.picture(p2,x=0.5,y=0.5,width=0.32,height=1)
  grid.picture(p3,x=0.83,y=0.5,width=0.32,height=1)
  grid.picture(p6,x=0.17,y=0.175,width=0.32,height=1)
  grid.picture(p7,x=0.5,y=0.175,width=0.32,height=1)
  grid.picture(p8,x=0.83,y=0.175,width=0.32,height=1)
  
    text(0.5,1,'Electroencephalography',cex=4)

  dev.off()
  
  file.remove(c('CRF1e.ps','CRF2e.ps','CRF3e.ps','CRF1e2.ps','CRF2e2.ps','CRF3e2.ps','SpecE.ps','timecourseE.ps','head1.tiff','head2.tiff'))
  file.remove(c('CRF1e.ps.xml','CRF2e.ps.xml','CRF3e.ps.xml','CRF1e2.ps.xml','CRF2e2.ps.xml','CRF3e2.ps.xml','SpecE.ps.xml','timecourseE.ps.xml'))

}

```

```{r include=FALSE, results='hide'}

# do statistics on the EEG data

alldata <- NULL
groupID <- NULL
allP <- NULL
counter <- 0
for (cont in 1:dim(allmeansP)[3]){
  for (p in 1:dim(allmeansP)[1]){
    counter <- counter + 1
    alldata[counter] <- mean(allmeansE[p,electrodeindices,3,cont])
    groupID[counter] <- cont
    allP[counter] <- p
  }
}
dichE2c <- anovacirc.test(alldata,group=groupID,participant=allP)
# groupID <- as.factor(groupID)
# participantID <- as.factor(participantID)
# adata <- data.frame(dichdata,groupID,participantID)
# dichE2c <- ezANOVA(data = adata, dv = dichdata, within=groupID, wid=participantID)


alldata <- NULL
allgroupA <- NULL
allgroupB <- NULL
allP <- NULL
counter <- 0
for (p in 1:30){
  for (lev in 1:5){
    for (cond in 1:2){
    counter <- counter + 1
    alldata[counter] <- mean(allmeansE[p,electrodeindices,cond,lev])
    allgroupA[counter] <- lev
    allgroupB[counter] <- cond
    allP[counter] <- p
    }
  }
}
monbinEstats <- anovacirc2way(alldata,allgroupA,allgroupB,allP)
# allgroupA <- as.factor(allgroupA)
# allgroupB <- as.factor(allgroupB)
# allP <- as.factor(allP)
# alldata <- abs(alldata)
# adata <- data.frame(alldata,allgroupA,allgroupB,allP)
# monbinEstats <- ezANOVA(data = adata, dv = alldata, within=c(allgroupA,allgroupB), wid=allP)


alldata <- NULL
allgroupA <- NULL
allgroupB <- NULL
allP <- NULL
counter <- 0
for (p in 1:30){
  for (lev in 1:5){
    counter <- counter + 1
    alldata[counter] <- mean(allmeansE[p,electrodeindices,1,lev])
    allgroupA[counter] <- lev
    allgroupB[counter] <- 1
    allP[counter] <- p

    counter <- counter + 1
    alldata[counter] <- mean(allmeansE[p,electrodeindices,3,lev])
    allgroupA[counter] <- lev
    allgroupB[counter] <- 2
    allP[counter] <- p
  }
}
mondichEstats <- anovacirc2way(alldata,allgroupA,allgroupB,allP)
# allgroupA <- as.factor(allgroupA)
# allgroupB <- as.factor(allgroupB)
# allP <- as.factor(allP)
# alldata <- abs(alldata)
# adata <- data.frame(alldata,allgroupA,allgroupB,allP)
# mondichEstats <- ezANOVA(data = adata, dv = alldata, within=c(allgroupA,allgroupB), wid=allP)


alldata <- NULL
allgroupA <- NULL
allgroupB <- NULL
allP <- NULL
counter <- 0
for (p in 1:30){
  for (lev in 1:5){
    counter <- counter + 1
    alldata[counter] <- mean(allmeansE[p,electrodeindices,1,lev])
    allgroupA[counter] <- lev
    allgroupB[counter] <- 1
    allP[counter] <- p

    counter <- counter + 1
    alldata[counter] <- mean(allmeansE[p,electrodeindices,5,lev])
    allgroupA[counter] <- lev
    allgroupB[counter] <- 2
    allP[counter] <- p
  }
}

monbinEstatsX <- anovacirc2way(alldata,allgroupA,allgroupB,allP)
# allgroupA <- as.factor(allgroupA)
# allgroupB <- as.factor(allgroupB)
# allP <- as.factor(allP)
# alldata <- abs(alldata)
# adata <- data.frame(alldata,allgroupA,allgroupB,allP)
# monbinEstatsX <- ezANOVA(data = adata, dv = alldata, within=c(allgroupA,allgroupB), wid=allP)

alldata <- NULL
allgroupA <- NULL
allgroupB <- NULL
allP <- NULL
counter <- 0
for (p in 1:30){
  for (lev in 1:5){
    counter <- counter + 1
    alldata[counter] <- mean(allmeansE[p,electrodeindices,1,lev])
    allgroupA[counter] <- lev
    allgroupB[counter] <- 1
    allP[counter] <- p

    counter <- counter + 1
    alldata[counter] <- mean(allmeansE[p,electrodeindices,6,lev])
    allgroupA[counter] <- lev
    allgroupB[counter] <- 2
    allP[counter] <- p
  }
}

mondichEstatsX <- anovacirc2way(alldata,allgroupA,allgroupB,allP)
# allgroupA <- as.factor(allgroupA)
# allgroupB <- as.factor(allgroupB)
# allP <- as.factor(allP)
# alldata <- abs(alldata)
# adata <- data.frame(alldata,allgroupA,allgroupB,allP)
# mondichEstatsX <- ezANOVA(data = adata, dv = alldata, within=c(allgroupA,allgroupB), wid=allP)

```

```{r EEGdata, fig.cap="Summary of EEG results for N=30 participants. Panel (a) shows a group average waveform for binocular presentation (low pass filtered at 5Hz), with the driving signal plotted at the foot. Panel (b) shows the average Fourier spectrum, and inset scalp distributions. Black dots on the scalp plots indicate electrodes Oz, POz, O1 and O2. Panels (c,d) show contrast response functions at 2Hz for different conditions. Panel (e) shows contrast response functions at 1.6Hz for three conditions. Panels (f-h) are in the same format but for the second harmonic responses. Shaded regions and error bars indicate bootstrapped standard errors.", fig.align="center", echo=FALSE}

knitr::include_graphics(paste0(figdir,'EEGdata.pdf'))

```

When stimuli in both eyes flicker at 2Hz, the binocular responses at the first (Figure \@ref(fig:EEGdata)c) and second (Figure \@ref(fig:EEGdata)f) harmonics are substantially greater than the monocular responses, particularly at high contrasts. Analysis of variance on the complex values ($ANOVA^2_{circ}$) revealed a main effect of contrast (F(`r monbinEstats$dfA`,`r monbinEstats$dfR`) = `r round(monbinEstats$FratioA,digits=2)`, $p$ < 0.001) and an interaction effect (F(`r monbinEstats$dfAB`,`r monbinEstats$dfR`) = `r round(monbinEstats$FratioAB,digits=2)`, $p$ < 0.001), but no effect of condition ($p$ = `r round(monbinEstats$pvalB,digits=2)`). For the cross-frequency conditions (Figure \@ref(fig:EEGdata)d,g), there was no appreciable effect of adding a 1.6Hz component on the response at 2Hz or 4Hz (no effect of condition, and no interaction). Similarly, there were no clear interocular interactions between frequencies in the responses at 1.6Hz (Figure \@ref(fig:EEGdata)e) and 3.2Hz (Figure \@ref(fig:EEGdata)h). This pattern of results suggests that processing of temporal luminance modulations happens in a more linear way in visual cortex (indexed by EEG), compared with subcortical pathways (indexed by pupillometry), and shows no evidence of interocular suppression.

```{r include=FALSE, results='hide'}

# generate plot showing the bin:mon ratio for three data sets

         if (!file.exists(paste0(datadir,'Averagedata.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '2qu6y'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name=='Averagedata.RData')
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
         }

load(file=paste0(datadir,'Averagedata.RData'))

contrastsdB <- 20*log10(c(6,12,24,48,96))
electrodeindices <- match(targetelectrodes,electrodes)-2

allPratios <- 20*log10(abs(allmeansP[,2,])/abs(allmeansP[,1,]))
allEratios <- 20*log10(abs(apply(allmeansE[,electrodeindices,2,],c(1,3),mean))/abs(apply(allmeansE[,electrodeindices,1,],c(1,3),mean)))
allE2ratios <- 20*log10(abs(apply(allmeansE2[,electrodeindices,2,],c(1,3),mean))/abs(apply(allmeansE2[,electrodeindices,1,],c(1,3),mean)))

allratios <- NULL
allconds <- NULL
allconts <- NULL
allparticipants <- NULL
counter <- 0
for (cont in 1:length(contrastsdB)){
  for (s in 1:nrow(allPratios)){
    counter <- counter + 1
    allratios[counter] <- allPratios[s,cont]
    allconds[counter] <- 1
    allparticipants[counter] <- s
    allconts[counter] <- cont
    
    counter <- counter + 1
    allratios[counter] <- allEratios[s,cont]
    allconds[counter] <- 2
    allparticipants[counter] <- s
    allconts[counter] <- cont
    
    counter <- counter + 1
    allratios[counter] <- allE2ratios[s,cont]
    allconds[counter] <- 3
    allparticipants[counter] <- s
    allconts[counter] <- cont
    
  }
}
allparticipants <- as.factor(allparticipants)
allconds <- as.factor(allconds)
allconts <- as.factor(allconts)
aovdata <- data.frame(allparticipants,allconds,allconts,allratios)
ratioaov <- ezANOVA(aovdata,dv=allratios,within=c(allconds,allconts),wid=allparticipants)
gg <- ratioaov$`Sphericity Corrections`$GGe

if (processdata > 0){

PratiosCI <- matrix(0,nrow=2,ncol=5)
EratiosCI <- matrix(0,nrow=2,ncol=5)
E2ratiosCI <- matrix(0,nrow=2,ncol=5)
for (level in 1:5){
    bspop <- NULL
    for (n in 1:nbootstraps){
      bspop[n] <- mean(sample(allPratios[,level],nrow(allPratios),replace=TRUE))
    }
    PratiosCI[,level] <- quantile(bspop,c((1-0.68)/2,1-((1-0.68)/2)))
     bspop <- NULL
    for (n in 1:nbootstraps){
      bspop[n] <- mean(sample(allEratios[,level],nrow(allEratios),replace=TRUE))
    }
    EratiosCI[,level] <- quantile(bspop,c((1-0.68)/2,1-((1-0.68)/2)))
    bspop <- NULL
    for (n in 1:nbootstraps){
      bspop[n] <- mean(sample(allE2ratios[,level],nrow(allE2ratios),replace=TRUE))
    }
    E2ratiosCI[,level] <- quantile(bspop,c((1-0.68)/2,1-((1-0.68)/2)))
}


plotlims <- c(15,40,-3,12)  
ticklocsx <- contrastsdB
ticklabelsx <-c(6,12,24,48,96) 
ticklocsy <- seq(-3,12,3)    # locations of tick marks on y axis
ticklabelsy <- c(expression(1/sqrt(2)),'1',expression(sqrt(2)),'2',expression(2*sqrt(2)),'4')

pdf("Figures/BSratios.pdf", onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Bin:Mon ratio", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

arrows(contrastsdB,colMeans(allPratios),contrastsdB,PratiosCI[1,],lwd=3,col=colpal[3],length=0.05,angle=90)
arrows(contrastsdB,colMeans(allPratios),contrastsdB,PratiosCI[2,],lwd=3,col=colpal[3],length=0.05,angle=90)
arrows(contrastsdB,colMeans(allEratios),contrastsdB,EratiosCI[1,],lwd=3,col=colpal[4],length=0.05,angle=90)
arrows(contrastsdB,colMeans(allEratios),contrastsdB,EratiosCI[2,],lwd=3,col=colpal[4],length=0.05,angle=90)
arrows(contrastsdB,colMeans(allE2ratios),contrastsdB,E2ratiosCI[1,],lwd=3,col=colpal[5],length=0.05,angle=90)
arrows(contrastsdB,colMeans(allE2ratios),contrastsdB,E2ratiosCI[2,],lwd=3,col=colpal[5],length=0.05,angle=90)
  
lines(contrastsdB,colMeans(allPratios), col=colpal[3], lwd=3, cex=0.5)
lines(contrastsdB,colMeans(allEratios), col=colpal[4], lwd=3, cex=0.5)
lines(contrastsdB,colMeans(allE2ratios), col=colpal[5], lwd=3, cex=0.5)

points(contrastsdB,colMeans(allPratios), pch = 21, col='black', bg=colpal[3], cex=1.6, lwd=3) 
points(contrastsdB,colMeans(allEratios), pch = 22, col='black', bg=colpal[4], cex=1.6, lwd=3)
points(contrastsdB,colMeans(allE2ratios), pch = 23, col='black', bg=colpal[5], cex=1.6, lwd=3)

legend(15,12,c('Pupillometry','EEG 1F', 'EEG 2F'), pch=21:23, pt.bg=colpal[3:5],box.lwd=2,pt.cex=1.6,pt.lwd=3)

dev.off()

}


```

Finally, we calculated the ratio of binocular to monocular responses across the three data types from Experiment 1. Figure \@ref(fig:BSratios) shows that these ratios are approximately $\sqrt2$ across the low-to-intermediate contrast range for all three data types. At higher contrasts, we see ratios of 2 or higher for the EEG data, but much weaker ratios near 1 for the pupillometry data. Note that the ratios here are calculated on a per-participant basis and then averaged, rather than being the ratios of the average values shown in Figures \@ref(fig:pupildata) and \@ref(fig:EEGdata). A $3 \times 5$ repeated measures ANOVA on the logarithmic (dB) ratios found a main effect of contrast (F(`r round(ratioaov$ANOVA$DFn[2]*gg[2],digits=2)`,`r round(ratioaov$ANOVA$DFd[2]*gg[2],digits=2)`) = `r round(ratioaov$ANOVA$F[2],digits=2)`, \emph{p} < `r round(ratioaov$ANOVA$p[2],digits=3)`), no effect of data modality (F(`r ratioaov$ANOVA$DFn[1]`,`r ratioaov$ANOVA$DFd[1]`) = `r round(ratioaov$ANOVA$F[1],digits=2)`, \emph{p} = `r round(ratioaov$ANOVA$p[1],digits=2)`), but a highly significant interaction (F(`r round(ratioaov$ANOVA$DFn[3]*gg[3],digits=2)`,`r round(ratioaov$ANOVA$DFd[3]*gg[3],digits=2)`) = `r round(ratioaov$ANOVA$F[3],digits=2)`, \emph{p} < `r round(ratioaov$ANOVA$p[3],digits=4)`).

```{r BSratios, fig.cap="Ratio of binocular to monocular response for three data types. Each ratio is the average of ratios for N=30 participants, and error bars indicate bootstrapped standard errors.", fig.align="center", out.width = '50%', echo=FALSE}

knitr::include_graphics(paste0(figdir,'BSratios.pdf'))

```

## Experiment 2

The strong binocular facilitation and weak interocular suppression in the EEG data from Experiment 1 was very different from previous findings on binocular combination using steady-state EEG with grating stimuli [@Baker2017]. One possible explanation is that the lower temporal frequency used here (2Hz, vs 5 or 7Hz in previous work) might be responsible for this difference. We therefore ran a second experiment to compare monocular and binocular responses at a range of temporal frequencies. Only EEG data were collected for this experiment, as the pupil response is negligible above around 2Hz [@Spitschan2014].

```{r include=FALSE, results='hide'}

# (download and) analyse the raw data from the temporal frequency experiment

if (processdata > 2){
  
  legaltriggers <- 1
  
  TFs <- c(2,4,8,16,30)
  EEGtimes <- seq(1/1000,10,1/1000)
  targetindices <- (TFs*10)+1
  
  for (participant in 1:12){
    print(participant)
    
# download and process data if this has not been done already for this participant
    if (!file.exists(paste0(datadir,'P',150+participant,'summary.RData'))){   
      
      # if there is no directory for this participant's data
      if (!file.exists(paste0(rawdir,'P',150+participant))){
        dir.create(paste0(rawdir,'P',150+participant))}
      
      d <- dir(paste0(rawdir,'P',150+participant))
      
      if (length(d)==0){
        
        # if the tar file of this participant's data doesn't exist
        if (!file.exists(paste0(rawdir,'P',150+participant,'.tar'))){
          # download it from OSF
          if (!exists('tffiles')){
            osfnode <- 'mvpyz'
            osfproject <- osf_retrieve_node(osfnode)
            tffiles <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(tffiles$name==paste0('P',150+participant,'.tar'))
          osf_download(tffiles[fid,],rawdir,progress=TRUE)
        }
        
        # then unzip the tar file
        untar(paste0(rawdir,'P',150+participant,'.tar'),exdir=paste0(rawdir,'P',150+participant))
        
        # and delete the tar file to save storage space
        file.remove(paste0(rawdir,'P',150+participant,'.tar'))
      }
      
      d <- dir(paste0(rawdir,'P',150+participant),full.names=TRUE)
      
      EEGtargets <- array(0,dim=c(5,64,20,5))
      EEGspectra <- array(0,dim=c(5,64,20,500))
      
      psychopyfiles <- dir(path=paste0(rawdir,'P',150+participant), pattern=paste0('P',150+participant,'_CRFstudy'), full.names = TRUE)
      
      EEGfiles <- dir(path=paste0(rawdir,'P',150+participant), pattern='*_EEG.gz', full.names = TRUE)
      
      for (block in 1:length(EEGfiles)){
        
        psychoutput <- read.csv(psychopyfiles[block])
        
        condorder <- psychoutput$condition
        
        EEGdata <- read.csv(EEGfiles[block])
        electrodes <- colnames(EEGdata)
        
        triggertimes <- NULL
        counter <- 0
        lasttrigger <- -10000
        for (n in 1:nrow(EEGdata)){
          if(EEGdata$Trigger[n] %in% legaltriggers){
            if(n>(lasttrigger+10000)){
              counter <- counter + 1
              triggertimes[counter] <- n
              lasttrigger <- n
            }}
        }
        
        for (cond in 1:counter){
          for (ch in 1:64){
            trial <- EEGdata[(triggertimes[cond]+(2001:12000)),ch+2]
            fspec <- (fft(trial)/length(trial))
            EEGtargets[block,ch,condorder[cond],] <- fspec[targetindices]
            EEGspectra[block,ch,condorder[cond],1:500] <- fspec[1:500]
          }}
      }
      
      electrodeindices <- match(targetelectrodes,electrodes)-2
      
      cleanmeansE <- array(0,dim=c(2,5))
      meanspec <- array(0,dim=c(2,5,500))
      
      for (eye in 1:2){
        for (cond in 1:5){
          includedconds <- c(cond,cond+5) + (10*(eye-1))
          temp <- as.vector(EEGtargets[,electrodeindices,includedconds,cond])
          temp <- temp[which(!is.na(temp))]
          temp <- temp[which(abs(temp)>0)]  
          cartdata <- data.frame(Re(temp),Im(temp))
          if (sum(cartdata)!=0){
            D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
            i <- which(D<SDthresh) 
            cleanmeansE[eye,cond] <- mean(temp[i])}   
          
          for (f in 2:500){
            temp <- as.vector(apply(EEGspectra[,electrodeindices,includedconds,f],c(1,3),mean))
            temp <- temp[which(!is.na(temp))]
            temp <- temp[which(abs(temp)>0)]  
            cartdata <- data.frame(Re(temp),Im(temp))
            if (sum(cartdata)!=0){
              D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
              i <- which(D<SDthresh) 
              meanspec[eye,cond,f] <- mean(temp[i])}   
          }
        }
      }
      
    }
    
    save(file=paste0(datadir,'P',150+participant,'summary.RData'),list=c('cleanmeansE','meanspec'))
    
  }
  
}


```

```{r include=FALSE, results='hide'}

# load in the processed data from the temporal frequency experiment and average

if (processdata > 1){
  
  allspec <- array(0,dim=c(12,2,5,500))
  allmeans <- array(0,dim=c(12,2,5))
  allratios <- matrix(0,nrow=12,ncol=5)
  
      for (participant in 1:12){
         # if the summary file of this participant's data doesn't exist
         if (!file.exists(paste0(datadir,'P',150+participant,'summary.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '2qu6y'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name==paste0('P',150+participant,'summary.RData'))
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
         }
      }
  
  for (participant in 1:12){
    
    load(paste0(datadir,'P',150+participant,'summary.RData'))
    
    allmeans[participant,,] <- cleanmeansE
    allspec[participant,,,] <- meanspec
    allratios[participant,] <- 20*log10(abs(allmeans[participant,2,])/abs(allmeans[participant,1,]))
  }
  
meanratios <- NULL
meanratiosCI <- matrix(0,nrow=2,ncol=5)
cleanmeansTF <- matrix(0,nrow=2,ncol=5)
cleanmeansTFCI <- array(0,dim=c(2,2,5))
meanspectraTF <- array(0,dim=c(2,5,500))
meanspectraTFCI <- array(0,dim=c(2,2,5,500))

for (cond in 1:2){
  for (level in 1:5){
    
    temp <- allmeans[,cond,level]
    cartdata <- data.frame(Re(temp),Im(temp))
    if (sum(cartdata)!=0){
      D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
      i <- which(D<SDthresh) 
    mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
    cleanmeansTF[cond,level] <- mbs$meanamp
    cleanmeansTFCI[1,cond,level] <- mbs$lowerCI
    cleanmeansTFCI[2,cond,level] <- mbs$upperCI
    }    
    
    meanratios[level] <- mean(allratios[,level])
    bspop <- NULL
    for (n in 1:nbootstraps){
      bspop[n] <- mean(sample(allratios[,level],nrow(allratios),replace=TRUE))
    }
    meanratiosCI[,level] <- quantile(bspop,c((1-0.68)/2,1-((1-0.68)/2)))
      
    for (f in 2:500){
  
        temp <- allspec[,cond,level,f]
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh) 
mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
meanspectraTF[cond,level,f] <- mbs$meanamp
meanspectraTFCI[1,cond,level,f] <- mbs$lowerCI
meanspectraTFCI[2,cond,level,f] <- mbs$upperCI
      }
    }
  }
}

save(file=paste0(datadir,'AveragedataTF.RData'),list=c('cleanmeansTF','cleanmeansTFCI','meanspectraTF','meanspectraTFCI','meanratios','meanratiosCI'))

}

```

```{r include=FALSE, results='hide'}

# generate figure showing the TF data

if (processdata > 0){
  
         if (!file.exists(paste0(datadir,'AveragedataTF.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '2qu6y'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name=='AveragedataTF.RData')
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
         }
  
  load(paste0(datadir,'AveragedataTF.RData'))
  
  TFs <- c(2,4,8,16,30)
  TFsdB <- 20*log10(TFs)
  
  postscript("SpecTF.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 8, width = 5.5)

frequencies <- (0:499)/10

plotlims <- c(0,36,0,5) 
ticklocsx <- seq(0,36,6)    # locations of tick marks on x axis
ticklocsy <- seq(0,5,1)    # locations of tick marks on y axis
ticklabelsx <- 2^(0:6)        # set labels for x ticks
ticklabelsy <- c(0,1,'','','','')    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
title(xlab="Frequency (Hz)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude (µV)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)


for (cond in 1:5){
  
lines(c(0,36),c(cond,cond)-1)  
polygon(20*log10(frequencies[c(11:490,490:11)]),(cond-1)+c(meanspectraTFCI[1,2,cond,11:490],meanspectraTFCI[2,2,cond,490:11]),col=colpal[cond],border=NA)

lines(20*log10(frequencies[11:490]),(cond-1)+abs(meanspectraTF[2,cond,11:490]), col=colpal[cond], lwd=2, cex=0.5) 
}

text(33,0.25,'2Hz',adj=0.5,cex=1.5,col=colpal[1])
text(33,1.25,'4Hz',adj=0.5,cex=1.5,col=colpal[2])
text(33,2.25,'8Hz',adj=0.5,cex=1.5,col=colpal[3])
text(33,3.25,'16Hz',adj=0.5,cex=1.5,col=colpal[4])
text(33,4.25,'30Hz',adj=0.5,cex=1.5,col=colpal[5])

text(1.5,4.8,'(a)',adj=0.5,cex=2.5)
text(18,4.8,'Binocular',adj=0.5,cex=2)

dev.off()
  
  
  
plotlims <- c(6,30,0,1)  
ticklocsx <- seq(6,30,6)    # locations of tick marks on x axis
ticklocsy <- seq(0,1,0.2)    # locations of tick marks on y axis
ticklabelsx <- 2^(1:5)        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

postscript("TF1.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Frequency (Hz)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude (µV)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

for (cond in 1:2){
  lines(TFsdB,abs(cleanmeansTF[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  arrows(TFsdB,abs(cleanmeansTF[cond,]),TFsdB,cleanmeansTFCI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  arrows(TFsdB,abs(cleanmeansTF[cond,]),TFsdB,cleanmeansTFCI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  points(TFsdB,abs(cleanmeansTF[cond,]), pch = 20+cond, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves
}  
legend(20,1,c('Monocular','Binocular'),pch=21:22,pt.bg=colpal[1:2],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(7.5,0.92,'(b)',adj=0.5,cex=2.5)

dev.off()
  

plotlims <- c(6,30,-3,12)  
ticklocsy <- seq(-3,12,3)    # locations of tick marks on y axis
ticklabelsy <- c(expression(1/sqrt(2)),'1',expression(sqrt(2)),'2',expression(2*sqrt(2)),'4')

postscript("TF2.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Frequency (Hz)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Bin:Mon ratio", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

  lines(TFsdB,meanratios, col=colpal[3], lwd=3, cex=0.5)
  arrows(TFsdB,meanratios,TFsdB,meanratiosCI[1,],lwd=3,col=colpal[3],length=0.05,angle=90)
  arrows(TFsdB,meanratios,TFsdB,meanratiosCI[2,],lwd=3,col=colpal[3],length=0.05,angle=90)
  points(TFsdB,meanratios, pch = 20+3, col='black', bg=colpal[3], cex=1.6, lwd=3)   
 text(7.5,11,'(c)',adj=0.5,cex=2.5)

dev.off()


  PostScriptTrace('SpecTF.ps')
  p1 <- readPicture('SpecTF.ps.xml')
  PostScriptTrace('TF1.ps')
  p2 <- readPicture('TF1.ps.xml')
  PostScriptTrace('TF2.ps')
  p3 <- readPicture('TF2.ps.xml')
  
    for (n in 1:length(p1@paths)){
    temp <- class(p1@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(p1@paths[n]$path@rgb))<765){p1@paths[n]$path@rgb <- addalpha(p1@paths[n]$path@rgb,alpha=0.2)}}}
  
  pdf(paste0(figdir,"TFdata.pdf"), bg="transparent", height = 12, width = 15)
  par(mar=c(0.1,0.1,0.1,0.1))
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(0,1), ylim=c(0,1))
  
  grid.picture(p1,x=0.3,y=0.5,width=0.6,height=1)
  grid.picture(p2,x=0.78,y=0.74,width=0.4,height=1)
  grid.picture(p3,x=0.78,y=0.26,width=0.4,height=1)

  dev.off()
  
  file.remove(c('TF1.ps','TF2.ps','SpecTF.ps','TF1.ps.xml','TF2.ps.xml','SpecTF.ps.xml'))


}

```

Results from the temporal frequency experiment are shown in figure \@ref(fig:TFdata). Figure \@ref(fig:TFdata)a shows the Fourier spectra for responses to binocular flicker at 5 different frequencies (2, 4, 8, 16, and 30 Hz). From 2 to 16 Hz, clear signals are observed at each fundamental frequency, and typically also their higher harmonics (integer multiples of the fundamental). However, at 30 Hz (upper row), the responses recorded were not demonstrably above the noise baseline. Figure \@ref(fig:TFdata)b compares the monocular and binocular responses at each stimulation frequency. Here we replicate the substantial summation effect across frequencies up to and including 16Hz (Fig. \@ref(fig:TFdata)c), demonstrating that strong binocular facilitation in the EEG data of Experiment 1 cannot be attributed to our use of 2Hz flicker.

```{r TFdata, fig.cap="Binocular facilitation at different temporal frequencies. Panel (a) shows Fourier spectra for responses to binocular flicker at 5 different frequencies (offset vertically for clarity). Panel (b) shows the response at each stimulation frequency for monocular (red circles) and binocular (blue squares) presentation. Panel (c) shows the ratio of binocular to monocular responses. Error bars and shaded regions indicate bootstrapped standard errors across N=12 participants.", fig.align="center", echo=FALSE}

knitr::include_graphics(paste0(figdir,'TFdata.pdf'))

```

## Experiment 3

In Experiment 1 we found evidence of much stronger binocular facilitation for cortical responses to luminance flicker (measured using EEG), compared with subcortical responses (measured using pupillometry). Since perception is dependent on cortical responses, these results provide a clear prediction for percieved contrast judgements indexed by psychophysical contrast matching paradigms [e.g. @Anstis1998; @Levelt1965; @Quaia2018]. We therefore conducted such an experiment, in which participants judged which of two stimuli had the greater perceived amplitude of flicker. One stimulus was a matching stimulus, that had a fixed binocular flicker amplitude of either 24\% or 48\% (temporal) contrast. The other stimulus was a target stimulus, the contrast of which was controlled by a staircase algorithm. We tested 9 ratios of contrast between the left and right eyes.

The results from the matching experiment are shown in Figure \@ref(fig:matchingdata). Each data point indicates the contrast levels required in each eye that were perceptually equivalent to the binocular 24\% (red circles) and 48\% (blue circles) matching contrasts. At both matching contrasts, we see a very substantial increase in the physical contrast required for a monocular target (data points along the x- and y-axes), compared to a binocular target (points along the diagonal of x=y). For example with a 48\% match, the monocular targets required contrasts close to 100\%, whereas binocular targets required a contrast of around 50\%. The data points between these extremes also fall close to the predictions of a linear summation model (diagonal dotted lines), and are inconsistent with a winner-takes-all (or MAX) model (dashed lines). Overall, these matching results are consistent with the approximately linear summation effects observed in the EEG data of Experiment 1 (Figure \@ref(fig:EEGdata)c,f).

```{r include=FALSE, results='hide'}

# (download and) analyse individual participant data for the matching experiment

ratiosL <- c(1, 1, 1, 1, 1, 0.75, 0.5, 0.25, 0)
ratiosR <- c(0, 0.25, 0.5, 0.75, 1, 1, 1, 1, 1)

if (processdata > 2){
  
if (!file.exists(paste0(datadir,'matchingdata.csv'))){
osfnode <- 'ey7rg'  
osfproject <- osf_retrieve_node(osfnode)
matchingfiles <- osf_ls_files(osfproject,n_max=300)
fid <- which(matchingfiles$name=='matchingdata.csv')
osf_download(matchingfiles[fid,],datadir,progress=TRUE)
}

matchingdata <- read.csv(paste0(datadir,'matchingdata.csv'))  

levels <- unique(matchingdata$allref)
subjects <- unique(matchingdata$Participant)

allthresh <- array(0,dim=c(length(subjects),length(levels),length(ratiosL)))
for (subj in 1:length(subjects)){
  thissubj <- subset(matchingdata,Participant==subj)  
  levels <- unique(thissubj$allref)
for (cond in 1:length(levels)){
  thiscond <- subset(thissubj,allref==levels[cond])
  contrast <- levels[cond]
  for (ll in 1:length(ratiosL)){
    Lratio <- ratiosL[ll]
    Rratio <- ratiosR[ll]
    thisL <- subset(thiscond, allLratio==Lratio)
    thisdata <- subset(thisL, allRratio==Rratio)
   
Ncorrect <- NULL
Ntrials <- NULL
Clevs <- sort(unique(thisdata$allcontrast))
for (lev in 1:length(Clevs)){
  temp <- subset(thisdata,allcontrast==Clevs[lev])
  Ncorrect[lev] <- sum(temp$correct)
  Ntrials[lev] <- nrow(temp)
}
CdB <- 20*log10(Clevs)
datatofit <- data.frame(CdB,Ncorrect,Ntrials)
fit <- quickpsy::quickpsy(datatofit, x=CdB, k=Ncorrect, n=Ntrials, guess=0, xmin=0, xmax=40, B = 0, fun=cum_normal_fun)
allthresh[subj,cond,ll] <- fit$thresholds$thre

# plot(datatofit$CdB,datatofit$Ncorrect/datatofit$Ntrials)
# points(datatofit$CdB,datatofit$Ncorrect/datatofit$Ntrials,pch=16)
# lines(fit$curves$x,fit$curves$y)

  }
}
}

allthresh[1,2,] <- NA   # exclude outliers
allthresh[2,2,2] <- NA  # exclude outliers
meanthresh <- apply(allthresh,2:3,mean,na.rm=TRUE)
SEthresh <- apply(allthresh,2:3,sd,na.rm=TRUE)/sqrt(apply(!is.na(allthresh),2:3,sum))

save(file=paste0(datadir,'meanmatching.RData'),list=c('meanthresh','SEthresh','allthresh'))

}

if (processdata > 0){
  
  
           if (!file.exists(paste0(datadir,'meanmatching.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '2qu6y'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name=='meanmatching.RData')
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
           }
  
load(paste0(datadir,'meanmatching.RData'))
  
pdf(paste0(figdir,"matchingdata.pdf"), bg="transparent", height = 5.5, width = 5.5)

plotlims <- c(0,125,0,125)  
ticklocs <- seq(0,125,25)   

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   
axis(1, at=ticklocs, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocs, tck=0.01, lab=F, lwd=2)
mtext(text = ticklocs, side = 1, at=ticklocs)     # add the tick labels
mtext(text = ticklocs, side = 2, at=ticklocs, line=0.2, las=1)
title(xlab="Right eye contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
title(ylab="Left eye contrast (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

lines(c(0,24),c(24,24),lty=2)
lines(c(0,48),c(48,48),lty=2)
lines(c(24,24),c(0,24),lty=2)
lines(c(48,48),c(0,48),lty=2)
lines(c(0,96),c(96,0),lty=3)
lines(c(0,48),c(48,0),lty=3)

for (matchlev in 1:2){
lines(ratiosR*10^(meanthresh[matchlev,]/20),ratiosL*10^(meanthresh[matchlev,]/20),pch=16,col=colpal[matchlev],lwd=3)}

# # these lines of code plot the individual participants' data for checking
# for (subj in 1:10){
# for (matchlev in 1:2){
#   lines(ratiosL*10^(allthresh[subj,matchlev,]/20),ratiosR*10^(allthresh[subj,matchlev,]/20),pch=16,col=colpal[matchlev],lwd=1)
# for (cond in 1:9){
#   points(ratiosL[cond]*10^(allthresh[subj,matchlev,cond]/20),ratiosR[cond]*10^(allthresh[subj,matchlev,cond]/20),pch=16,cex=1,col=colpal[matchlev])}}}


for (matchlev in 1:2){
for (cond in 1:9){
  points(ratiosR[cond]*10^(meanthresh[matchlev,cond]/20),ratiosL[cond]*10^(meanthresh[matchlev,cond]/20),pch=16,cex=2,col=colpal[matchlev])
  
  if ((SEthresh[matchlev,cond]+meanthresh[matchlev,cond])<42){
  arrows(ratiosR[cond]*10^(meanthresh[matchlev,cond]/20),ratiosL[cond]*10^(meanthresh[matchlev,cond]/20),ratiosR[cond]*10^((SEthresh[matchlev,cond]+meanthresh[matchlev,cond])/20),ratiosL[cond]*10^((SEthresh[matchlev,cond]+meanthresh[matchlev,cond])/20),length=0.015, angle=90, lwd=2)
  }
  
  # plot as an arrow if exceeding the axis limits
  if ((SEthresh[matchlev,cond]+meanthresh[matchlev,cond])>42){
  arrows(ratiosR[cond]*10^(meanthresh[matchlev,cond]/20),ratiosL[cond]*10^(meanthresh[matchlev,cond]/20),125,ratiosL[cond]*10^((SEthresh[matchlev,cond]+meanthresh[matchlev,cond])/20),length=0.035, angle=45, lwd=2)
  }
  
  arrows(ratiosR[cond]*10^(meanthresh[matchlev,cond]/20),ratiosL[cond]*10^(meanthresh[matchlev,cond]/20),ratiosR[cond]*10^((meanthresh[matchlev,cond]-SEthresh[matchlev,cond])/20),ratiosL[cond]*10^((meanthresh[matchlev,cond]-SEthresh[matchlev,cond])/20),length=0.015, angle=90, lwd=2)
}
}

legend(75,95,c('48% match','24% match'),pch=16,col=colpal[2:1],pt.cex=2,box.lwd=2)

legend(45.75,125,c('Winner-take-all','Linear summation'),lty=2:3,box.lwd=2)

dev.off()

}

```
  
```{r matchingdata, fig.cap="Contrast matching functions. Dotted and dashed lines are predictions of canonical summation models with a linear exponent (dotted) or an infinite exponent (dashed). Error bars indicate the standard error across participants (N=10), and are constrained along radial lines converging at the origin.", out.width = '50%', fig.align="center", echo=FALSE}

knitr::include_graphics(paste0(figdir,'matchingdata.pdf'))

```

## Computational modelling

We fitted a computational model to the data from Experiments 1 & 3 using a hierarchical Bayesian approach. The model behaviour is displayed in Figure \@ref(fig:modelfigure)e-h, with empirical data replotted in Figure \@ref(fig:modelfigure)a-d for comparison. In general, the model captures the key characteristics of the empirical data. Note that there are some minor discrepancies, which are a consequence of the hierarchical nature of the modelling. In brief, the model is fitted to the amplitudes for each participant, and group-level parameter estimates are derived based on these fits (see Table \@ref(tab:paramtable)). This procedure discards the phase information, whereas the empirical averages are coherently averaged across participants (retaining phase information). This explains the amplitude differences between model and data, particularly at low target contrast levels, but are of no consequence for the pattern of relative responses across conditions.

We were particularly interested in comparing the weight of interocular suppression across data sets. We therefore plot the posterior distributions for this parameter for all four data sets (see Figure \@ref(fig:modelfigure)i). The key finding is that the pupillometry results (green distribution) display a much greater weight of interocular suppression compared with the other data sets (grey, purple and yellow distributions). There is no overlap between the pupillometry distribution and any of the other three. All four distributions are also meaningfully below a weight of 1 -- the value that previous work using grating stimuli would predict [@Meese2006; @Baker2017]. These results offer an explanation of the empirical data: the strong interocular suppression for the pupillometry data is consistent with the weak binocular facilitation, and measurable dichoptic masking observed using that method. The weaker suppression for the other experiments is consistent with the near-linear binocular facilitation effects, and absence of dichoptic masking.

```{r include=FALSE, results='hide'}

# create text objects for Stan models

CRFmodelstring = "
  data {
    int<lower=1> Nsubj ;
    int<lower=1> Ntotal ;
    real y[Ntotal] ;
    real x[Ntotal] ;
    real<lower=0> w[Ntotal] ;
    int<lower=1> c[Ntotal] ;
    int<lower=1> s[Ntotal] ;
  }
  parameters {
    real<lower=1> Z[Nsubj] ;
    real<lower=0> Rmax[Nsubj] ;
    real<lower=0> wt[Nsubj] ;
    real<lower=0> k[Nsubj] ;
    real<lower=0> sigma ;
    real<lower=1> Zmu ; 
    real<lower=0> Rmaxmu ; 
    real<lower=0> wtmu ; 
    real<lower=0> kmu ; 
    real<lower=0> Zsigma ;
    real<lower=0> Rmaxsigma ;
    real<lower=0> wtsigma ;
    real<lower=0> ksigma ;
    real<lower=0> nu ;
  }
  model {
    Zmu ~ normal( 5 , 2 ) ;
    Rmaxmu ~ normal( 1 , 0.5 ) ;
    wtmu ~ normal( 1 , 0.5 ) ;
    kmu ~ normal( 5 , 2 ) ;
    sigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    Zsigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    Rmaxsigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    wtsigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    ksigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    nu ~ exponential(1/30.0) ;
    Z ~ normal( Zmu , Zsigma ) ; // vectorized
    Rmax ~ normal( Rmaxmu , Rmaxsigma ) ; // vectorized
    wt ~ normal( wtmu , wtsigma ) ; // vectorized
    k ~ normal( kmu , ksigma ) ; // vectorized
    for ( i in 1:Ntotal ) {
    
    if (c[i]==1)  // monocular condition
       y[i] ~ student_t( 
                nu ,
                k[s[i]] + (Rmax[s[i]]*(pow(x[i],2))/(Z[s[i]] + x[i])) ,
                w[i]*sigma ) ;
                
     else if (c[i]==2)  // binocular condition 
       y[i] ~ student_t( 
                nu ,
                k[s[i]] + (Rmax[s[i]]*((pow(x[i],2))/(Z[s[i]] + x[i] + wt[s[i]]*x[i]) + (pow(x[i],2))/(Z[s[i]] + x[i] + wt[s[i]]*x[i]))),
                w[i]*sigma ) ;   
                
     else if (c[i]==3)  // dichoptic condition
       y[i] ~ student_t( 
                nu ,
                k[s[i]] + (Rmax[s[i]]*((pow(x[i],2))/(Z[s[i]] + x[i] + wt[s[i]]*48) + (pow(48,2))/(Z[s[i]] + 48 + wt[s[i]]*x[i]))),
                w[i]*sigma ) ;  
                
                
     else if (c[i]==4)  // binocular cross condition 
       y[i] ~ student_t( 
                nu ,
                k[s[i]] + (Rmax[s[i]]*(pow(x[i],2))/(Z[s[i]] + x[i] + wt[s[i]]*x[i])) ,
                w[i]*sigma ) ;                  
                
                
     else if (c[i]==5)  // dichoptic cross condition
       y[i] ~ student_t( 
                nu ,
                k[s[i]] + (Rmax[s[i]]*(pow(x[i],2))/(Z[s[i]] + x[i] + wt[s[i]]*48)) ,
                w[i]*sigma ) ;       
    }
  }

  " # close quote for CRFmodelstring


matchingmodelstring = "
  data {
    int<lower=1> Nsubj ;
    int<lower=1> Ntotal ;
    int correct[Ntotal] ;
    real allcontrast[Ntotal] ;
    real allref[Ntotal] ;
    real allLratio[Ntotal] ;
    real allRratio[Ntotal] ;    
    int<lower=1> s[Ntotal] ;
  }
  parameters {
    real<lower=0> Z[Nsubj] ;
    real<lower=0> k[Nsubj] ;
    real<lower=0> w[Nsubj] ;
    real<lower=0> sigma ;
    real<lower=0> Zmu ; 
    real<lower=0> kmu ; 
    real<lower=0> wmu ;     
    real<lower=0> Zsigma ;
    real<lower=0> ksigma ;
    real<lower=0> wsigma ;
    }
  model {
    Zmu ~ normal( 5 , 2 ) ;
    wmu ~ normal( 1 , 0.5 ) ;
    kmu ~ normal( 5 , 2 ) ;
    sigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    Zsigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    ksigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    wsigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    Z ~ normal( Zmu , Zsigma ) ; // vectorized
    k ~ normal( kmu , ksigma ) ; // vectorized
    w ~ normal( wmu , wsigma ) ; // vectorized  

    for ( i in 1:Ntotal ) {
    
      real standresp ;
      real matchrespL ;
      real matchrespR ;
      real matchresp ;
    
      standresp = 2 * pow(allref[i],2) / (Z[s[i]] + allref[i] + w[s[i]]*allref[i]);
      matchrespL = pow(allLratio[i]*allcontrast[i],2) / (Z[s[i]] + allLratio[i]*allcontrast[i] + w[s[i]]*allRratio[i]*allcontrast[i]);
      matchrespR = pow(allRratio[i]*allcontrast[i],2) / (Z[s[i]] + allRratio[i]*allcontrast[i] + w[s[i]]*allLratio[i]*allcontrast[i]);
      matchresp = matchrespL + matchrespR;
      correct[i] ~ bernoulli(((1 + erf((matchresp - standresp)/k[s[i]]))/2)*0.998 + 0.001) ;
    }
  }  
  " # close quote for matchingmodelstring


```

```{r include=FALSE, results='hide'}

# do computational modelling

if (processdata > 1){

# settings for sampler 
numSavedSteps <- 100000    # total number of MCMC steps
adaptSteps <- 1000  # Number of steps to "tune" the samplers
burnInSteps <- 2000 
thinSteps <- 10
nChains <- 8
ncores <- detectCores()/2  # because of multi-threading, this is usually double the true number of physical cores, so we halve the number as Stan can only use physical cores
options(mc.cores=ncores)

if (!file.exists(paste0(datadir,'matchingdata.csv'))){
osfnode <- 'ey7rg'  
osfproject <- osf_retrieve_node(osfnode)
matchingfiles <- osf_ls_files(osfproject,n_max=300)
fid <- which(matchingfiles$name=='matchingdata.csv')
osf_download(matchingfiles[fid,],datadir,progress=TRUE)
}

matchingdata <- read.csv(paste0(datadir,'matchingdata.csv'))  

matchingdatalist = list(correct = matchingdata$correct, allLratio = matchingdata$allLratio, allRratio = matchingdata$allRratio, allcontrast = matchingdata$allcontrast, allref = matchingdata$allref, s = matchingdata$Participant, Nsubj = max(matchingdata$Participant), Ntotal = nrow(matchingdata))

for (participant in 1:30){
         # if the tar file of this participant's data doesn't exist
         if (!file.exists(paste0(datadir,'P',100+participant,'summary.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '2qu6y'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name==paste0('P',100+participant,'summary.RData'))
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
         }
}

d <- dir(datadir,pattern='*summary.RData',full.names=TRUE)

allmasksP <- array(0,dim=c(length(d),6,5))
allmeansP <- allmasksP
allmasksE <- array(0,dim=c(length(d),64,6,5))
allmeansE <- allmasksE
allmeansE2 <- allmeansE
allmasksE2 <- allmasksE

  for (s in 1:length(d)){
    
    load(d[s])
    
  allmasksP[s,,] <- cleanmasksP
  allmeansP[s,,] <- cleanmeansP
  allmeansE[s,,,] <- cleanmeansE
  allmasksE[s,,,] <- cleanmasksE
  allmeansE2[s,,,] <- cleanmeansE2
  allmasksE2[s,,,] <- cleanmasksE2
    
  }
  electrodeindices <- match(targetelectrodes,electrodes)-2

  # THE DATA
  condlist <- c(1,2,3,5,6)
  contlist <- c(6,12,24,48,96)
  y <- NULL
  x <- NULL
  c <- NULL
  s <- NULL
  w <- NULL
  i <- 0
  for (subj in 1:dim(allmeansP)[1]){
    for (cond in 1:length(condlist)){
      for (cont in 1:length(contlist)){
        dp <- abs(allmeansP[subj,condlist[cond],cont])
        if (is.na(dp)==0){
          if (is.infinite(dp)==0){
          i <- i + 1
          x[i] <- contlist[cont]
          y[i] <- dp
          c[i] <- cond
          s[i] <- subj
          w[i] <- 1
          }
        }
      }
    }
  }

pupildatalist = list(x = x, y = y, s = s, w = w, c = c, Nsubj = max(s), Ntotal = length(y))

  y <- NULL
  x <- NULL
  c <- NULL
  s <- NULL
  w <- NULL
  i <- 0
  for (subj in 1:dim(allmeansE)[1]){
    for (cond in 1:length(condlist)){
      for (cont in 1:length(contlist)){
        dp <- abs(mean(allmeansE[subj,electrodeindices,condlist[cond],cont]))
        if (is.na(dp)==0){
          if (is.infinite(dp)==0){
            i <- i + 1
            x[i] <- contlist[cont]
            y[i] <- dp
            c[i] <- cond
            s[i] <- subj
            w[i] <- 1
          }
        }
      }
    }
  }
  
  EEG1Fdatalist = list(x = x, y = y, s = s, w = w, c = c, Nsubj = max(s), Ntotal = length(y))
  
  y <- NULL
  x <- NULL
  c <- NULL
  s <- NULL
  w <- NULL
  i <- 0
  for (subj in 1:dim(allmeansE)[1]){
    for (cond in 1:length(condlist)){
      for (cont in 1:length(contlist)){
        dp <- abs(mean(allmeansE2[subj,electrodeindices,condlist[cond],cont]))
        if (is.na(dp)==0){
          if (is.infinite(dp)==0){
            i <- i + 1
            x[i] <- contlist[cont]
            y[i] <- dp
            c[i] <- cond
            s[i] <- subj
            w[i] <- 1
          }
        }
      }
    }
  }
  
  EEG2Fdatalist = list(x = x, y = y, s = s, w = w, c = c, Nsubj = max(s), Ntotal = length(y))
  
  
# Translate Stan models to C++ and compile to DSO:
matchingmodel <- stan_model(model_code=matchingmodelstring)  
CRFmodel <- stan_model(model_code=CRFmodelstring)  


# Get MC sample of posterior:
pupilsamples <- sampling(object=CRFmodel, 
                    data = pupildatalist, 
                    chains = nChains,
                    iter = (ceiling(numSavedSteps/nChains)*thinSteps+burnInSteps), 
                    warmup = burnInSteps, 
                    thin = thinSteps,
                    cores = getOption("mc.cores", 1L))

EEG1Fsamples <- sampling(object=CRFmodel, 
                    data = EEG1Fdatalist, 
                    chains = nChains,
                    iter = (ceiling(numSavedSteps/nChains)*thinSteps+burnInSteps), 
                    warmup = burnInSteps, 
                    thin = thinSteps,
                    cores = getOption("mc.cores", 1L))

EEG2Fsamples <- sampling(object=CRFmodel, 
                    data = EEG2Fdatalist, 
                    chains = nChains,
                    iter = (ceiling(numSavedSteps/nChains)*thinSteps+burnInSteps), 
                    warmup = burnInSteps, 
                    thin = thinSteps,
                    cores = getOption("mc.cores", 1L))

matchingsamples <- sampling(object=matchingmodel, 
                    data = matchingdatalist, 
                    chains = nChains,
                    iter = (ceiling(numSavedSteps/nChains)*thinSteps+burnInSteps), 
                    warmup = burnInSteps, 
                    thin = thinSteps,
                    cores = getOption("mc.cores", 1L))

save(file=paste0(datadir,'modeloutput.RData'),list=c('pupilsamples','EEG1Fsamples','EEG2Fsamples','matchingsamples'))

}


```

```{r include=FALSE, results='hide'}

# create figure containing modelling results

if (!file.exists(paste0(datadir,'modeloutput.RData'))){
osfnode <- '2qu6y'  
osfproject <- osf_retrieve_node(osfnode)
osffilesP <- osf_ls_files(osfproject,n_max=300)
fid <- which(osffilesP$name=='modeloutput.RData')
osf_download(osffilesP[fid,],datadir,progress=TRUE)
}

  load(paste0(datadir,'modeloutput.RData'))
  
  nchains <- dim(pupilsamples)[2]
  pupilweightpop <- NULL
  pupilZpop <- NULL
  pupilKpop <- NULL
  pupilRpop <- NULL
  for (n in 1:nchains){
  pupilweightpop <- c(pupilweightpop,pupilsamples@sim$samples[[n]]$wtmu)
  pupilZpop <- c(pupilZpop,pupilsamples@sim$samples[[n]]$Zmu)
  pupilKpop <- c(pupilKpop,pupilsamples@sim$samples[[n]]$kmu)
  pupilRpop <- c(pupilRpop,pupilsamples@sim$samples[[n]]$Rmaxmu)
  }
  pupilW <- median(pupilweightpop)
  pupilZ <- median(pupilZpop)
  pupilK <- median(pupilKpop)
  pupilRmax <- median(pupilRpop)
  
  
  nchains <- dim(EEG1Fsamples)[2]
  EEGweightpop <- NULL
  EEGZpop <- NULL
  EEGKpop <- NULL
  EEGRpop <- NULL
  for (n in 1:nchains){
  EEGweightpop <- c(EEGweightpop,EEG1Fsamples@sim$samples[[n]]$wtmu)
  EEGZpop <- c(EEGZpop,EEG1Fsamples@sim$samples[[n]]$Zmu)
  EEGKpop <- c(EEGKpop,EEG1Fsamples@sim$samples[[n]]$kmu)
  EEGRpop <- c(EEGRpop,EEG1Fsamples@sim$samples[[n]]$Rmaxmu)
  }
  EEGW <- median(EEGweightpop)
  EEGZ <- median(EEGZpop)
  EEGK <- median(EEGKpop)
  EEGRmax <- median(EEGRpop)
  
  nchains <- dim(EEG2Fsamples)[2]
  EEG2weightpop <- NULL
  EEG2Zpop <- NULL
  EEG2Kpop <- NULL
  EEG2Rpop <- NULL
  for (n in 1:nchains){
  EEG2weightpop <- c(EEG2weightpop,EEG2Fsamples@sim$samples[[n]]$wtmu)
  EEG2Zpop <- c(EEG2Zpop,EEG2Fsamples@sim$samples[[n]]$Zmu)
  EEG2Kpop <- c(EEG2Kpop,EEG2Fsamples@sim$samples[[n]]$kmu)
  EEG2Rpop <- c(EEG2Rpop,EEG2Fsamples@sim$samples[[n]]$Rmaxmu)
  }
  EEG2W <- median(EEG2weightpop)
  EEG2Z <- median(EEG2Zpop)
  EEG2K <- median(EEG2Kpop)
  EEG2Rmax <- median(EEG2Rpop)

  nchains <- dim(matchingsamples)[2]
  matchingweightpop <- NULL
  matchingZpop <- NULL
  matchingKpop <- NULL
  for (n in 1:nchains){
  matchingweightpop <- c(matchingweightpop,matchingsamples@sim$samples[[n]]$wmu)
  matchingZpop <- c(matchingZpop,matchingsamples@sim$samples[[n]]$Zmu)
  matchingKpop <- c(matchingKpop,matchingsamples@sim$samples[[n]]$kmu)
  }
  matchingW <- median(matchingweightpop)
  matchingZ <- median(matchingZpop)
  matchingK <- median(matchingKpop)


  if (processdata > 0){
    
postscript('posteriors.ps', horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

plotlims <- c(-48,12,0,0.6) 
ticklocsx <- seq(-48,12,12)    
ticklocsy <- seq(0,0.6,0.1)    
ticklabelsx <- c('1/256','1/64','1/16','1/4','1','4')        
ticklabelsy <- ticklocsy    # set labels for y ticks

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)    
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)   
 
title(xlab="w", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
title(ylab="Probability", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

a <- density(20*log10(pupilweightpop),from=-48,to=12)   
polygon(c(-48,a$x,12), c(0,a$y,0), col=colpal[3],border=NA) 

a <- density(20*log10(EEGweightpop),from=-48,to=12)   
polygon(c(-48,a$x,12), c(0,a$y,0), col=colpal[4],border=NA) 

a <- density(20*log10(EEG2weightpop),from=-48,to=12)   
polygon(c(-48,a$x,12), c(0,a$y,0), col=colpal[5],border=NA) 

a <- density(20*log10(matchingweightpop),from=-48,to=12)   
polygon(c(-48,a$x,12), c(0,a$y,0), col=colpal[6],border=NA) 

prior <- dnorm(10^((-48:12)/20),1,0.5)
prior <- 0.5*prior/max(prior)
lines(-48:12,prior)

lines(20*log10(c(mean(pupilW),mean(pupilW))),c(0,0.6),lwd=3,col=colpal[3])
lines(20*log10(c(mean(EEGW),mean(EEGW))),c(0,0.6),lwd=3,col=colpal[4])
lines(20*log10(c(mean(EEG2W),mean(EEG2W))),c(0,0.6),lwd=3,col=colpal[5])
lines(20*log10(c(mean(matchingW),mean(matchingW))),c(0,0.6),lwd=3,col=colpal[6])

legend(-48,0.6,c('Prior','Pupillometry','EEG 1F','EEG 2F','Matching'),col=c('black',colpal[3:6]),lwd=c(1,3,3,3,3),lty=1, box.lwd=2, bg='white')

text(9,0.58,'(i)',cex=1.25,adj=0.5)

dev.off()


finex <- 10^(seq(20*log10(6),20*log10(96),length=100)/20)

w <- pupilW
Z <- pupilZ
k <- pupilRmax
n <- pupilK
q <- 2
modelA <- matrix(0,nrow=6,ncol=length(finex))
modelB <- matrix(0,nrow=6,ncol=length(finex))
# mon condition
R <- 0
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[1,] <- k*(Lresp + Rresp) + n
modelB[1,] <- n

# bin condition
R <- finex
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[2,] <- k*(Lresp + Rresp) + n
modelB[2,] <- n

# dich condition
R <- 48
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[3,] <- k*(Lresp + Rresp) + n
modelB[3,] <- n

# mon X condition
R <- 0
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[4,] <- n
modelB[4,] <- k*(Lresp + Rresp) + n

# bin X condition
R <- finex
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[5,] <- k*(Lresp) + n 
modelB[5,] <- k*(Rresp) + n  

# dich X condition
L <- finex
R <- 48
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[6,] <- k*(Lresp) + n 
modelB[6,] <- k*(Rresp) + n  



contrastsdB <- 20*log10(c(6,12,24,48,96))

plotlims <- c(15,40,0,0.04)
ticklocsx <- contrastsdB    # locations of tick marks on x axis
ticklabelsx <-c(6,12,24,48,96)        # set labels for x ticks
ticklocsy <- seq(0,0.04,0.01)    # locations of tick marks on y axis
ticklabelsy <- ticklocsy    # set labels for y ticks

postscript(paste("CRF1p.ps",sep=''), horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)    
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)    
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
title(ylab="Amplitude at 2Hz (mm)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

condlist <- c(1,2,3,6)
for (cond in 1:4){lines(20*log10(finex),modelA[condlist[cond],], col=colpal[condlist[cond]], lwd=3, cex=0.5)}

legend(21,0.04,c('Monocular','Binocular','Dichoptic','Dichoptic cross'),lwd=3,col=colpal[condlist],box.lwd=2)

text(17,0.038,'(e)',adj=0.5,cex=2.5)

dev.off()  


w <- EEGW
Z <- EEGZ
k <- EEGRmax
n <- EEGK
q <- 2
modelA <- matrix(0,nrow=6,ncol=length(finex))
modelB <- matrix(0,nrow=6,ncol=length(finex))
# mon condition
R <- 0
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[1,] <- k*(Lresp + Rresp) + n
modelB[1,] <- n

# bin condition
R <- finex
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[2,] <- k*(Lresp + Rresp) + n
modelB[2,] <- n

# dich condition
R <- 48
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[3,] <- k*(Lresp + Rresp) + n
modelB[3,] <- n

# mon X condition
R <- 0
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[4,] <- n
modelB[4,] <- k*(Lresp + Rresp) + n

# bin X condition
R <- finex
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[5,] <- k*(Lresp) + n 
modelB[5,] <- k*(Rresp) + n  

# dich X condition
L <- finex
R <- 48
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[6,] <- k*(Lresp) + n 
modelB[6,] <- k*(Rresp) + n  

plotlims <- c(15,40,0,0.8)  
ticklocsy <- seq(0,0.8,0.2)    # locations of tick marks on y axis
ticklabelsy <- ticklocsy    # set labels for y ticks

postscript("CRF1e.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)    
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)    
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
title(ylab="Amplitude at 2Hz (µV) ", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

condlist <- c(1,2,3,6)
for (cond in 1:4){lines(20*log10(finex),modelA[condlist[cond],], col=colpal[condlist[cond]], lwd=3, cex=0.5)}

# legend(21,0.8,c('Monocular','Binocular','Dichoptic','Dichoptic cross'),lwd=3,col=colpal[condlist],box.lwd=2)

text(17,0.75,'(f)',adj=0.5,cex=2.5)

dev.off()


w <- EEG2W
Z <- EEG2Z
k <- EEG2Rmax
n <- EEG2K
q <- 2
modelA <- matrix(0,nrow=6,ncol=length(finex))
modelB <- matrix(0,nrow=6,ncol=length(finex))
# mon condition
R <- 0
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[1,] <- k*(Lresp + Rresp) + n
modelB[1,] <- n

# bin condition
R <- finex
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[2,] <- k*(Lresp + Rresp) + n
modelB[2,] <- n

# dich condition
R <- 48
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[3,] <- k*(Lresp + Rresp) + n
modelB[3,] <- n

# mon X condition
R <- 0
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[4,] <- n
modelB[4,] <- k*(Lresp + Rresp) + n

# bin X condition
R <- finex
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[5,] <- k*(Lresp) + n 
modelB[5,] <- k*(Rresp) + n  

# dich X condition
L <- finex
R <- 48
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[6,] <- k*(Lresp) + n 
modelB[6,] <- k*(Rresp) + n  

plotlims <- c(15,40,0,0.8)  
ticklocsy <- seq(0,0.8,0.2)    # locations of tick marks on y axis
ticklabelsy <- ticklocsy    # set labels for y ticks

postscript("CRF2e.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)    
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)    
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude at 4Hz (µV) ", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

condlist <- c(1,2,3,6)
for (cond in 1:4){lines(20*log10(finex),modelA[condlist[cond],], col=colpal[condlist[cond]], lwd=3, cex=0.5)}

# legend(21,0.8,c('Monocular','Binocular','Dichoptic','Dichoptic cross'),lwd=3,col=colpal[condlist],box.lwd=2)

text(17,0.75,'(g)',adj=0.5,cex=2.5)

dev.off()



# very finely sampled ratios to produce smooth curves
ratiosL <- seq(0,1,length=100)
ratiosR <- rep(1,100)

params <- c(2,matchingZ,matchingW)

binmodel <- function(L,R,p){
  # this is the two-stage model with a linear denominator and saturation constant
  stage1L <- (L^p[1])/(p[2] + L + p[3]*R)
  stage1R <- (R^p[1])/(p[2] + R + p[3]*L)
  resp <- stage1L + stage1R

  return(resp)}

getmatch <- function(L,R,ratios,p){
  standardresp <- binmodel(L,R,p)
  contrast <- 0
  matchresp <- 0
  while (matchresp<standardresp){
    contrast <- contrast + 0.1
    matchresp <- binmodel(contrast*ratios[1],contrast*ratios[2],p)
  }
  
  return(contrast)}

postscript("matchingmodel.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

plotlims <- c(0,125,0,125)  
ticklocs <- seq(0,125,25)   

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   
axis(1, at=ticklocs, tck=0.01, lab=F, lwd=2)
axis(2, at=ticklocs, tck=0.01, lab=F, lwd=2)
mtext(text = ticklocs, side = 1, at=ticklocs)     # add the tick labels
mtext(text = ticklocs, side = 2, at=ticklocs, line=0.2, las=1)
title(xlab="Right eye contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
title(ylab="Left eye contrast (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

standardcontrast <- 48

matchlist <- NULL
for (n in 1:length(ratiosL)){
  matchlist[n] <- getmatch(standardcontrast,standardcontrast,c(ratiosL[n],ratiosR[n]),params)
}

tempx <- c(matchlist*ratiosL, matchlist[100:1])
tempy <- c(matchlist, matchlist[100:1]*ratiosL[100:1])

lines(tempx,tempy,lwd=3,col=colpal[2])
lines(c(0,standardcontrast),c(standardcontrast,standardcontrast),lty=2)
lines(c(standardcontrast,standardcontrast),c(0,standardcontrast),lty=2)
lines(c(0,2*standardcontrast),c(2*standardcontrast,0),lty=3)

standardcontrast <- 24

matchlist <- NULL
for (n in 1:length(ratiosL)){
  matchlist[n] <- getmatch(standardcontrast,standardcontrast,c(ratiosL[n],ratiosR[n]),params)
}

tempx <- c(matchlist*ratiosL, matchlist[100:1])
tempy <- c(matchlist, matchlist[100:1]*ratiosL[100:1])
lines(tempx,tempy,lwd=3,col=colpal[1])

lines(c(0,standardcontrast),c(standardcontrast,standardcontrast),lty=2)
lines(c(standardcontrast,standardcontrast),c(0,standardcontrast),lty=2)
lines(c(0,2*standardcontrast),c(2*standardcontrast,0),lty=3)

legend(62,95,c('48% match','24% match'),col=colpal[2:1],lwd=3,pt.cex=2,box.lwd=2)

legend(45,125,c('Winner-take-all','Linear summation'),lty=2:3,box.lwd=2)

text(10,117.5,'(h)',adj=0.5,cex=2.5)

dev.off()


contrastsdB <- 20*log10(c(6,12,24,48,96))

         if (!file.exists(paste0(datadir,'Averagedata.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '2qu6y'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name=='Averagedata.RData')
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
         }

load(file=paste0(datadir,'Averagedata.RData'))
 

plotlims <- c(15,40,0,0.03) 
ticklocsx <- contrastsdB    # locations of tick marks on x axis
ticklocsy <- seq(0,0.03,0.01)    # locations of tick marks on y axis
ticklabelsx <-c(6,12,24,48,96)        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

postscript("pdata.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude at 2Hz (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansP[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  points(contrastsdB,abs(cleanmeansP[cond,]), pch = 20+cond, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves
}  
cond <- 6
  lines(contrastsdB,abs(cleanmeansP[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  points(contrastsdB,abs(cleanmeansP[cond,]), pch = 25, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves

legend(21,0.03,c('Monocular','Binocular','Dichoptic','Dichoptic cross'),pch=c(21:23,25),pt.bg=colpal[c(1:3,6)],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.028,'(a)',adj=0.5,cex=2.5)

dev.off()


plotlims <- c(15,40,0,0.8)  
ticklocsx <- contrastsdB    # locations of tick marks on x axis
ticklocsy <- seq(0,0.8,0.2)    # locations of tick marks on y axis
ticklabelsx <-c(6,12,24,48,96)        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

postscript("edata.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude (µV) at 2Hz", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansEav[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  points(contrastsdB,abs(cleanmeansEav[cond,]), pch = 20+cond, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves
}  
cond <- 6
  lines(contrastsdB,abs(cleanmeansEav[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  points(contrastsdB,abs(cleanmeansEav[cond,]), pch = 25, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves

# legend(22,0.8,c('Monocular','Binocular','Dichoptic','Dichoptic cross'),pch=c(21:23,25),pt.bg=colpal[c(1:3,6)],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.75,'(b)',adj=0.5,cex=2.5)

dev.off()

postscript("edata2.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude (µV) at 4Hz", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansE2av[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  points(contrastsdB,abs(cleanmeansE2av[cond,]), pch = 20+cond, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves
}  
cond <- 6
  lines(contrastsdB,abs(cleanmeansE2av[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  points(contrastsdB,abs(cleanmeansE2av[cond,]), pch = 25, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves

# legend(22,0.8,c('Monocular','Binocular','Dichoptic','Dichoptic cross'),pch=c(21:23,25),pt.bg=colpal[c(1:3,6)],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.75,'(c)',adj=0.5,cex=2.5)

dev.off()

         if (!file.exists(paste0(datadir,'meanmatching.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '2qu6y'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name=='meanmatching.RData')
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
         }

load(paste0(datadir,'meanmatching.RData'))
  
postscript("matchingdata.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

plotlims <- c(0,125,0,125)  
ticklocs <- seq(0,125,25)   
ratiosL <- c(1, 1, 1, 1, 1, 0.75, 0.5, 0.25, 0)
ratiosR <- c(0, 0.25, 0.5, 0.75, 1, 1, 1, 1, 1)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   
axis(1, at=ticklocs, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocs, tck=0.01, lab=F, lwd=2)
mtext(text = ticklocs, side = 1, at=ticklocs)     # add the tick labels
mtext(text = ticklocs, side = 2, at=ticklocs, line=0.2, las=1)
title(xlab="Right eye contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
title(ylab="Left eye contrast (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

lines(c(0,24),c(24,24),lty=2)
lines(c(0,48),c(48,48),lty=2)
lines(c(24,24),c(0,24),lty=2)
lines(c(48,48),c(0,48),lty=2)
lines(c(0,96),c(96,0),lty=3)
lines(c(0,48),c(48,0),lty=3)

for (matchlev in 1:2){
lines(ratiosR*10^(meanthresh[matchlev,]/20),ratiosL*10^(meanthresh[matchlev,]/20),pch=16,col=colpal[matchlev],lwd=3)}

for (matchlev in 1:2){
for (cond in 1:9){
  points(ratiosR[cond]*10^(meanthresh[matchlev,cond]/20),ratiosL[cond]*10^(meanthresh[matchlev,cond]/20),pch=16,cex=2,col=colpal[matchlev])
  
  # if ((SEthresh[matchlev,cond]+meanthresh[matchlev,cond])<42){
  # arrows(ratiosR[cond]*10^(meanthresh[matchlev,cond]/20),ratiosL[cond]*10^(meanthresh[matchlev,cond]/20),ratiosR[cond]*10^((SEthresh[matchlev,cond]+meanthresh[matchlev,cond])/20),ratiosL[cond]*10^((SEthresh[matchlev,cond]+meanthresh[matchlev,cond])/20),length=0.015, angle=90, lwd=2)
  # }
  # 
  # # plot as an arrow if exceeding the axis limits
  # if ((SEthresh[matchlev,cond]+meanthresh[matchlev,cond])>42){
  # arrows(ratiosR[cond]*10^(meanthresh[matchlev,cond]/20),ratiosL[cond]*10^(meanthresh[matchlev,cond]/20),125,ratiosL[cond]*10^((SEthresh[matchlev,cond]+meanthresh[matchlev,cond])/20),length=0.035, angle=45, lwd=2)
  # }
  
  # arrows(ratiosR[cond]*10^(meanthresh[matchlev,cond]/20),ratiosL[cond]*10^(meanthresh[matchlev,cond]/20),ratiosR[cond]*10^((meanthresh[matchlev,cond]-SEthresh[matchlev,cond])/20),ratiosL[cond]*10^((meanthresh[matchlev,cond]-SEthresh[matchlev,cond])/20),length=0.015, angle=90, lwd=2)
}
}

text(10,117.5,'(d)',adj=0.5,cex=2.5)

legend(75,95,c('48% match','24% match'),pch=16,col=colpal[2:1],pt.cex=2,box.lwd=2)

legend(45.75,125,c('Winner-take-all','Linear summation'),lty=2:3,box.lwd=2)

dev.off()

  PostScriptTrace('CRF1p.ps')
  p1 <- readPicture('CRF1p.ps.xml')
  PostScriptTrace('CRF1e.ps')
  p2 <- readPicture('CRF1e.ps.xml')
  PostScriptTrace('CRF2e.ps')
  p3 <- readPicture('CRF2e.ps.xml')
  PostScriptTrace('matchingmodel.ps')
  p4 <- readPicture('matchingmodel.ps.xml')
  PostScriptTrace('posteriors.ps')
  p5 <- readPicture('posteriors.ps.xml')
  
  PostScriptTrace('pdata.ps')
  p6 <- readPicture('pdata.ps.xml')
  PostScriptTrace('edata.ps')
  p7 <- readPicture('edata.ps.xml')
  PostScriptTrace('edata2.ps')
  p8 <- readPicture('edata2.ps.xml')
  PostScriptTrace('matchingdata.ps')
  p9 <- readPicture('matchingdata.ps.xml')  
  
    for (n in 1:length(p5@paths)){
    temp <- class(p5@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(p5@paths[n]$path@rgb))<765){p5@paths[n]$path@rgb <- addalpha(p5@paths[n]$path@rgb,alpha=0.2)}}}

  
  pdf(paste0(figdir,"modelfigure.pdf"), bg="transparent", height = 10, width = 30)
  par(mar=c(0.1,0.1,0.1,0.1))
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(0,1), ylim=c(0,1))
  

  grid.picture(p1,x=1/12,y=0.25,width=1/6,height=1)
  grid.picture(p2,x=3/12,y=0.25,width=1/6,height=1)
  grid.picture(p3,x=5/12,y=0.25,width=1/6,height=1)
  grid.picture(p4,x=7/12,y=0.25,width=1/6,height=1)

  grid.picture(p5,x=5/6,y=0.5,width=1/3,height=1)

  grid.picture(p6,x=1/12,y=0.75,width=1/6,height=1)
  grid.picture(p7,x=3/12,y=0.75,width=1/6,height=1)
  grid.picture(p8,x=5/12,y=0.75,width=1/6,height=1)
  grid.picture(p9,x=7/12,y=0.75,width=1/6,height=1)
  
    
  dev.off()
  
  file.remove(c('CRF1e.ps','CRF2e.ps','CRF1p.ps','matchingmodel.ps','matchingdata.ps','pdata.ps','edata.ps','edata2.ps','posteriors.ps'))
  file.remove(c('CRF1e.ps.xml','CRF2e.ps.xml','CRF1p.ps.xml','matchingmodel.ps.xml','matchingdata.ps.xml','pdata.ps.xml','edata.ps.xml','edata2.ps.xml','posteriors.ps.xml'))

}

```

```{r modelfigure, fig.cap="Summary of computational modelling. Panels (a-d) show empirical data from key conditions, replotted from earlier figures for the pupillometry (a), first harmonic EEG responses (b), second harmonic EEG responses (c) and contrast matching (d) experiments. Panels (e-h) show model behaviour for the same conditions, generated using the median group-level parameter values.  Panel (i) shows the posterior probability distributions of the interocular suppression parameter for each of the four model fits. The pupillometry distribution (green) is centred about a substantially higher suppressive weight than for the other data types (note the logarithmic x-axis). The black curve shows the (scaled) prior distribution for the weight parameter.", fig.align="center", echo=FALSE}

knitr::include_graphics(paste0(figdir,'modelfigure.pdf'))

```

```{r paramtable, echo=FALSE}

exptnames <- c('Pupillometry','EEG 1F', 'EEG 2F', 'Matching')
zlist <- c(pupilZ,EEGZ,EEG2Z,matchingZ)
klist <- c(pupilK,EEGK,EEG2K,matchingK)
wlist <- c(pupilW,EEGW,EEG2W,matchingW)
Rlist <- c(round(c(pupilRmax,EEGRmax,EEG2Rmax),5),'-')
tabledata <- data.frame(exptnames,round(zlist,digits=2),round(klist,digits=2),round(wlist,digits=2),Rlist)

colnames(tabledata) <- c('Data set','Z','k','w','Rmax')
kable(tabledata, align='lcccc',caption = 'Summary of median parameter values.') 

```


# Discussion

Using a novel paradigm that combines elctrophysiological and pupillometic measures, we found surprising results for binocular combination of flickering light: in the visual cortex, the processing of temporal luminance modulations seems to happen linearly, with no evidence of interocular suppression, while, in the subcortical pathways, this seems to happen non-linearly with evidence of interocular suppression. This pattern of results was also supported by the computational model that we fitted our data to, which showed a much greater suppression weight of the pupillometry data compared with the EEG data. Additionally, we also found that perception of flickering light is consistent with cortical responses, with our matching results also showing linear summation effects.

The results from our first experiment were unexpected for both the pupillometry and the EEG. Previous studies investigating binocular combination of grating stimuli using steady-state EEG showed that combination for this type of stimuli seems to happen in a non-linear way [@Baker2017]. However, we found that there seems to be a strong binocular facilitation for flickering stimuli. While this could have been due to the lower frequency used in our experiment, our second experiment showed that this was not the case. A reason for this apparent facilitation could be due to the different nature of our stimuli: @Baker2017 used static gratings, while here we used flickering stimuli. @Quaia2018 observed a strong binocular facilitation in eye movement response to moving stimuli. Here, obviously, we were not investigating eye movements, but our stimuli included a movement component due to their flickering nature. This induced movement of the stimuli could be the reason why we observed this strong facilitation in the visual cortex. As for our pupillometry results, we observed less binocular facilitation than what we hypothesised at beginning of testing. As mentioned in the introduction, the presence of a consensual response in the pupils [@Wyatt1981] is evidence of binocular interaction. @Wyatt1981 measured an inequality of the responses between the two eyes during this consensual response, which could actually be explained by the presence of interocular suppression between the two pupils. 

On the other hand, the results of our matching experiment were not completely unexpected. Previous literature has used the matching paradigm to investigate the binocular fusion of static stimuli for spatial increments, which consists of a bright target on a dark background, and spatial decrements, which consist of a dark target on a bright background [@Anstis1998; @Levelt1965]. For the former, it was found that binocular fusion seems to follow approximately linear combination rules, while, for the latter, it was found that binocular fusion seems to follow a winner-take-all pattern, where the observer is seeing what the eye that is receiving the strongest signal is seeing. Our flickering stimuli were a combination of both increments and decrements presented on a dark background, but presented a stronger similarity in presentation to the increments than the decrements. This would explain why our results showed a strong facilitation.

As mentioned before, the main frequency for the three experiments was 2 Hz. The reason behind this was that we wanted to be able to measure both EEG and pupillary responses simultaneously. However, these two methods have different temporal properties: pupillometry is most responsive to slow flicker frequencies of less than 1 Hz [@Spitschan2014], while steady-state EEG generates stronger responses to faster frequencies of more than 3 Hz [@Norcia2015]. This means that stronger responses for pupillometry should be obtained at a lower frequency than the one we used in the main experiment, and for EEG at a higher frequency, meaning that our interpretation of the results might have been limited by the frequency that we selected. However, previous studies have shown that significant pupil responses can be obtained at higher frequencies, with the pupils showing a similar pattern of responses as at 1 Hz or lower, although at a reduced amplitude [@Barrionuevo2014; @Barrionuevo2016]. Additionally, our second experiment shows that the strong binocular facilitation observed in the cortical areas for flickering stimuli at 2 Hz is also observable at higher frequencies. Therefore, this would seem to indicate that 2 Hz was a good compromise to obtain significant responses from both pupillometry and EEG.

# Conclusions

With these three experiments, we have demonstrated that binocular combination for temporal flickering stimuli seems to happen in different manners in cortical and subcortical pathways.

# References
