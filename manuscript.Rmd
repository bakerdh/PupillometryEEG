---
title: "Different rules for binocular combination of luminance in cortical and subcortical pathways"
author: "Federico G. Segala, Aurelio Bruno, Alex R. Wade &  Daniel H. Baker (+Myat? +Joel?)"
date: "`r Sys.Date()`"
output:
  pdf_document:
    toc: no
  word_document: default
  bookdown::pdf_document2:
    fig_caption: yes
    toc: no
    keep_tex: yes
  html_document: default
bibliography: references.bib
csl: elife.csl
---

```{r setup, include=FALSE}

processdata <- 0  # this flag determines the amount of processing, with 4 levels:
# 0 - do no processing, generate the pdf using existing versions of all figures
# 1 - generate figures using the processed group data
# 2 - average data across participants, do bootstrapping and modelling
# 3 - download all raw data and analyse (requires 48GB of storage)

# check which packages are installed, install the missing ones, and activate
packagelist <- c('knitr','remotes','tictoc','R.matlab','bookdown','grImport','tiff','pals','ez','gtools','signal','boot','quickpsy','rstan','coda','parallel') # list of CRAN packages
missingpackages <- packagelist[!packagelist %in% installed.packages()[,1]]
if (length(missingpackages)>0){install.packages(missingpackages)}
if (!'osfr' %in% installed.packages()[,1]){remotes::install_github("centerforopenscience/osfr")}
if (!'FourierStats' %in% installed.packages()[,1]){remotes::install_github("bakerdh/FourierStats")}
packagelist <- c(packagelist,'osfr','FourierStats')
toinstall <- packagelist[which(!packagelist %in% (.packages()))]
invisible(lapply(toinstall,library,character.only=TRUE))

knitr::opts_chunk$set(echo = TRUE)

# helper function to make colours transparent
addalpha <- function(col, alpha=1){apply(sapply(col, col2rgb)/255, 2, function(x) rgb(x[1], x[2], x[3], alpha=alpha))}

v4Interp <- function(df, xo, yo, rmax = .75, gridRes = 67) {
  ## Create a function to perform Matlab's v4 interpolation.
  ## Takes as input a data-frame with columns x, y, and z (x co-ordinates, y co-ordinates, and amplitude)
  ## and variables xo and yo, the co-ordinates which will be use to create a grid for interpolation
  xo <- matrix(rep(xo,length(yo)),nrow = length(xo),ncol = length(yo))
  yo <- t(matrix(rep(yo,length(xo)),nrow = length(yo),ncol = length(xo)))
  xy <- df$x + df$y*sqrt(as.complex(-1))
  d <- matrix(rep(xy,length(xy)),nrow = length(xy), ncol = length(xy))
  d <- abs(d - t(d))
  diag(d) <- 1
  g <- (d^2) * (log(d)-1)   # Green's function.
  diag(g) <- 0
  weights <- qr.solve(g,df$z)
  xy <- t(xy)
  outmat <- matrix(nrow = gridRes,ncol = gridRes)
  for (i in 1:gridRes){
    for (j in 1:gridRes) {
      test4 <- abs((xo[i,j] + sqrt(as.complex(-1))*yo[i,j]) - xy)
      g <- (test4^2) * (log(test4)-1)
      outmat[i,j] <- g %*% weights}}
  outDf <- data.frame(x = xo[,1],outmat)
  names(outDf)[1:length(yo[1,])+1] <- yo[1,]
  return(outDf)}

colpal <- c('#FE5000','#8783CF','#228B22','#808080','#6d008b','#8B8000')
targetelectrodes <- c('Oz','POz','O1','O2')

localdir <- 'local/'    # all files are stored in the project directory /local/ which git is told to ignore
if (!file.exists(localdir)){dir.create(localdir)}   # create a local directory to store data and outputs
rawdir <- 'local/rawdata/'
if (!file.exists(rawdir)){dir.create(rawdir)}   # create a local directory to store raw data
figdir <- 'Figures/'
if (!file.exists(figdir)){dir.create(figdir)}   # create a local directory to store figures
datadir <- 'local/processeddata/'
if (!file.exists(datadir)){dir.create(datadir)}   # create a local directory to store processed data

# cut off for data inclusion (Mahalanobis distance for complex data)
SDthresh <- 3
nbootstraps <- 1000

```

# Abstract


# Introduction
BinocularBinocular combination provides a higher visual sensitivity than monocular viewing. This superiority is known as binocular summation and is defined by the binocular summation ratio (BSR), which was originally believed to be around $\sqrt{2}$ ($\approx1.4$) for grating stimuli at detection threshold [@Campbell1965]. In other words, a monocular stimulus can elicit the same response as a binocular stimulus if it has a contrast that is 1.4 times higher. This led Legge to develop a widely accepted explanation that used quadratic summation to describe binocular combination [@Legge1984]: monocular signals from the right (R) and the left (L) eyes are squared before being summed together and the binocular response (B) is given by the square root of the output (B = $\sqrt{R^2 + L^2}$, when R and L are equal to 1, the output is $\sqrt{2}$). However, subsequent research has shown that these explanations are not fully adequate to account for binocular summation. Both of these accounts constitute single channel models, and this type of model has been shown to not being able to account for contrast detection in the presence of noise [@Anderson1989]. Moreover, more recent research has shown that the summation ratio can vary greatly between $\sqrt{2}$ and 2 depending on factors such as the spatial and temporal frequency of a stimulus or the sensitivity difference between the eyes [@Baker]. These observations led to the development of multistage gain control models, which combine binocular summation and interocular suppression, and can account for contrast matching, detection and discrimination for spatial contrast [@Ding2006; @Meese2006].
In general, it seems that the mechanisms behind binocular combination have been thoroughly studied, as have been the anatomical pathways behind it: light enters the eye though the pupil and signals are sent from the left and right retinae to the primary visual cortex, remaining anatomically isolated while passing through the lateral geniculate nucleus (LGN) until they reach V1, where they are binocularly combined [@Purves2008]. However, there is an eye component that is often underestimated in its role to determine the quality of visual information: the pupil. The pupils are openings found in the centre of the eyes that appear to be black and allow light to enter the eyes. Their size determines how much light will reach the retina and it is usually determined by the ambient levels of light: in brightness the pupils will constrict and in darkness they will dilate. This is known as the pupillary light response (PLR). The anatomical pathways that regulate this response are well understood and are very clearly and extensively described in the literature [@Angée2021; @Mathôt2018; @McDougal2010; @Wang2015]. However, they are anatomically distinct from the LGN-V1 pathway meaning that binocular combination occurs separately in anatomically distinct pathways. Given this, not much is known about the computational processes behind the PLR except for some evidence of binocular interaction. The presence of a consensual response in one eye when the other is being stimulated, and the presence of convergence (one pupil responds to illumination in either retina) and divergence (both pupils respond to illumination of one retina) [@Wyatt1981] are evidence of this binocular interaction.
With this in mind we designed an experiment that simultaneously recorded electrophysiological and pupillometric responses to investigate the combination of flickering light signals in both the visual cortex and the pupils. The results should offer new insight about basic neural circuits and information on how they might be affected in clinical disorders of vision (e.g. amblyopia). Based on previous literature, we expected to find a non-linear combination of the responses in visual cortex, as described by the gain control mechanisms, and a more linear combination of the responses and a greater binocular response at the level of the pupils.
To follow up on the results that we obtained, we decided to perform a contrast matching experiment to investigate whether perception of flickering light is consistent with the results observed in the cortical pathways (visual cortex) or the subcortical pathways (pupils). Matching is a paradigm in which the perceived brightness of a standard stimulus is matched to that of a target stimulus. In the latter, the interocular ratios of luminance are varied to obtain an equibrightness curve. Previous literature has used this paradigm to investigate the binocular fusion of static stimuli and the temporal combination of spatial flickering of spatial increments (a bright target on a dark background) and decrements (a dark target on a bright background) [@Anstis1998; @Levelt1965]. For spatial increments, it was found that binocular fusion seems to follow approximately linear combination rules. This means that, for a monocular stimulus to elicit the same response as a binocular stimulus, the former needs to have twice the signal of the latter. On the other hand, spatial decrements follow a winner-takes-all pattern. This means that the observer is seeing what the eye that is receiving the strongest signal is seeing.
Our experiment used different stimuli than the ones used by Anstis and Ho: in the binocular fusion experiment, their stimuli were not flickering and, in the flicker experiment, they were always shown in both eyes. In our experiment, in some conditions, the flicker was shown to only one eye. Moreover, they were looking at the temporal fusion of the flicker while we focussed on the binocular fusion of the flicker. Based on this and on the results from our first experiment, we expected to find a near linear summation of the responses.

# Methods


## Participants

## Apparatus & Stimuli



## Procedure

## Data analysis

@Baker2021

# Results

## Experiment 1

```{r include=FALSE, results='hide'}

# (download and) analyse individual participant data for experiment 1

if (processdata > 2){
  
legaltriggers <- 1

timeseq <- seq(1/120,10,length.out=120*10)
timeseq2 <- seq(1/120,14,length.out=120*14)
EEGtimes <- seq(1/1000,10,1/1000)
targetindex <- (2*10)+1
maskindex <- (1.6*10)+1
targetindex2 <- (2*2*10)+1
maskindex2 <- (2*1.6*10)+1

  for (participant in 1:30){
    
    # only download and process data if this has not been done already for this participant
    if (!file.exists(paste0(datadir,'P',100+participant,'summary.RData'))){   

      # if there is no directory for this participant's data
      if (!file.exists(paste0(rawdir,'P',100+participant))){
        dir.create(paste0(rawdir,'P',100+participant))
        
       d <- dir(paste0(rawdir,'P',100+participant))
       
       if (length(d)==0){
         
         # if the tar file of this participant's data doesn't exist
         if (!file.exists(paste0(rawdir,'P',100+participant,'.tar'))){
           # download it from OSF
           if (!exists('osffiles')){
           osfnode <- 'x8u4v'
           osfproject <- osf_retrieve_node(osfnode)
          osffiles <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffiles$name==paste0('P',100+participant,'.tar'))
          osf_download(osffiles[fid,],rawdir,progress=TRUE)
         }
         
         # then unzip the tar file
         untar(paste0(rawdir,'P',100+participant,'.tar'),exdir=paste0(rawdir,'P',100+participant))
         
         # and delete the tar file to save storage space
         file.remove(paste0(rawdir,'P',100+participant,'.tar'))
       }
      
      d <- dir(paste0(rawdir,'P',100+participant),full.names=TRUE)
       
      pupiltargets <- array(0,dim=c(3,2,60))
pupilmasks <- pupiltargets
pupilwaveforms <- array(0,dim=c(3,2,60,120*14))
pupilspectra <- array(0,dim=c(3,2,60,300))
EEGtargets <- array(0,dim=c(3,64,60))
EEGmasks <- EEGtargets
EEGtargets2 <- EEGtargets
EEGmasks2 <- EEGtargets
EEGwaveforms <- array(0,dim=c(3,64,60,1000*14))
EEGspectra <- array(0,dim=c(3,64,60,300))

psychopyfiles <- dir(path=paste0(rawdir,'P',100+participant),pattern=paste0('P',100+participant,'_CRFstudy'), full.names = TRUE)
infofiles <- dir(path=paste0(rawdir,'P',100+participant),pattern='*_info.csv', full.names = TRUE)
EEGfiles <- dir(path=paste0(rawdir,'P',100+participant),pattern='*_EEG.csv.gz', full.names = TRUE)
pupilfiles <- dir(path=paste0(rawdir,'P',100+participant),pattern='*_pupil_positions.csv', full.names = TRUE)

for (block in 1:length(EEGfiles)){
  
    infofile <- read.csv(infofiles[block])
  pupilstarttime <- as.numeric(as.character(infofile[4,2]))
  localstarttime <- as.numeric(as.character(infofile[5,2]))
  
  psychoutput <- read.csv(psychopyfiles[block])

  trialtimes <- psychoutput$trialonset - pupilstarttime
  condorder <- psychoutput$condition
  
    EEGdata <- read.csv(EEGfiles[block])
  electrodes <- colnames(EEGdata)
  
      triggertimes <- NULL
    counter <- 0
    lasttrigger <- -10000
    for (n in 1:nrow(EEGdata)){
      if(EEGdata$Trigger[n] %in% legaltriggers){
        if(n>(lasttrigger+10000)){
        counter <- counter + 1
        triggertimes[counter] <- n
        lasttrigger <- n
      }}
    }
  
    for (cond in 1:60){
      for (ch in 1:64){
        trial <- EEGdata[(triggertimes[cond]+(2001:12000)),ch+2]
        fspec <- (fft(trial)/length(trial))
        EEGtargets[block,ch,condorder[cond]] <- fspec[targetindex]
        EEGmasks[block,ch,condorder[cond]] <- fspec[maskindex]
        EEGtargets2[block,ch,condorder[cond]] <- fspec[targetindex2]
        EEGmasks2[block,ch,condorder[cond]] <- fspec[maskindex2]
        EEGspectra[block,ch,condorder[cond],1:300] <- fspec[1:300]
        
        trial <- EEGdata[(triggertimes[cond]+(-999:13000)),ch+2]
        EEGwaveforms[block,ch,condorder[cond],] <- trial - mean(trial[1:1000])
      }}
    
    
  pdata <- read.csv(pupilfiles[block])
  pdata2 <- pdata[,c(1,3,4,14)]
  pdata2[,1] <- pdata2[,1] - localstarttime
  pdata2 <- pdata2[which(pdata2[,3]>0.0),]

  for (eye in 1:2){
    eyedata <- pdata2[which(pdata2[,2]==(2-eye)),]
    for (cond in 1:60){
      a <- which(eyedata[,1]>trialtimes[cond]+2)
      b <- which(eyedata[,1]<(trialtimes[cond]+12))
      i <- intersect(a,b)
      trial <- eyedata[i,]
      trial[,1] <- trial[,1] - trial[1,1]
      if (nrow(trial)>3){
        resampled <- interp1(trial[,1],trial[,4],timeseq,method='linear',extrap=TRUE)
        fspec <- (fft(resampled)/length(resampled))
        pupiltargets[block,eye,condorder[cond]] <- fspec[targetindex]
        pupilmasks[block,eye,condorder[cond]] <- fspec[maskindex]
        pupilspectra[block,eye,condorder[cond],1:300] <- fspec[1:300]
      }
      
      a <- which(eyedata[,1]>(trialtimes[cond]-1))
      b <- which(eyedata[,1]<(trialtimes[cond]+13))
      i <- intersect(a,b)
      trial <- eyedata[i,]
      trial[,1] <- trial[,1] - trial[1,1]
      if (nrow(trial)>3){
        resampled <- interp1(trial[,1],trial[,4],timeseq2,method='linear',extrap=TRUE)
        pupilwaveforms[block,eye,condorder[cond],] <- resampled - mean(resampled[1:120])
      }
      
      }}
  
}

cleanmeansP <- matrix(0,nrow=6,ncol=5)
cleanmasksP <- matrix(0,nrow=6,ncol=5)
cleanmeansE <- array(0,dim=c(64,6,5))
cleanmasksE <- array(0,dim=c(64,6,5))
cleanmeansE2 <- array(0,dim=c(64,6,5))
cleanmasksE2 <- array(0,dim=c(64,6,5))

for (cond in 1:6){
  startindex <- (10*(cond-1))
  for (level in 1:5){
    temp <- c(pupiltargets[,,startindex+level],pupiltargets[,,startindex+level+5])
        cartdata <- data.frame(Re(temp),Im(temp))
    if (sum(cartdata)!=0){
      D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
      i <- which(D<SDthresh) 
    cleanmeansP[cond,level] <- mean(temp[i])}

    temp <- c(pupilmasks[,,startindex+level],pupiltargets[,,startindex+level+5])
        cartdata <- data.frame(Re(temp),Im(temp))
    if (sum(cartdata)!=0){
      D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
      i <- which(D<SDthresh) 
    cleanmasksP[cond,level] <- mean(temp[i])}

    for (ch in 1:64){
    temp <- c(EEGtargets[,ch,startindex+level],EEGtargets[,ch,startindex+level+5])
            cartdata <- data.frame(Re(temp),Im(temp))
    if (sum(cartdata)!=0){
      D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
      i <- which(D<SDthresh) 
    cleanmeansE[ch,cond,level] <- mean(temp[i])}
    
    temp <- c(EEGmasks[,ch,startindex+level],EEGmasks[,ch,startindex+level+5])
                cartdata <- data.frame(Re(temp),Im(temp))
    if (sum(cartdata)!=0){
      D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
      i <- which(D<SDthresh) 
    cleanmasksE[ch,cond,level] <- mean(temp[i])}
    
    temp <- c(EEGtargets2[,ch,startindex+level],EEGtargets2[,ch,startindex+level+5])
                cartdata <- data.frame(Re(temp),Im(temp))
    if (sum(cartdata)!=0){
      D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
      i <- which(D<SDthresh) 
    cleanmeansE2[ch,cond,level] <- mean(temp[i])}
    
    temp <- c(EEGmasks2[,ch,startindex+level],EEGmasks2[,ch,startindex+level+5])
                cartdata <- data.frame(Re(temp),Im(temp))
    if (sum(cartdata)!=0){
      D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
      i <- which(D<SDthresh) 
    cleanmasksE2[ch,cond,level] <- mean(temp[i])}   
    }

  }
}

electrodeindices <- match(targetelectrodes,electrodes)-2

meanwavesP <- apply(pupilwaveforms[,,c(15,20),],4,mean,na.rm=TRUE)
meanwavesE <- apply(EEGwaveforms[,electrodeindices,c(15,20),],4,mean,na.rm=TRUE)
meanspectraP <- apply(pupilspectra[,,c(15,20),],4,mean,na.rm=TRUE)
meanspectraE <- apply(EEGspectra[,electrodeindices,c(15,20),],4,mean,na.rm=TRUE)
save(file=paste(datadir,'P',100+participant,'summary.RData',sep=''),list=c('cleanmeansP','cleanmeansE','cleanmeansE2','cleanmasksP','cleanmasksE','cleanmasksE2','meanspectraP','meanspectraE','meanwavesP','meanwavesE','electrodes'))

      }
        
        
      }
      
    
    }
  }
  


```

```{r include=FALSE, results='hide'}

# load in individual participant data and average, save group data

if (processdata > 1){

         if (!file.exists(paste0(datadir,'headerfile.csv'))){
           # download it from OSF
           if (!exists('osffiles')){
           osfnode <- 'x8u4v'
           osfproject <- osf_retrieve_node(osfnode)
          osffiles <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffiles$name=='headerfile.csv')
          osf_download(osffiles[fid,],datadir,progress=TRUE)
          } 
  
  hdata <- read.csv(paste0(datadir,'headerfile.csv'))  

for (participant in 1:30){
         # if the summary file of this participant's data doesn't exist
         if (!file.exists(paste0(datadir,'P',100+participant,'summary.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '2qu6y'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name==paste0('P',100+participant,'summary.RData'))
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
         }
}

 
d <- dir(datadir,pattern='*summary.RData',full.names=TRUE)

tempmasksP <- array(0,dim=c(length(d),6,5))
tempmeansP <- tempmasksP
tempmasksE <- array(0,dim=c(length(d),64,6,5))
tempmeansE <- tempmasksE
tempmeansE2 <- tempmeansE
tempmasksE2 <- tempmasksE
tempspectraP <- array(0,dim=c(length(d),300))
tempspectraE <- array(0,dim=c(length(d),300))
tempwavesP <- array(0,dim=c(length(d),1680))
tempwavesE <- array(0,dim=c(length(d),14000))

  for (s in 1:length(d)){
    
    load(d[s])
    
  tempmasksP[s,,] <- cleanmasksP
  tempmeansP[s,,] <- cleanmeansP
  tempspectraP[s,] <- meanspectraP
  tempspectraE[s,] <- meanspectraE
  tempwavesP[s,] <- meanwavesP
  tempwavesE[s,] <- meanwavesE
  tempmeansE[s,,,] <- cleanmeansE
  tempmasksE[s,,,] <- cleanmasksE
  tempmeansE2[s,,,] <- cleanmeansE2
  tempmasksE2[s,,,] <- cleanmasksE2
    
  }

electrodeindices <- match(targetelectrodes,electrodes)-2

tempspectraP <- tempspectraP[-c(2,4,13,20,26),]

cleanmeansP <- matrix(0,nrow=6,ncol=5)
cleanmeansPCI <- array(0,c(2,6,5))
cleanmasksP <- matrix(0,nrow=6,ncol=5)
cleanmasksPCI <- array(0,c(2,6,5))
cleanmeansEav <- matrix(0,nrow=6,ncol=5)
cleanmeansEavCI <- array(0,c(2,6,5))
cleanmasksEav <- matrix(0,nrow=6,ncol=5)
cleanmasksEavCI <- array(0,c(2,6,5))
cleanmeansE2av <- matrix(0,nrow=6,ncol=5)
cleanmeansE2avCI <- array(0,c(2,6,5))
cleanmasksE2av <- matrix(0,nrow=6,ncol=5)
cleanmasksE2avCI <- array(0,c(2,6,5))
cleanmeansE <- array(0,dim=c(64,6,5))
cleanmeansECI <- array(0,c(2,64,6,5))
cleanmasksE <- array(0,dim=c(64,6,5))
cleanmasksECI <- array(0,c(2,64,6,5))
cleanmeansE2 <- array(0,dim=c(64,6,5))
cleanmeansE2CI <- array(0,c(2,64,6,5))
cleanmasksE2 <- array(0,dim=c(64,6,5))
cleanmasksE2CI <- array(0,c(2,64,6,5))


for (cond in 1:6){
  for (level in 1:5){
    
    temp <- tempmeansP[,cond,level]
    cartdata <- data.frame(Re(temp),Im(temp))
    if (sum(cartdata)!=0){
      D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
      i <- which(D<SDthresh) 
    mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
    cleanmeansP[cond,level] <- mbs$meanamp
    cleanmeansPCI[1,cond,level] <- mbs$lowerCI
    cleanmeansPCI[2,cond,level] <- mbs$upperCI
    }    
      
    temp <- tempmasksP[,cond,level]
    cartdata <- data.frame(Re(temp),Im(temp))
    if (sum(cartdata)!=0){
      D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
      i <- which(D<SDthresh) 
          mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
    cleanmasksP[cond,level] <- mbs$meanamp
    cleanmasksPCI[1,cond,level] <- mbs$lowerCI
    cleanmasksPCI[2,cond,level] <- mbs$upperCI
}
  
    
      temp <- apply(tempmeansE[,electrodeindices,cond,level],1,mean)
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh) 
    mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
    cleanmeansEav[cond,level] <- mbs$meanamp
    cleanmeansEavCI[1,cond,level] <- mbs$lowerCI
    cleanmeansEavCI[2,cond,level] <- mbs$upperCI
      }
      
temp <- apply(tempmasksE[,electrodeindices,cond,level],1,mean)
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh) 
mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
    cleanmasksEav[cond,level] <- mbs$meanamp
    cleanmasksEavCI[1,cond,level] <- mbs$lowerCI
    cleanmasksEavCI[2,cond,level] <- mbs$upperCI
        }

temp <- apply(tempmeansE2[,electrodeindices,cond,level],1,mean)
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh) 
    mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
    cleanmeansE2av[cond,level] <- mbs$meanamp
    cleanmeansE2avCI[1,cond,level] <- mbs$lowerCI
    cleanmeansE2avCI[2,cond,level] <- mbs$upperCI
        }

      temp <- apply(tempmasksE2[,electrodeindices,cond,level],1,mean)
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh) 
    mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
    cleanmasksE2av[cond,level] <- mbs$meanamp
    cleanmasksE2avCI[1,cond,level] <- mbs$lowerCI
    cleanmasksE2avCI[2,cond,level] <- mbs$upperCI
        }
      
    for (ch in 1:64){
      
      temp <- tempmeansE[,ch,cond,level]
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh) 
    mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
    cleanmeansE[ch,cond,level] <- mbs$meanamp
    cleanmeansECI[1,ch,cond,level] <- mbs$lowerCI
    cleanmeansECI[2,ch,cond,level] <- mbs$upperCI
}

      temp <- tempmasksE[,ch,cond,level]
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh) 
mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
    cleanmasksE[ch,cond,level] <- mbs$meanamp
    cleanmasksECI[1,ch,cond,level] <- mbs$lowerCI
    cleanmasksECI[2,ch,cond,level] <- mbs$upperCI
        }

      temp <- tempmeansE2[,ch,cond,level]
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh) 
    mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
    cleanmeansE2[ch,cond,level] <- mbs$meanamp
    cleanmeansE2CI[1,ch,cond,level] <- mbs$lowerCI
    cleanmeansE2CI[2,ch,cond,level] <- mbs$upperCI
        }
      
      temp <- tempmasksE2[,ch,cond,level]
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh) 
    mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
    cleanmasksE2[ch,cond,level] <- mbs$meanamp
    cleanmasksE2CI[1,ch,cond,level] <- mbs$lowerCI
    cleanmasksE2CI[2,ch,cond,level] <- mbs$upperCI
        }
      
    }}}

meanspectraP <- (1:300)*0
meanspectraE <- (1:300)*0
meanspectraPCI <- array(0,c(2,300))
meanspectraECI <- array(0,c(2,300))

for (f in 2:300){
  
        temp <- tempspectraP[,f]
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh) 
mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
meanspectraP[f] <- mbs$meanamp
meanspectraPCI[1,f] <- mbs$lowerCI
meanspectraPCI[2,f] <- mbs$upperCI
      }
      
        temp <- tempspectraE[,f]
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh) 
mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
meanspectraE[f] <- mbs$meanamp
meanspectraECI[1,f] <- mbs$lowerCI
meanspectraECI[2,f] <- mbs$upperCI
      }
}

meanwavesP <- NULL
meanwavesE <- NULL
meanwavesPCI <- array(0,dim=c(2,dim(tempwavesP)[2]))
meanwavesECI <- array(0,dim=c(2,dim(tempwavesE)[2]))
nsubjs <- dim(tempwavesP)[1]
for (t in 1:dim(tempwavesP)[2]){
  temp <- tempwavesP[,t]
  i <- which(abs(temp-mean(temp))<(SDthresh*sd(temp)))
  meanwavesP[t] <- mean(temp[i])
  bspop <- NULL
  for (s in 1:nbootstraps){bspop[s] <- mean(sample(temp[i],length(i),replace=TRUE))}
  meanwavesPCI[,t] <- quantile(bspop,c(0.16,0.84),na.rm=TRUE)
}

for (t in 1:dim(tempwavesE)[2]){
    temp <- tempwavesE[,t]
  i <- which(abs(temp-mean(temp))<(SDthresh*sd(temp)))
  meanwavesE[t] <- mean(temp[i])
  bspop <- NULL
  for (s in 1:nbootstraps){bspop[s] <- mean(sample(temp[i],length(i),replace=TRUE))}
  meanwavesECI[,t] <- quantile(bspop,c(0.16,0.84),na.rm=TRUE)
}

save(file=paste0(datadir,'Averagedata.RData'),list=c('cleanmeansP','cleanmeansPCI','cleanmasksP','cleanmasksPCI','cleanmeansEav','cleanmeansEavCI','cleanmasksEav','cleanmasksEavCI','cleanmeansE2av','cleanmeansE2avCI','cleanmasksE2av','cleanmasksE2avCI','cleanmeansE','cleanmeansECI','cleanmasksECI','cleanmeansE2','cleanmeansE2CI','cleanmasksE2','cleanmasksE2CI','meanspectraP','meanspectraPCI','meanspectraE','meanspectraECI','meanwavesP','meanwavesE','meanwavesPCI','meanwavesECI','electrodes'))

}

```

```{r include=FALSE, results='hide'}

# generate plot showing the group pupillometry data

if (processdata > 0){

contrastsdB <- 20*log10(c(6,12,24,48,96))

         if (!file.exists(paste0(datadir,'Averagedata.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '2qu6y'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name=='Averagedata.RData')
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
         }

load(file=paste0(datadir,'Averagedata.RData'))
  
plotlims <- c(15,40,0,0.03) 
ticklocsx <- contrastsdB    # locations of tick marks on x axis
ticklocsy <- seq(0,0.03,0.01)    # locations of tick marks on y axis
ticklabelsx <-c(6,12,24,48,96)        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

postscript("CRF1p.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude at 2Hz (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansP[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  arrows(contrastsdB,abs(cleanmeansP[cond,]),contrastsdB,cleanmeansPCI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansP[cond,]),contrastsdB,cleanmeansPCI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  points(contrastsdB,abs(cleanmeansP[cond,]), pch = 20+cond, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves
}  
legend(22,0.03,c('Monocular','Binocular','Dichoptic'),pch=21:23,pt.bg=colpal[1:3],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.028,'(c)',adj=0.5,cex=2.5)

dev.off()

postscript("CRF2p.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)   
title(ylab="Amplitude at 2Hz (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

condlist <- c(1,5,6)
pointlist <- c(21,24,25)
for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansP[condlist[cond],]), col=colpal[condlist[cond]], lwd=3, cex=0.5)  
  arrows(contrastsdB,abs(cleanmeansP[condlist[cond],]),contrastsdB,cleanmeansPCI[1,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansP[condlist[cond],]),contrastsdB,cleanmeansPCI[2,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)  
  points(contrastsdB,abs(cleanmeansP[condlist[cond],]), pch = pointlist[cond], col='black', bg=colpal[condlist[cond]], cex=1.6, lwd=3)   
}  
legend(22,0.03,c('Monocular','Binocular cross','Dichoptic cross'),pch=pointlist,pt.bg=colpal[condlist],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.028,'(d)',adj=0.5,cex=2.5)

dev.off()


postscript("CRF3p.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude at 1.6Hz (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

for (cond in 4:6){
  lines(contrastsdB,abs(cleanmasksP[cond,]), col=colpal[cond], lwd=3, cex=0.5)   
  arrows(contrastsdB,abs(cleanmasksP[cond,]),contrastsdB,cleanmasksPCI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmasksP[cond,]),contrastsdB,cleanmasksPCI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)    
  points(contrastsdB,abs(cleanmasksP[cond,]), pch = pointlist[cond-3], col='black', bg=colpal[cond], cex=1.6, lwd=3) 
}
legend(22,0.03,c('Monocular 1.6Hz','Binocular cross','Dichoptic cross'),pch=pointlist,pt.bg=colpal[4:6],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.028,'(e)',adj=0.5,cex=2.5)

dev.off()


postscript("SpecP.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 8)

frequencies <- (0:299)/10

plotlims <- c(1,6,0,0.03) 
ticklocsx <- seq(1,6,1)    # locations of tick marks on x axis
ticklocsy <- seq(0,0.03,0.01)    # locations of tick marks on y axis
ticklabelsx <-ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
title(xlab="Frequency (Hz)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

polygon(frequencies[c(11:61,61:11)],c(meanspectraPCI[1,11:61],meanspectraPCI[2,61:11]),col=colpal[2],border=NA)

lines(frequencies[11:61],abs(meanspectraP[11:61]), col=colpal[2], lwd=3, cex=0.5) 

text(1.1,0.028,'(b)',adj=0.5,cex=2.5)

dev.off()



postscript("timecourseP.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 8)

times <- seq((1/120)-1,13,1/120)
sinewave <- sin(2*times * 2*pi)
sinewave[1:120] <- 0
sinewave[1560:1680] <- 0

plotlims <- c(-1,13,-1,0.5) 
ticklocsx <- seq(-1,13,1)    # locations of tick marks on x axis
ticklocsy <- seq(-1,0.5,0.5)    # locations of tick marks on y axis
ticklabelsx <- ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
title(xlab="Time (s)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

filt <- butter(3,0.083)
filtwaveP <- signal::filter(filt, meanwavesP)
filtU <- signal::filter(filt,meanwavesPCI[1,])
filtL <- signal::filter(filt,meanwavesPCI[2,])
polygon(times[c(1:length(times),length(times):1)],c(filtL,filtU[length(filtU):1]),col=colpal[2],border=NA)

lines(times, filtwaveP, col=colpal[2], lwd=1.5) 

lines(times, (sinewave/10)-0.9, col='black', lwd=3) 

text(-0.7,0.4,'(a)',adj=0.5,cex=2.5)

dev.off()


  PostScriptTrace('CRF1p.ps')
  p1 <- readPicture('CRF1p.ps.xml')
  PostScriptTrace('CRF2p.ps')
  p2 <- readPicture('CRF2p.ps.xml')
  PostScriptTrace('CRF3p.ps')
  p3 <- readPicture('CRF3p.ps.xml')
  PostScriptTrace('SpecP.ps')
  p4 <- readPicture('SpecP.ps.xml')
  PostScriptTrace('timecourseP.ps')
  p5 <- readPicture('timecourseP.ps.xml')
  
    for (n in 1:length(p4@paths)){
    temp <- class(p4@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(p4@paths[n]$path@rgb))<765){p4@paths[n]$path@rgb <- addalpha(p4@paths[n]$path@rgb,alpha=0.2)}}}
  
      for (n in 1:length(p5@paths)){
    temp <- class(p5@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(p5@paths[n]$path@rgb))<765){p5@paths[n]$path@rgb <- addalpha(p5@paths[n]$path@rgb,alpha=0.2)}}}

  
  pdf(paste0(figdir,"pupildata.pdf"), bg="transparent", height = 10, width = 15)
  par(mar=c(0.1,0.1,0.1,0.1))
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(0,1), ylim=c(0,1))
  
  grid.picture(p1,x=0.17,y=0.25,width=0.32,height=1)
  grid.picture(p2,x=0.5,y=0.25,width=0.32,height=1)
  grid.picture(p3,x=0.83,y=0.25,width=0.32,height=1)
  grid.picture(p5,x=0.25,y=0.7,width=0.5,height=1)
  grid.picture(p4,x=0.75,y=0.7,width=0.5,height=1)
  
  text(0.5,0.98,'Pupillometry',cex=4)
  
  dev.off()
  
  file.remove(c('CRF1p.ps','CRF2p.ps','CRF3p.ps','SpecP.ps','timecourseP.ps'))
  file.remove(c('CRF1p.ps.xml','CRF2p.ps.xml','CRF3p.ps.xml','SpecP.ps.xml','timecourseP.ps.xml'))



}

```

```{r pupildata, fig.cap="Summary of pupillometry results for N=30 participants. Panel (a) shows a group average waveform for binocular presentation (low pass filtered at 5Hz), with the driving signal plotted at the foot. Panel (b) shows the average Fourier spectrum. Panels (c,d) show contrast response functions at 2Hz for different conditions. Panel (e) shows contrast response functions at 1.6Hz for three conditions. Shaded regions and error bars indicate bootstrapped standard errors.", fig.align="center", echo=FALSE}

knitr::include_graphics(paste0(figdir,'pupildata.pdf'))

```


Figure \@ref(fig:pupildata)a

```{r include=FALSE, results='hide'}

# generate plot showing the group EEG data

if (processdata > 0){

contrastsdB <- 20*log10(c(6,12,24,48,96))

         if (!file.exists(paste0(datadir,'headerfile.csv'))){
           # download it from OSF
           if (!exists('osffiles')){
           osfnode <- 'x8u4v'
           osfproject <- osf_retrieve_node(osfnode)
          osffiles <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffiles$name=='headerfile.csv')
          osf_download(osffiles[fid,],datadir,progress=TRUE)
          } 
hdata <- read.csv(paste0(datadir,'headerfile.csv'))  

         if (!file.exists(paste0(datadir,'Averagedata.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '2qu6y'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name=='Averagedata.RData')
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
         }

load(file=paste0(datadir,'Averagedata.RData'))

electrodeindices <- match(targetelectrodes,electrodes)-2

plotlims <- c(15,40,0,0.8)  
ticklocsx <- contrastsdB    # locations of tick marks on x axis
ticklocsy <- seq(0,0.8,0.2)    # locations of tick marks on y axis
ticklabelsx <-c(6,12,24,48,96)        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

postscript("CRF1e.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude (µV) at 2Hz", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansEav[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  arrows(contrastsdB,abs(cleanmeansEav[cond,]),contrastsdB,cleanmeansEavCI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansEav[cond,]),contrastsdB,cleanmeansEavCI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  points(contrastsdB,abs(cleanmeansEav[cond,]), pch = 20+cond, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves
}  
legend(22,0.8,c('Monocular','Binocular','Dichoptic'),pch=21:23,pt.bg=colpal[1:3],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.75,'(c)',adj=0.5,cex=2.5)

dev.off()

postscript("CRF2e.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)   
title(ylab="Amplitude (µV) at 2Hz", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

condlist <- c(1,5,6)
pointlist <- c(21,24,25)
for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansEav[condlist[cond],]), col=colpal[condlist[cond]], lwd=3, cex=0.5)  
  arrows(contrastsdB,abs(cleanmeansEav[condlist[cond],]),contrastsdB,cleanmeansEavCI[1,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansEav[condlist[cond],]),contrastsdB,cleanmeansEavCI[2,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  points(contrastsdB,abs(cleanmeansEav[condlist[cond],]), pch = pointlist[cond], col='black', bg=colpal[condlist[cond]], cex=1.6, lwd=3)   
}  
legend(22,0.8,c('Monocular','Binocular cross','Dichoptic cross'),pch=pointlist,pt.bg=colpal[condlist],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.75,'(d)',adj=0.5,cex=2.5)

dev.off()


postscript("CRF3e.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude (µV) at 1.6Hz", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

for (cond in 4:6){
  lines(contrastsdB,abs(cleanmasksEav[cond,]), col=colpal[cond], lwd=3, cex=0.5)   
  arrows(contrastsdB,abs(cleanmasksEav[cond,]),contrastsdB,cleanmasksEavCI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmasksEav[cond,]),contrastsdB,cleanmasksEavCI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  points(contrastsdB,abs(cleanmasksEav[cond,]), pch = pointlist[cond-3], col='black', bg=colpal[cond], cex=1.6, lwd=3) 
}
legend(22,0.8,c('Monocular 1.6Hz','Binocular cross','Dichoptic cross'),pch=pointlist,pt.bg=colpal[4:6],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.75,'(e)',adj=0.5,cex=2.5)

dev.off()


postscript("CRF1e2.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude (µV) at 4Hz", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansE2av[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  arrows(contrastsdB,abs(cleanmeansE2av[cond,]),contrastsdB,cleanmeansE2avCI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  if (cond!=2){
  arrows(contrastsdB,abs(cleanmeansE2av[cond,]),contrastsdB,cleanmeansE2avCI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)}
  
  # plot an arrow for the final binocular target contrast level that is above 0.8
  if (cond==2){
  arrows(contrastsdB[1:4],abs(cleanmeansE2av[cond,1:4]),contrastsdB[1:4],cleanmeansE2avCI[2,cond,1:4],lwd=3,col=colpal[cond],length=0.05,angle=90)   
  arrows(contrastsdB[5],abs(cleanmeansE2av[cond,5]),contrastsdB[5],0.8,lwd=3,col=colpal[cond],length=0.05,angle=45)    
  }
  
  points(contrastsdB,abs(cleanmeansE2av[cond,]), pch = 20+cond, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves
}  
legend(22,0.8,c('Monocular','Binocular','Dichoptic'),pch=21:23,pt.bg=colpal[1:3],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.75,'(f)',adj=0.5,cex=2.5)

dev.off()

postscript("CRF2e2.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)   
title(ylab="Amplitude (µV) at 4Hz", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

condlist <- c(1,5,6)
pointlist <- c(21,24,25)
for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansE2av[condlist[cond],]), col=colpal[condlist[cond]], lwd=3, cex=0.5)  
  arrows(contrastsdB,abs(cleanmeansE2av[condlist[cond],]),contrastsdB,cleanmeansE2avCI[1,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansE2av[condlist[cond],]),contrastsdB,cleanmeansE2avCI[2,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  points(contrastsdB,abs(cleanmeansE2av[condlist[cond],]), pch = pointlist[cond], col='black', bg=colpal[condlist[cond]], cex=1.6, lwd=3)   
}  
legend(22,0.8,c('Monocular','Binocular cross','Dichoptic cross'),pch=pointlist,pt.bg=colpal[condlist],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.75,'(g)',adj=0.5,cex=2.5)

dev.off()


postscript("CRF3e2.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude (µV) at 3.2Hz", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

for (cond in 4:6){
  lines(contrastsdB,abs(cleanmasksE2av[cond,]), col=colpal[cond], lwd=3, cex=0.5)   
  arrows(contrastsdB,abs(cleanmasksE2av[cond,]),contrastsdB,cleanmasksE2avCI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmasksE2av[cond,]),contrastsdB,cleanmasksE2avCI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  points(contrastsdB,abs(cleanmasksE2av[cond,]), pch = pointlist[cond-3], col='black', bg=colpal[cond], cex=1.6, lwd=3) 
}
legend(22,0.8,c('Monocular 1.6Hz','Binocular cross','Dichoptic cross'),pch=pointlist,pt.bg=colpal[4:6],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.75,'(h)',adj=0.5,cex=2.5)

dev.off()


postscript("SpecE.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 8)

frequencies <- (0:299)/10

plotlims <- c(1,6,0,1) 
ticklocsx <- seq(1,6,1)    # locations of tick marks on x axis
ticklocsy <- seq(0,1,0.2)    # locations of tick marks on y axis
ticklabelsx <-ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
title(xlab="Frequency (Hz)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude (µV)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

polygon(frequencies[c(11:61,61:11)],c(meanspectraECI[1,11:61],meanspectraECI[2,61:11]),col=colpal[2],border=NA)

lines(frequencies[11:61],abs(meanspectraE[11:61]), col=colpal[2], lwd=3, cex=0.5) 

text(1.1,0.95,'(b)',adj=0.5,cex=2.5)

dev.off()



postscript("timecourseE.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 8)

times <- seq((1/1000)-1,13,1/1000)
sinewave <- sin(2*times * 2*pi)
sinewave[1:1000] <- 0
sinewave[13001:14000] <- 0

plotlims <- c(-1,13,-10,20) 
ticklocsx <- seq(-1,13,1)    # locations of tick marks on x axis
ticklocsy <- seq(-10,20,10)    # locations of tick marks on y axis
ticklabelsx <- ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
title(xlab="Time (s)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude (µV)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

filt <- butter(3,0.083*0.12)
filtwaveE <- signal::filter(filt, meanwavesE)
filtU <- signal::filter(filt,meanwavesECI[1,])
filtL <- signal::filter(filt,meanwavesECI[2,])
polygon(times[c(1:length(times),length(times):1)],c(filtL,filtU[length(filtU):1]),col=colpal[2],border=NA)

lines(times, filtwaveE, col=colpal[2], lwd=1.5) 

lines(times, (sinewave*2.5)-7.5, col='black', lwd=3) 

text(-0.7,18,'(a)',adj=0.5,cex=2.5)

dev.off()


xpos <- 1:64
ypos <- 1:64
montageE <- toupper(as.character(hdata$Electrode))
for (ch in 1:64){
  i <- match(toupper(electrodes[ch+2]),montageE)
  xpos[ch] <- hdata$X_position[i]
  ypos[ch] <- hdata$Y_position[i]
}

ramp2 <- colorRamp(c("white",colpal[2]))  # create a ramp from one colour to another
colmatrix2 <- rgb(ramp2(seq(0, 1, length = 101)), max = 255)

## Create data frame to be used for interpolation - the function needs columns labelled x, y, and z
rmax <- 0.55   #specify a maximum boundary for the grid
gridRes <- 100 #specify the interpolation grid resolution

toplot <- abs(cleanmeansE[,2,5])
toplot[which(is.na(toplot))] <- 0
testDat<- data.frame(x = xpos, y = -ypos, z = toplot)

#Create the interpolation grid
xo <- seq(min(-rmax, testDat$x), max(rmax, testDat$x), length = gridRes)
yo <- seq(max(rmax, testDat$y), min(-rmax, testDat$y), length = gridRes)

interpV4 <- v4Interp(testDat, xo, yo, rmax, gridRes)

zo2 <- as.matrix(interpV4[,2:ncol(interpV4)])

xo2 <- matrix(rep(xo,length(yo)),nrow = length(xo),ncol = length(yo))
yo2 <- t(matrix(rep(yo,length(xo)),nrow = length(yo),ncol = length(xo)))
outsidecircle <- sqrt(xo2^2 + yo2^2) > 0.51
zo2[outsidecircle] <- 0

tiff("head1.tiff", height = 600, width = 600, units="px", bg="white")

plotlims <- c(-rmax,rmax,-rmax,rmax) 
par(pty="s")  # make axis square
plot(x=NULL,y=NULL,ann=FALSE, axes=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
image(xo,xo,zo2,col=colmatrix2,zlim=c(0,1),add=TRUE,useRaster=TRUE)
maskx <- c(hdata$OutlineX[1:51]*2.2,hdata$OutlineX[51:1])
masky <- c(hdata$OutlineY[1:51]*2.2,hdata$OutlineY[51:1])
polygon(maskx,masky,border=NA,col="white")
maskx <- c(hdata$OutlineX[51:101]*2.2,hdata$OutlineX[101:51])
masky <- c(hdata$OutlineY[51:101]*2.2,hdata$OutlineY[101:51])
polygon(maskx,masky,border=NA,col="white")

blackelectrodes <- match(toupper(targetelectrodes),toupper(as.character(electrodes[3:66])))
points(xpos[blackelectrodes],ypos[blackelectrodes],pch=16,col="black",cex=2)

lines(hdata$OutlineX,hdata$OutlineY,col="black",lwd=2)
lines(hdata$NoseX,hdata$NoseY,col="black",lwd=2)
lines(hdata$LearX,hdata$LearY,col="black",lwd=2)
lines(hdata$RearX,hdata$RearY,col="black",lwd=2)

dev.off()


toplot <- abs(cleanmeansE2[,2,5])
toplot[which(is.na(toplot))] <- 0
testDat<- data.frame(x = xpos, y = -ypos, z = toplot)

#Create the interpolation grid
xo <- seq(min(-rmax, testDat$x), max(rmax, testDat$x), length = gridRes)
yo <- seq(max(rmax, testDat$y), min(-rmax, testDat$y), length = gridRes)

interpV4 <- v4Interp(testDat, xo, yo, rmax, gridRes)

zo2 <- as.matrix(interpV4[,2:ncol(interpV4)])

xo2 <- matrix(rep(xo,length(yo)),nrow = length(xo),ncol = length(yo))
yo2 <- t(matrix(rep(yo,length(xo)),nrow = length(yo),ncol = length(xo)))
outsidecircle <- sqrt(xo2^2 + yo2^2) > 0.51
zo2[outsidecircle] <- 0
zo2[which(zo2>1)] <- 1

tiff("head2.tiff", height = 600, width = 600, units="px", bg="white")

plotlims <- c(-rmax,rmax,-rmax,rmax) 
par(pty="s")  # make axis square
plot(x=NULL,y=NULL,ann=FALSE, axes=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
image(xo,xo,zo2,col=colmatrix2,zlim=c(0,1),add=TRUE,useRaster=TRUE)
maskx <- c(hdata$OutlineX[1:51]*2.2,hdata$OutlineX[51:1])
masky <- c(hdata$OutlineY[1:51]*2.2,hdata$OutlineY[51:1])
polygon(maskx,masky,border=NA,col="white")
maskx <- c(hdata$OutlineX[51:101]*2.2,hdata$OutlineX[101:51])
masky <- c(hdata$OutlineY[51:101]*2.2,hdata$OutlineY[101:51])
polygon(maskx,masky,border=NA,col="white")

blackelectrodes <- match(toupper(targetelectrodes),toupper(as.character(electrodes[3:66])))
points(xpos[blackelectrodes],ypos[blackelectrodes],pch=16,col="black",cex=2)

lines(hdata$OutlineX,hdata$OutlineY,col="black",lwd=2)
lines(hdata$NoseX,hdata$NoseY,col="black",lwd=2)
lines(hdata$LearX,hdata$LearY,col="black",lwd=2)
lines(hdata$RearX,hdata$RearY,col="black",lwd=2)

dev.off()


  PostScriptTrace('CRF1e.ps')
  p1 <- readPicture('CRF1e.ps.xml')
  PostScriptTrace('CRF2e.ps')
  p2 <- readPicture('CRF2e.ps.xml')
  PostScriptTrace('CRF3e.ps')
  p3 <- readPicture('CRF3e.ps.xml')
  PostScriptTrace('SpecE.ps')
  p4 <- readPicture('SpecE.ps.xml')
  PostScriptTrace('timecourseE.ps')
  p5 <- readPicture('timecourseE.ps.xml')
  PostScriptTrace('CRF1e2.ps')
  p6 <- readPicture('CRF1e2.ps.xml')
  PostScriptTrace('CRF2e2.ps')
  p7 <- readPicture('CRF2e2.ps.xml')
  PostScriptTrace('CRF3e2.ps')
  p8 <- readPicture('CRF3e2.ps.xml')
  
    for (n in 1:length(p4@paths)){
    temp <- class(p4@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(p4@paths[n]$path@rgb))<765){p4@paths[n]$path@rgb <- addalpha(p4@paths[n]$path@rgb,alpha=0.2)}}}

      for (n in 1:length(p5@paths)){
    temp <- class(p5@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(p5@paths[n]$path@rgb))<765){p5@paths[n]$path@rgb <- addalpha(p5@paths[n]$path@rgb,alpha=0.2)}}}

    
  h1 <- readTIFF('head1.tiff')
  h2 <- readTIFF('head2.tiff')
  
  pdf(paste0(figdir,"EEGdata.pdf"), bg="transparent", height = 15, width = 15)
  par(mar=c(0.1,0.1,0.1,0.1))
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(0,1), ylim=c(0,1))
  
  # insert the head plots first so the white border doesn't overlap the other graphs
    aspratio <- 1  # this is the aspect ratio of the output pdf
  imwidth <- 0.16
  xstart <- 0.65
  ystart <- 0.82
  rasterImage(h1,xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth) 
  xstart <- 0.82
  ystart <- 0.82
  rasterImage(h2,xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth)

  grid.picture(p5,x=0.25,y=0.8,width=0.5,height=1)
  grid.picture(p4,x=0.75,y=0.8,width=0.5,height=1)
  grid.picture(p1,x=0.17,y=0.5,width=0.32,height=1)
  grid.picture(p2,x=0.5,y=0.5,width=0.32,height=1)
  grid.picture(p3,x=0.83,y=0.5,width=0.32,height=1)
  grid.picture(p6,x=0.17,y=0.175,width=0.32,height=1)
  grid.picture(p7,x=0.5,y=0.175,width=0.32,height=1)
  grid.picture(p8,x=0.83,y=0.175,width=0.32,height=1)
  
    text(0.5,1,'Electroencephalography',cex=4)

  dev.off()
  
  file.remove(c('CRF1e.ps','CRF2e.ps','CRF3e.ps','CRF1e2.ps','CRF2e2.ps','CRF3e2.ps','SpecE.ps','timecourseE.ps','head1.tiff','head2.tiff'))
  file.remove(c('CRF1e.ps.xml','CRF2e.ps.xml','CRF3e.ps.xml','CRF1e2.ps.xml','CRF2e2.ps.xml','CRF3e2.ps.xml','SpecE.ps.xml','timecourseE.ps.xml'))



}

```

```{r EEGdata, fig.cap="Summary of EEG results for N=30 participants. Panel (a) shows a group average waveform for binocular presentation (low pass filtered at 5Hz), with the driving signal plotted at the foot. Panel (b) shows the average Fourier spectrum, and inset scalp distributions. Black dots on the scalp plots indicate electrodes Oz, POz, O1 and O2. Panels (c,d) show contrast response functions at 2Hz for different conditions. Panel (e) shows contrast response functions at 1.6Hz for three conditions. Panels (f-h) are in the same format but for the second harmonic responses. Shaded regions and error bars indicate bootstrapped standard errors.", fig.align="center", echo=FALSE}

knitr::include_graphics(paste0(figdir,'EEGdata.pdf'))

```



## Experiment 2

```{r include=FALSE, results='hide'}

# (download and) analyse the raw data from the temporal frequency experiment

if (processdata > 2){
  
  legaltriggers <- 1
  
  TFs <- c(2,4,8,16,30)
  EEGtimes <- seq(1/1000,10,1/1000)
  targetindices <- (TFs*10)+1
  
  for (participant in 1:12){
    print(participant)
    
# download and process data if this has not been done already for this participant
    if (!file.exists(paste0(datadir,'P',150+participant,'summary.RData'))){   
      
      # if there is no directory for this participant's data
      if (!file.exists(paste0(rawdir,'P',150+participant))){
        dir.create(paste0(rawdir,'P',150+participant))}
      
      d <- dir(paste0(rawdir,'P',150+participant))
      
      if (length(d)==0){
        
        # if the tar file of this participant's data doesn't exist
        if (!file.exists(paste0(rawdir,'P',150+participant,'.tar'))){
          # download it from OSF
          if (!exists('tffiles')){
            osfnode <- 'mvpyz'
            osfproject <- osf_retrieve_node(osfnode)
            tffiles <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(tffiles$name==paste0('P',150+participant,'.tar'))
          osf_download(tffiles[fid,],rawdir,progress=TRUE)
        }
        
        # then unzip the tar file
        untar(paste0(rawdir,'P',150+participant,'.tar'),exdir=paste0(rawdir,'P',150+participant))
        
        # and delete the tar file to save storage space
        file.remove(paste0(rawdir,'P',150+participant,'.tar'))
      }
      
      d <- dir(paste0(rawdir,'P',150+participant),full.names=TRUE)
      
      EEGtargets <- array(0,dim=c(5,64,20,5))
      EEGspectra <- array(0,dim=c(5,64,20,500))
      
      psychopyfiles <- dir(path=paste0(rawdir,'P',150+participant), pattern=paste0('P',150+participant,'_CRFstudy'), full.names = TRUE)
      
      EEGfiles <- dir(path=paste0(rawdir,'P',150+participant), pattern='*_EEG.gz', full.names = TRUE)
      
      for (block in 1:length(EEGfiles)){
        
        psychoutput <- read.csv(psychopyfiles[block])
        
        condorder <- psychoutput$condition
        
        EEGdata <- read.csv(EEGfiles[block])
        electrodes <- colnames(EEGdata)
        
        triggertimes <- NULL
        counter <- 0
        lasttrigger <- -10000
        for (n in 1:nrow(EEGdata)){
          if(EEGdata$Trigger[n] %in% legaltriggers){
            if(n>(lasttrigger+10000)){
              counter <- counter + 1
              triggertimes[counter] <- n
              lasttrigger <- n
            }}
        }
        
        for (cond in 1:counter){
          for (ch in 1:64){
            trial <- EEGdata[(triggertimes[cond]+(2001:12000)),ch+2]
            fspec <- (fft(trial)/length(trial))
            EEGtargets[block,ch,condorder[cond],] <- fspec[targetindices]
            EEGspectra[block,ch,condorder[cond],1:500] <- fspec[1:500]
          }}
      }
      
      electrodeindices <- match(targetelectrodes,electrodes)-2
      
      cleanmeansE <- array(0,dim=c(2,5))
      meanspec <- array(0,dim=c(2,5,500))
      
      for (eye in 1:2){
        for (cond in 1:5){
          includedconds <- c(cond,cond+5) + (10*(eye-1))
          temp <- as.vector(EEGtargets[,electrodeindices,includedconds,cond])
          temp <- temp[which(!is.na(temp))]
          temp <- temp[which(abs(temp)>0)]  
          cartdata <- data.frame(Re(temp),Im(temp))
          if (sum(cartdata)!=0){
            D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
            i <- which(D<SDthresh) 
            cleanmeansE[eye,cond] <- mean(temp[i])}   
          
          for (f in 2:500){
            temp <- as.vector(apply(EEGspectra[,electrodeindices,includedconds,f],c(1,3),mean))
            temp <- temp[which(!is.na(temp))]
            temp <- temp[which(abs(temp)>0)]  
            cartdata <- data.frame(Re(temp),Im(temp))
            if (sum(cartdata)!=0){
              D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
              i <- which(D<SDthresh) 
              meanspec[eye,cond,f] <- mean(temp[i])}   
          }
        }
      }
      
    }
    
    save(file=paste0(datadir,'P',150+participant,'summary.RData'),list=c('cleanmeansE','meanspec'))
    
  }
  
}


```

```{r include=FALSE, results='hide'}

# load in the processed data from the temporal frequency experiment and average

if (processdata > 1){
  
  allspec <- array(0,dim=c(12,2,5,500))
  allmeans <- array(0,dim=c(12,2,5))
  allratios <- matrix(0,nrow=12,ncol=5)
  
      for (participant in 1:12){
         # if the summary file of this participant's data doesn't exist
         if (!file.exists(paste0(datadir,'P',150+participant,'summary.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '2qu6y'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name==paste0('P',150+participant,'summary.RData'))
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
         }
      }
  
  for (participant in 1:12){
    
    load(paste0(datadir,'P',150+participant,'summary.RData'))
    
    allmeans[participant,,] <- cleanmeansE
    allspec[participant,,,] <- meanspec
    allratios[participant,] <- 20*log10(abs(allmeans[participant,2,])/abs(allmeans[participant,1,]))
  }
  
meanratios <- NULL
meanratiosCI <- matrix(0,nrow=2,ncol=5)
cleanmeansTF <- matrix(0,nrow=2,ncol=5)
cleanmeansTFCI <- array(0,dim=c(2,2,5))
meanspectraTF <- array(0,dim=c(2,5,500))
meanspectraTFCI <- array(0,dim=c(2,2,5,500))

for (cond in 1:2){
  for (level in 1:5){
    
    temp <- allmeans[,cond,level]
    cartdata <- data.frame(Re(temp),Im(temp))
    if (sum(cartdata)!=0){
      D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
      i <- which(D<SDthresh) 
    mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
    cleanmeansTF[cond,level] <- mbs$meanamp
    cleanmeansTFCI[1,cond,level] <- mbs$lowerCI
    cleanmeansTFCI[2,cond,level] <- mbs$upperCI
    }    
    
    meanratios[level] <- mean(allratios[,level])
    bspop <- NULL
    for (n in 1:nbootstraps){
      bspop[n] <- mean(sample(allratios[,level],nrow(allratios),replace=TRUE))
    }
    meanratiosCI[,level] <- quantile(bspop,c((1-0.68)/2,1-((1-0.68)/2)))
      
    for (f in 2:500){
  
        temp <- allspec[,cond,level,f]
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh) 
mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
meanspectraTF[cond,level,f] <- mbs$meanamp
meanspectraTFCI[1,cond,level,f] <- mbs$lowerCI
meanspectraTFCI[2,cond,level,f] <- mbs$upperCI
      }
    }
  }
}

save(file=paste0(datadir,'AveragedataTF.RData'),list=c('cleanmeansTF','cleanmeansTFCI','meanspectraTF','meanspectraTFCI','meanratios','meanratiosCI'))

}

```

```{r include=FALSE, results='hide'}

# generate figure showing the TF data

if (processdata > 0){
  
         if (!file.exists(paste0(datadir,'AveragedataTF.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '2qu6y'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name=='AveragedataTF.RData')
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
         }
  
  load(paste0(datadir,'AveragedataTF.RData'))
  
  TFs <- c(2,4,8,16,30)
  TFsdB <- 20*log10(TFs)
  
  postscript("SpecTF.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 8, width = 5.5)

frequencies <- (0:499)/10

plotlims <- c(0,36,0,5) 
ticklocsx <- seq(0,36,6)    # locations of tick marks on x axis
ticklocsy <- seq(0,5,1)    # locations of tick marks on y axis
ticklabelsx <- 2^(0:6)        # set labels for x ticks
ticklabelsy <- c(0,1,'','','','')    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
title(xlab="Frequency (Hz)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude (µV)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)


for (cond in 1:5){
  
lines(c(0,36),c(cond,cond)-1)  
polygon(20*log10(frequencies[c(11:490,490:11)]),(cond-1)+c(meanspectraTFCI[1,2,cond,11:490],meanspectraTFCI[2,2,cond,490:11]),col=colpal[cond],border=NA)

lines(20*log10(frequencies[11:490]),(cond-1)+abs(meanspectraTF[2,cond,11:490]), col=colpal[cond], lwd=2, cex=0.5) 
}

text(33,0.25,'2Hz',adj=0.5,cex=1.5,col=colpal[1])
text(33,1.25,'4Hz',adj=0.5,cex=1.5,col=colpal[2])
text(33,2.25,'8Hz',adj=0.5,cex=1.5,col=colpal[3])
text(33,3.25,'16Hz',adj=0.5,cex=1.5,col=colpal[4])
text(33,4.25,'30Hz',adj=0.5,cex=1.5,col=colpal[5])

text(1.5,4.8,'(a)',adj=0.5,cex=2.5)
text(18,4.8,'Binocular',adj=0.5,cex=2)

dev.off()
  
  
  
plotlims <- c(6,30,0,1)  
ticklocsx <- seq(6,30,6)    # locations of tick marks on x axis
ticklocsy <- seq(0,1,0.2)    # locations of tick marks on y axis
ticklabelsx <- 2^(1:5)        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

postscript("TF1.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Frequency (Hz)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude (µV)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

for (cond in 1:2){
  lines(TFsdB,abs(cleanmeansTF[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  arrows(TFsdB,abs(cleanmeansTF[cond,]),TFsdB,cleanmeansTFCI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  arrows(TFsdB,abs(cleanmeansTF[cond,]),TFsdB,cleanmeansTFCI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  points(TFsdB,abs(cleanmeansTF[cond,]), pch = 20+cond, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves
}  
legend(20,1,c('Monocular','Binocular'),pch=21:22,pt.bg=colpal[1:2],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(7.5,0.92,'(b)',adj=0.5,cex=2.5)

dev.off()
  

plotlims <- c(6,30,-3,12)  
ticklocsy <- seq(-3,12,3)    # locations of tick marks on y axis
ticklabelsy <- c(expression(1/sqrt(2)),'1',expression(sqrt(2)),'2',expression(2*sqrt(2)),'4')

postscript("TF2.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Frequency (Hz)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Bin:Mon ratio", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

  lines(TFsdB,meanratios, col=colpal[3], lwd=3, cex=0.5)
  arrows(TFsdB,meanratios,TFsdB,meanratiosCI[1,],lwd=3,col=colpal[3],length=0.05,angle=90)
  arrows(TFsdB,meanratios,TFsdB,meanratiosCI[2,],lwd=3,col=colpal[3],length=0.05,angle=90)
  points(TFsdB,meanratios, pch = 20+3, col='black', bg=colpal[3], cex=1.6, lwd=3)   
 text(7.5,11,'(c)',adj=0.5,cex=2.5)

dev.off()


  PostScriptTrace('SpecTF.ps')
  p1 <- readPicture('SpecTF.ps.xml')
  PostScriptTrace('TF1.ps')
  p2 <- readPicture('TF1.ps.xml')
  PostScriptTrace('TF2.ps')
  p3 <- readPicture('TF2.ps.xml')
  
    for (n in 1:length(p1@paths)){
    temp <- class(p1@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(p1@paths[n]$path@rgb))<765){p1@paths[n]$path@rgb <- addalpha(p1@paths[n]$path@rgb,alpha=0.2)}}}
  
  pdf(paste0(figdir,"TFdata.pdf"), bg="transparent", height = 12, width = 15)
  par(mar=c(0.1,0.1,0.1,0.1))
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(0,1), ylim=c(0,1))
  
  grid.picture(p1,x=0.3,y=0.5,width=0.6,height=1)
  grid.picture(p2,x=0.78,y=0.74,width=0.4,height=1)
  grid.picture(p3,x=0.78,y=0.26,width=0.4,height=1)

  dev.off()
  
  file.remove(c('TF1.ps','TF2.ps','SpecTF.ps','TF1.ps.xml','TF2.ps.xml','SpecTF.ps.xml'))


}

```

```{r TFdata, fig.cap="Binocular facilitation at different temporal frequencies. Panel (a) shows Fourier spectra for responses to binocular flicker at 5 different frequencies (offset vertically for clarity). Panel (b) shows the response at each stimulation frequency for monocular (red) and binocular (blue) presentation. Panel (c) shows the ratio of binocular to monocular responses. Error bars and shaded regions indicate bootstrapped standard errors across N=12 participants.", fig.align="center", echo=FALSE}

knitr::include_graphics(paste0(figdir,'TFdata.pdf'))

```

## Experiment 3


```{r include=FALSE, results='hide'}

# (download and) analyse individual participant data for the matching experiment

ratiosL <- c(1, 1, 1, 1, 1, 0.75, 0.5, 0.25, 0)
ratiosR <- c(0, 0.25, 0.5, 0.75, 1, 1, 1, 1, 1)

if (processdata > 2){
  
if (!file.exists(paste0(datadir,'matchingdata.csv'))){
osfnode <- 'ey7rg'  
osfproject <- osf_retrieve_node(osfnode)
matchingfiles <- osf_ls_files(osfproject,n_max=300)
fid <- which(matchingfiles$name=='matchingdata.csv')
osf_download(matchingfiles[fid,],datadir,progress=TRUE)
}

matchingdata <- read.csv(paste0(datadir,'matchingdata.csv'))  

levels <- unique(matchingdata$allref)
subjects <- unique(matchingdata$Participant)

allthresh <- array(0,dim=c(length(subjects),length(levels),length(ratiosL)))
for (subj in 1:length(subjects)){
  thissubj <- subset(matchingdata,Participant==subj)  
  levels <- unique(thissubj$allref)
for (cond in 1:length(levels)){
  thiscond <- subset(thissubj,allref==levels[cond])
  contrast <- levels[cond]
  for (ll in 1:length(ratiosL)){
    Lratio <- ratiosL[ll]
    Rratio <- ratiosR[ll]
    thisL <- subset(thiscond, allLratio==Lratio)
    thisdata <- subset(thisL, allRratio==Rratio)
   
Ncorrect <- NULL
Ntrials <- NULL
Clevs <- sort(unique(thisdata$allcontrast))
for (lev in 1:length(Clevs)){
  temp <- subset(thisdata,allcontrast==Clevs[lev])
  Ncorrect[lev] <- sum(temp$correct)
  Ntrials[lev] <- nrow(temp)
}
CdB <- 20*log10(Clevs)
datatofit <- data.frame(CdB,Ncorrect,Ntrials)
fit <- quickpsy::quickpsy(datatofit, x=CdB, k=Ncorrect, n=Ntrials, guess=0, xmin=0, xmax=40, B = 0, fun=cum_normal_fun)
allthresh[subj,cond,ll] <- fit$thresholds$thre

# plot(datatofit$CdB,datatofit$Ncorrect/datatofit$Ntrials)
# points(datatofit$CdB,datatofit$Ncorrect/datatofit$Ntrials,pch=16)
# lines(fit$curves$x,fit$curves$y)

  }
}
}

allthresh[1,2,] <- NA   # exclude outliers
allthresh[2,2,2] <- NA  # exclude outliers
meanthresh <- apply(allthresh,2:3,mean,na.rm=TRUE)
SEthresh <- apply(allthresh,2:3,sd,na.rm=TRUE)/sqrt(apply(!is.na(allthresh),2:3,sum))

save(file=paste0(datadir,'meanmatching.RData'),list=c('meanthresh','SEthresh','allthresh'))

}

if (processdata > 0){
  
  
           if (!file.exists(paste0(datadir,'meanmatching.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '2qu6y'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name=='meanmatching.RData')
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
           }
  
load(paste0(datadir,'meanmatching.RData'))
  
pdf(paste0(figdir,"matchingdata.pdf"), bg="transparent", height = 5.5, width = 5.5)

plotlims <- c(0,125,0,125)  
ticklocs <- seq(0,125,25)   

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   
axis(1, at=ticklocs, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocs, tck=0.01, lab=F, lwd=2)
mtext(text = ticklocs, side = 1, at=ticklocs)     # add the tick labels
mtext(text = ticklocs, side = 2, at=ticklocs, line=0.2, las=1)
title(xlab="Right eye contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
title(ylab="Left eye contrast (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

lines(c(0,24),c(24,24),lty=2)
lines(c(0,48),c(48,48),lty=2)
lines(c(24,24),c(0,24),lty=2)
lines(c(48,48),c(0,48),lty=2)
lines(c(0,96),c(96,0),lty=3)
lines(c(0,48),c(48,0),lty=3)

for (matchlev in 1:2){
lines(ratiosR*10^(meanthresh[matchlev,]/20),ratiosL*10^(meanthresh[matchlev,]/20),pch=16,col=colpal[matchlev],lwd=3)}

# # these lines of code plot the individual participants' data for checking
# for (subj in 1:10){
# for (matchlev in 1:2){
#   lines(ratiosL*10^(allthresh[subj,matchlev,]/20),ratiosR*10^(allthresh[subj,matchlev,]/20),pch=16,col=colpal[matchlev],lwd=1)
# for (cond in 1:9){
#   points(ratiosL[cond]*10^(allthresh[subj,matchlev,cond]/20),ratiosR[cond]*10^(allthresh[subj,matchlev,cond]/20),pch=16,cex=1,col=colpal[matchlev])}}}


for (matchlev in 1:2){
for (cond in 1:9){
  points(ratiosR[cond]*10^(meanthresh[matchlev,cond]/20),ratiosL[cond]*10^(meanthresh[matchlev,cond]/20),pch=16,cex=2,col=colpal[matchlev])
  
  if ((SEthresh[matchlev,cond]+meanthresh[matchlev,cond])<42){
  arrows(ratiosR[cond]*10^(meanthresh[matchlev,cond]/20),ratiosL[cond]*10^(meanthresh[matchlev,cond]/20),ratiosR[cond]*10^((SEthresh[matchlev,cond]+meanthresh[matchlev,cond])/20),ratiosL[cond]*10^((SEthresh[matchlev,cond]+meanthresh[matchlev,cond])/20),length=0.015, angle=90, lwd=2)
  }
  
  # plot as an arrow if exceeding the axis limits
  if ((SEthresh[matchlev,cond]+meanthresh[matchlev,cond])>42){
  arrows(ratiosR[cond]*10^(meanthresh[matchlev,cond]/20),ratiosL[cond]*10^(meanthresh[matchlev,cond]/20),125,ratiosL[cond]*10^((SEthresh[matchlev,cond]+meanthresh[matchlev,cond])/20),length=0.035, angle=45, lwd=2)
  }
  
  arrows(ratiosR[cond]*10^(meanthresh[matchlev,cond]/20),ratiosL[cond]*10^(meanthresh[matchlev,cond]/20),ratiosR[cond]*10^((meanthresh[matchlev,cond]-SEthresh[matchlev,cond])/20),ratiosL[cond]*10^((meanthresh[matchlev,cond]-SEthresh[matchlev,cond])/20),length=0.015, angle=90, lwd=2)
}
}

legend(75,95,c('48% match','24% match'),pch=16,col=colpal[2:1],pt.cex=2,box.lwd=2)

legend(45.75,125,c('Winner-take-all','Linear summation'),lty=2:3,box.lwd=2)

dev.off()

}

```
  
```{r matchingdata, fig.cap="Contrast matching functions. Dotted and dashed lines are predictions of canonical summation models with a linear exponent (dotted) or an infinite exponent (dashed). Error bars indicate the standard error across participants (N=10), and are constrained along radial lines converging at the origin.", fig.align="center", echo=FALSE}

knitr::include_graphics(paste0(figdir,'matchingdata.pdf'))

```

## Computational modelling


```{r include=FALSE, results='hide'}

# create text objects for Stan models

CRFmodelstring = "
  data {
    int<lower=1> Nsubj ;
    int<lower=1> Ntotal ;
    real y[Ntotal] ;
    real x[Ntotal] ;
    real<lower=0> w[Ntotal] ;
    int<lower=1> c[Ntotal] ;
    int<lower=1> s[Ntotal] ;
  }
  parameters {
    real<lower=1> Z[Nsubj] ;
    real<lower=0> Rmax[Nsubj] ;
    real<lower=0> wt[Nsubj] ;
    real<lower=0> k[Nsubj] ;
    real<lower=0> sigma ;
    real<lower=1> Zmu ; 
    real<lower=0> Rmaxmu ; 
    real<lower=0> wtmu ; 
    real<lower=0> kmu ; 
    real<lower=0> Zsigma ;
    real<lower=0> Rmaxsigma ;
    real<lower=0> wtsigma ;
    real<lower=0> ksigma ;
    real<lower=0> nu ;
  }
  model {
    Zmu ~ normal( 5 , 2 ) ;
    Rmaxmu ~ normal( 1 , 0.5 ) ;
    wtmu ~ normal( 1 , 0.5 ) ;
    kmu ~ normal( 5 , 2 ) ;
    sigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    Zsigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    Rmaxsigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    wtsigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    ksigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    nu ~ exponential(1/30.0) ;
    Z ~ normal( Zmu , Zsigma ) ; // vectorized
    Rmax ~ normal( Rmaxmu , Rmaxsigma ) ; // vectorized
    wt ~ normal( wtmu , wtsigma ) ; // vectorized
    k ~ normal( kmu , ksigma ) ; // vectorized
    for ( i in 1:Ntotal ) {
    
    if (c[i]==1)  // monocular condition
       y[i] ~ student_t( 
                nu ,
                k[s[i]] + (Rmax[s[i]]*(pow(x[i],2))/(Z[s[i]] + x[i])) ,
                w[i]*sigma ) ;
                
     else if (c[i]==2)  // binocular condition 
       y[i] ~ student_t( 
                nu ,
                k[s[i]] + (Rmax[s[i]]*((pow(x[i],2))/(Z[s[i]] + x[i] + wt[s[i]]*x[i]) + (pow(x[i],2))/(Z[s[i]] + x[i] + wt[s[i]]*x[i]))),
                w[i]*sigma ) ;   
                
     else if (c[i]==3)  // dichoptic condition
       y[i] ~ student_t( 
                nu ,
                k[s[i]] + (Rmax[s[i]]*((pow(x[i],2))/(Z[s[i]] + x[i] + wt[s[i]]*48) + (pow(48,2))/(Z[s[i]] + 48 + wt[s[i]]*x[i]))),
                w[i]*sigma ) ;  
                
                
     else if (c[i]==4)  // binocular cross condition 
       y[i] ~ student_t( 
                nu ,
                k[s[i]] + (Rmax[s[i]]*(pow(x[i],2))/(Z[s[i]] + x[i] + wt[s[i]]*x[i])) ,
                w[i]*sigma ) ;                  
                
                
     else if (c[i]==5)  // dichoptic cross condition
       y[i] ~ student_t( 
                nu ,
                k[s[i]] + (Rmax[s[i]]*(pow(x[i],2))/(Z[s[i]] + x[i] + wt[s[i]]*48)) ,
                w[i]*sigma ) ;       
    }
  }

  " # close quote for CRFmodelstring


matchingmodelstring = "
  data {
    int<lower=1> Nsubj ;
    int<lower=1> Ntotal ;
    int correct[Ntotal] ;
    real allcontrast[Ntotal] ;
    real allref[Ntotal] ;
    real allLratio[Ntotal] ;
    real allRratio[Ntotal] ;    
    int<lower=1> s[Ntotal] ;
  }
  parameters {
    real<lower=0> Z[Nsubj] ;
    real<lower=0> k[Nsubj] ;
    real<lower=0> w[Nsubj] ;
    real<lower=0> sigma ;
    real<lower=0> Zmu ; 
    real<lower=0> kmu ; 
    real<lower=0> wmu ;     
    real<lower=0> Zsigma ;
    real<lower=0> ksigma ;
    real<lower=0> wsigma ;
    }
  model {
    Zmu ~ normal( 5 , 2 ) ;
    wmu ~ normal( 1 , 0.5 ) ;
    kmu ~ normal( 5 , 2 ) ;
    sigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    Zsigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    ksigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    wsigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    Z ~ normal( Zmu , Zsigma ) ; // vectorized
    k ~ normal( kmu , ksigma ) ; // vectorized
    w ~ normal( wmu , wsigma ) ; // vectorized  

    for ( i in 1:Ntotal ) {
    
      real standresp ;
      real matchrespL ;
      real matchrespR ;
      real matchresp ;
    
      standresp = 2 * pow(allref[i],2) / (Z[s[i]] + allref[i] + w[s[i]]*allref[i]);
      matchrespL = pow(allLratio[i]*allcontrast[i],2) / (Z[s[i]] + allLratio[i]*allcontrast[i] + w[s[i]]*allRratio[i]*allcontrast[i]);
      matchrespR = pow(allRratio[i]*allcontrast[i],2) / (Z[s[i]] + allRratio[i]*allcontrast[i] + w[s[i]]*allLratio[i]*allcontrast[i]);
      matchresp = matchrespL + matchrespR;
      correct[i] ~ bernoulli(((1 + erf((matchresp - standresp)/k[s[i]]))/2)*0.998 + 0.001) ;
    }
  }  
  " # close quote for matchingmodelstring


```

```{r include=FALSE, results='hide'}

# do computational modelling

if (processdata > 1){

# settings for sampler 
numSavedSteps <- 100000    # total number of MCMC steps
adaptSteps <- 1000  # Number of steps to "tune" the samplers
burnInSteps <- 2000 
thinSteps <- 10
nChains <- 8
ncores <- detectCores()/2  # because of multi-threading, this is usually double the true number of physical cores, so we halve the number as Stan can only use physical cores
options(mc.cores=ncores)

if (!file.exists(paste0(datadir,'matchingdata.csv'))){
osfnode <- 'ey7rg'  
osfproject <- osf_retrieve_node(osfnode)
matchingfiles <- osf_ls_files(osfproject,n_max=300)
fid <- which(matchingfiles$name=='matchingdata.csv')
osf_download(matchingfiles[fid,],datadir,progress=TRUE)
}

matchingdata <- read.csv(paste0(datadir,'matchingdata.csv'))  

matchingdatalist = list(correct = matchingdata$correct, allLratio = matchingdata$allLratio, allRratio = matchingdata$allRratio, allcontrast = matchingdata$allcontrast, allref = matchingdata$allref, s = matchingdata$Participant, Nsubj = max(matchingdata$Participant), Ntotal = nrow(matchingdata))

for (participant in 1:30){
         # if the tar file of this participant's data doesn't exist
         if (!file.exists(paste0(datadir,'P',100+participant,'summary.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '2qu6y'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name==paste0('P',100+participant,'summary.RData'))
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
         }
}

d <- dir(datadir,pattern='*summary.RData',full.names=TRUE)

tempmasksP <- array(0,dim=c(length(d),6,5))
tempmeansP <- tempmasksP
tempmasksE <- array(0,dim=c(length(d),64,6,5))
tempmeansE <- tempmasksE
tempmeansE2 <- tempmeansE
tempmasksE2 <- tempmasksE

  for (s in 1:length(d)){
    
    load(d[s])
    
  tempmasksP[s,,] <- cleanmasksP
  tempmeansP[s,,] <- cleanmeansP
  tempmeansE[s,,,] <- cleanmeansE
  tempmasksE[s,,,] <- cleanmasksE
  tempmeansE2[s,,,] <- cleanmeansE2
  tempmasksE2[s,,,] <- cleanmasksE2
    
  }
  electrodeindices <- match(targetelectrodes,electrodes)-2

  # THE DATA
  condlist <- c(1,2,3,5,6)
  contlist <- c(6,12,24,48,96)
  y <- NULL
  x <- NULL
  c <- NULL
  s <- NULL
  w <- NULL
  i <- 0
  for (subj in 1:dim(tempmeansP)[1]){
    for (cond in 1:length(condlist)){
      for (cont in 1:length(contlist)){
        dp <- abs(tempmeansP[subj,condlist[cond],cont])
        if (is.na(dp)==0){
          if (is.infinite(dp)==0){
          i <- i + 1
          x[i] <- contlist[cont]
          y[i] <- dp
          c[i] <- cond
          s[i] <- subj
          w[i] <- 1
          }
        }
      }
    }
  }

pupildatalist = list(x = x, y = y, s = s, w = w, c = c, Nsubj = max(s), Ntotal = length(y))

  y <- NULL
  x <- NULL
  c <- NULL
  s <- NULL
  w <- NULL
  i <- 0
  for (subj in 1:dim(tempmeansE)[1]){
    for (cond in 1:length(condlist)){
      for (cont in 1:length(contlist)){
        dp <- abs(mean(tempmeansE[subj,electrodeindices,condlist[cond],cont]))
        if (is.na(dp)==0){
          if (is.infinite(dp)==0){
            i <- i + 1
            x[i] <- contlist[cont]
            y[i] <- dp
            c[i] <- cond
            s[i] <- subj
            w[i] <- 1
          }
        }
      }
    }
  }
  
  EEG1Fdatalist = list(x = x, y = y, s = s, w = w, c = c, Nsubj = max(s), Ntotal = length(y))
  
  y <- NULL
  x <- NULL
  c <- NULL
  s <- NULL
  w <- NULL
  i <- 0
  for (subj in 1:dim(tempmeansE)[1]){
    for (cond in 1:length(condlist)){
      for (cont in 1:length(contlist)){
        dp <- abs(mean(tempmeansE2[subj,electrodeindices,condlist[cond],cont]))
        if (is.na(dp)==0){
          if (is.infinite(dp)==0){
            i <- i + 1
            x[i] <- contlist[cont]
            y[i] <- dp
            c[i] <- cond
            s[i] <- subj
            w[i] <- 1
          }
        }
      }
    }
  }
  
  EEG2Fdatalist = list(x = x, y = y, s = s, w = w, c = c, Nsubj = max(s), Ntotal = length(y))
  
  
# Translate Stan models to C++ and compile to DSO:
matchingmodel <- stan_model(model_code=matchingmodelstring)  
CRFmodel <- stan_model(model_code=CRFmodelstring)  


# Get MC sample of posterior:
pupilsamples <- sampling(object=CRFmodel, 
                    data = pupildatalist, 
                    chains = nChains,
                    iter = (ceiling(numSavedSteps/nChains)*thinSteps+burnInSteps), 
                    warmup = burnInSteps, 
                    thin = thinSteps,
                    cores = getOption("mc.cores", 1L))

EEG1Fsamples <- sampling(object=CRFmodel, 
                    data = EEG1Fdatalist, 
                    chains = nChains,
                    iter = (ceiling(numSavedSteps/nChains)*thinSteps+burnInSteps), 
                    warmup = burnInSteps, 
                    thin = thinSteps,
                    cores = getOption("mc.cores", 1L))

EEG2Fsamples <- sampling(object=CRFmodel, 
                    data = EEG2Fdatalist, 
                    chains = nChains,
                    iter = (ceiling(numSavedSteps/nChains)*thinSteps+burnInSteps), 
                    warmup = burnInSteps, 
                    thin = thinSteps,
                    cores = getOption("mc.cores", 1L))

matchingsamples <- sampling(object=matchingmodel, 
                    data = matchingdatalist, 
                    chains = nChains,
                    iter = (ceiling(numSavedSteps/nChains)*thinSteps+burnInSteps), 
                    warmup = burnInSteps, 
                    thin = thinSteps,
                    cores = getOption("mc.cores", 1L))

save(file=paste0(datadir,'modeloutput.RData'),list=c('pupilsamples','EEG1Fsamples','EEG2Fsamples','matchingsamples'))

}


```

```{r include=FALSE, results='hide'}

# create figure containing modelling results

if (!file.exists(paste0(datadir,'modeloutput.RData'))){
osfnode <- '2qu6y'  
osfproject <- osf_retrieve_node(osfnode)
osffilesP <- osf_ls_files(osfproject,n_max=300)
fid <- which(osffilesP$name=='modeloutput.RData')
osf_download(osffilesP[fid,],datadir,progress=TRUE)
}

  load(paste0(datadir,'modeloutput.RData'))
  
  
  pupilweightpop <- pupilsamples@sim$samples[[1]]$wtmu
  pupilW <- median(pupilsamples@sim$samples[[1]]$wtmu)
  pupilZ <- median(pupilsamples@sim$samples[[1]]$Zmu)
  pupilK <- median(pupilsamples@sim$samples[[1]]$kmu)
  pupilRmax <- median(pupilsamples@sim$samples[[1]]$Rmaxmu)
  
  EEGweightpop <- EEG1Fsamples@sim$samples[[1]]$wtmu
  EEGW <- median(EEG1Fsamples@sim$samples[[1]]$wtmu)
  EEGZ <- median(EEG1Fsamples@sim$samples[[1]]$Zmu)
  EEGK <- median(EEG1Fsamples@sim$samples[[1]]$kmu)
  EEGRmax <- median(EEG1Fsamples@sim$samples[[1]]$Rmaxmu)
  
  EEG2weightpop <- EEG2Fsamples@sim$samples[[1]]$wtmu
  EEG2W <- median(EEG2Fsamples@sim$samples[[1]]$wtmu)
  EEG2Z <- median(EEG2Fsamples@sim$samples[[1]]$Zmu)
  EEG2K <- median(EEG2Fsamples@sim$samples[[1]]$kmu)
  EEG2Rmax <- median(EEG2Fsamples@sim$samples[[1]]$Rmaxmu)
  
  matchingweightpop <- matchingsamples@sim$samples[[1]]$wmu
  matchingW <- median(matchingsamples@sim$samples[[1]]$wmu)
  matchingZ <- median(matchingsamples@sim$samples[[1]]$Zmu)
  matchingK <- median(matchingsamples@sim$samples[[1]]$kmu)
  
  if (processdata > 0){
    
postscript('posteriors.ps', horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

plotlims <- c(-48,12,0,0.5) 
ticklocsx <- seq(-48,12,12)    
ticklocsy <- seq(0,0.5,0.1)    
ticklabelsx <- c('1/256','1/64','1/16','1/4','1','4')        
ticklabelsy <- ticklocsy    # set labels for y ticks

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)    
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)   
 
title(xlab="w", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
title(ylab="Probability", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

a <- density(20*log10(pupilweightpop),from=-48,to=12)   
polygon(c(-48,a$x,12), c(0,a$y,0), col=colpal[3],border=NA) 

a <- density(20*log10(EEGweightpop),from=-48,to=12)   
polygon(c(-48,a$x,12), c(0,a$y,0), col=colpal[4],border=NA) 

a <- density(20*log10(EEG2weightpop),from=-48,to=12)   
polygon(c(-48,a$x,12), c(0,a$y,0), col=colpal[5],border=NA) 

a <- density(20*log10(matchingweightpop),from=-48,to=12)   
polygon(c(-48,a$x,12), c(0,a$y,0), col=colpal[6],border=NA) 

prior <- dnorm(10^((-48:12)/20),1,0.5)
prior <- 0.3*prior/max(prior)
lines(-48:12,prior)

lines(20*log10(c(mean(pupilW),mean(pupilW))),c(0,0.3),lwd=3,col=colpal[3])
lines(20*log10(c(mean(EEGW),mean(EEGW))),c(0,0.3),lwd=3,col=colpal[4])
lines(20*log10(c(mean(EEG2W),mean(EEG2W))),c(0,0.3),lwd=3,col=colpal[5])
lines(20*log10(c(mean(matchingW),mean(matchingW))),c(0,0.3),lwd=3,col=colpal[6])

legend(-48,0.5,c('Prior','Pupillometry','EEG 1F','EEG 2F','Matching'),col=c('black',colpal[3:6]),lwd=c(1,3,3,3,3),lty=1, box.lwd=2, bg='white')

text(9,0.48,'(i)',cex=1.25,adj=0.5)

dev.off()


finex <- 10^(seq(20*log10(6),20*log10(96),length=100)/20)

w <- pupilW
Z <- pupilZ
k <- pupilRmax
n <- pupilK
q <- 2
modelA <- matrix(0,nrow=6,ncol=length(finex))
modelB <- matrix(0,nrow=6,ncol=length(finex))
# mon condition
R <- 0
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[1,] <- k*(Lresp + Rresp) + n
modelB[1,] <- n

# bin condition
R <- finex
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[2,] <- k*(Lresp + Rresp) + n
modelB[2,] <- n

# dich condition
R <- 48
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[3,] <- k*(Lresp + Rresp) + n
modelB[3,] <- n

# mon X condition
R <- 0
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[4,] <- n
modelB[4,] <- k*(Lresp + Rresp) + n

# bin X condition
R <- finex
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[5,] <- k*(Lresp) + n 
modelB[5,] <- k*(Rresp) + n  

# dich X condition
L <- finex
R <- 48
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[6,] <- k*(Lresp) + n 
modelB[6,] <- k*(Rresp) + n  



contrastsdB <- 20*log10(c(6,12,24,48,96))

plotlims <- c(15,40,0,0.04)
ticklocsx <- contrastsdB    # locations of tick marks on x axis
ticklabelsx <-c(6,12,24,48,96)        # set labels for x ticks
ticklocsy <- seq(0,0.04,0.01)    # locations of tick marks on y axis
ticklabelsy <- ticklocsy    # set labels for y ticks

postscript(paste("CRF1p.ps",sep=''), horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)    
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)    
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
title(xlab="Target contrast (dB)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
title(ylab="Amplitude at 2Hz (mm)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

condlist <- c(1,2,3,6)
for (cond in 1:4){lines(20*log10(finex),modelA[condlist[cond],], col=colpal[condlist[cond]], lwd=3, cex=0.5)}

legend(21,0.04,c('Monocular','Binocular','Dichoptic','Dichoptic cross'),lwd=3,col=colpal[condlist],box.lwd=2)

text(17,0.038,'(e)',adj=0.5,cex=2.5)

dev.off()  


w <- EEGW
Z <- EEGZ
k <- EEGRmax
n <- EEGK
q <- 2
modelA <- matrix(0,nrow=6,ncol=length(finex))
modelB <- matrix(0,nrow=6,ncol=length(finex))
# mon condition
R <- 0
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[1,] <- k*(Lresp + Rresp) + n
modelB[1,] <- n

# bin condition
R <- finex
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[2,] <- k*(Lresp + Rresp) + n
modelB[2,] <- n

# dich condition
R <- 48
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[3,] <- k*(Lresp + Rresp) + n
modelB[3,] <- n

# mon X condition
R <- 0
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[4,] <- n
modelB[4,] <- k*(Lresp + Rresp) + n

# bin X condition
R <- finex
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[5,] <- k*(Lresp) + n 
modelB[5,] <- k*(Rresp) + n  

# dich X condition
L <- finex
R <- 48
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[6,] <- k*(Lresp) + n 
modelB[6,] <- k*(Rresp) + n  

plotlims <- c(15,40,0,0.8)  
ticklocsy <- seq(0,0.8,0.2)    # locations of tick marks on y axis
ticklabelsy <- ticklocsy    # set labels for y ticks

postscript("CRF1e.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)    
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)    
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
title(xlab="Target contrast (dB)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude at 2Hz (µV) ", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

condlist <- c(1,2,3,6)
for (cond in 1:4){lines(20*log10(finex),modelA[condlist[cond],], col=colpal[condlist[cond]], lwd=3, cex=0.5)}

# legend(21,0.8,c('Monocular','Binocular','Dichoptic','Dichoptic cross'),lwd=3,col=colpal[condlist],box.lwd=2)

text(17,0.75,'(f)',adj=0.5,cex=2.5)

dev.off()


w <- EEG2W
Z <- EEG2Z
k <- EEG2Rmax
n <- EEG2K
q <- 2
modelA <- matrix(0,nrow=6,ncol=length(finex))
modelB <- matrix(0,nrow=6,ncol=length(finex))
# mon condition
R <- 0
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[1,] <- k*(Lresp + Rresp) + n
modelB[1,] <- n

# bin condition
R <- finex
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[2,] <- k*(Lresp + Rresp) + n
modelB[2,] <- n

# dich condition
R <- 48
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[3,] <- k*(Lresp + Rresp) + n
modelB[3,] <- n

# mon X condition
R <- 0
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[4,] <- n
modelB[4,] <- k*(Lresp + Rresp) + n

# bin X condition
R <- finex
L <- finex
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[5,] <- k*(Lresp) + n 
modelB[5,] <- k*(Rresp) + n  

# dich X condition
L <- finex
R <- 48
Lresp <- (L^q)/(Z + L + w*R)
Rresp <- (R^q)/(Z + R + w*L)
modelA[6,] <- k*(Lresp) + n 
modelB[6,] <- k*(Rresp) + n  

plotlims <- c(15,40,0,0.8)  
ticklocsy <- seq(0,0.8,0.2)    # locations of tick marks on y axis
ticklabelsy <- ticklocsy    # set labels for y ticks

postscript("CRF2e.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)    
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)    
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
title(xlab="Target contrast (dB)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude at 4Hz (µV) ", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

condlist <- c(1,2,3,6)
for (cond in 1:4){lines(20*log10(finex),modelA[condlist[cond],], col=colpal[condlist[cond]], lwd=3, cex=0.5)}

# legend(21,0.8,c('Monocular','Binocular','Dichoptic','Dichoptic cross'),lwd=3,col=colpal[condlist],box.lwd=2)

text(17,0.75,'(g)',adj=0.5,cex=2.5)

dev.off()



# very finely sampled ratios to produce smooth curves
ratiosL <- seq(0,1,length=100)
ratiosR <- rep(1,100)

params <- c(2,matchingZ,matchingW)

binmodel <- function(L,R,p){
  # this is the two-stage model with a linear denominator and saturation constant
  stage1L <- (L^p[1])/(p[2] + L + p[3]*R)
  stage1R <- (R^p[1])/(p[2] + R + p[3]*L)
  resp <- stage1L + stage1R

  return(resp)}

getmatch <- function(L,R,ratios,p){
  standardresp <- binmodel(L,R,p)
  contrast <- 0
  matchresp <- 0
  while (matchresp<standardresp){
    contrast <- contrast + 0.1
    matchresp <- binmodel(contrast*ratios[1],contrast*ratios[2],p)
  }
  
  return(contrast)}

postscript("matchingmodel.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

plotlims <- c(0,125,0,125)  
ticklocs <- seq(0,125,25)   

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   
axis(1, at=ticklocs, tck=0.01, lab=F, lwd=2)
axis(2, at=ticklocs, tck=0.01, lab=F, lwd=2)
mtext(text = ticklocs, side = 1, at=ticklocs)     # add the tick labels
mtext(text = ticklocs, side = 2, at=ticklocs, line=0.2, las=1)
title(xlab="Right eye contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
title(ylab="Left eye contrast (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

standardcontrast <- 48

matchlist <- NULL
for (n in 1:length(ratiosL)){
  matchlist[n] <- getmatch(standardcontrast,standardcontrast,c(ratiosL[n],ratiosR[n]),params)
}

tempx <- c(matchlist*ratiosL, matchlist[100:1])
tempy <- c(matchlist, matchlist[100:1]*ratiosL[100:1])

lines(tempx,tempy,lwd=3,col=colpal[2])
lines(c(0,standardcontrast),c(standardcontrast,standardcontrast),lty=2)
lines(c(standardcontrast,standardcontrast),c(0,standardcontrast),lty=2)
lines(c(0,2*standardcontrast),c(2*standardcontrast,0),lty=3)

standardcontrast <- 24

matchlist <- NULL
for (n in 1:length(ratiosL)){
  matchlist[n] <- getmatch(standardcontrast,standardcontrast,c(ratiosL[n],ratiosR[n]),params)
}

tempx <- c(matchlist*ratiosL, matchlist[100:1])
tempy <- c(matchlist, matchlist[100:1]*ratiosL[100:1])
lines(tempx,tempy,lwd=3,col=colpal[1])

lines(c(0,standardcontrast),c(standardcontrast,standardcontrast),lty=2)
lines(c(standardcontrast,standardcontrast),c(0,standardcontrast),lty=2)
lines(c(0,2*standardcontrast),c(2*standardcontrast,0),lty=3)

legend(62,95,c('48% match','24% match'),col=colpal[2:1],lwd=3,pt.cex=2,box.lwd=2)

legend(45,125,c('Winner-take-all','Linear summation'),lty=2:3,box.lwd=2)

text(10,117.5,'(h)',adj=0.5,cex=2.5)

dev.off()


contrastsdB <- 20*log10(c(6,12,24,48,96))

         if (!file.exists(paste0(datadir,'Averagedata.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '2qu6y'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name=='Averagedata.RData')
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
         }

load(file=paste0(datadir,'Averagedata.RData'))
 

plotlims <- c(15,40,0,0.03) 
ticklocsx <- contrastsdB    # locations of tick marks on x axis
ticklocsy <- seq(0,0.03,0.01)    # locations of tick marks on y axis
ticklabelsx <-c(6,12,24,48,96)        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

postscript("pdata.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude at 2Hz (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansP[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  points(contrastsdB,abs(cleanmeansP[cond,]), pch = 20+cond, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves
}  
cond <- 6
  lines(contrastsdB,abs(cleanmeansP[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  points(contrastsdB,abs(cleanmeansP[cond,]), pch = 25, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves

legend(21,0.03,c('Monocular','Binocular','Dichoptic','Dichoptic cross'),pch=c(21:23,25),pt.bg=colpal[c(1:3,6)],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.028,'(a)',adj=0.5,cex=2.5)

dev.off()


plotlims <- c(15,40,0,0.8)  
ticklocsx <- contrastsdB    # locations of tick marks on x axis
ticklocsy <- seq(0,0.8,0.2)    # locations of tick marks on y axis
ticklabelsx <-c(6,12,24,48,96)        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

postscript("edata.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude (µV) at 2Hz", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansEav[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  points(contrastsdB,abs(cleanmeansEav[cond,]), pch = 20+cond, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves
}  
cond <- 6
  lines(contrastsdB,abs(cleanmeansEav[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  points(contrastsdB,abs(cleanmeansEav[cond,]), pch = 25, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves

# legend(22,0.8,c('Monocular','Binocular','Dichoptic','Dichoptic cross'),pch=c(21:23,25),pt.bg=colpal[c(1:3,6)],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.75,'(b)',adj=0.5,cex=2.5)

dev.off()

postscript("edata2.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude (µV) at 4Hz", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansE2av[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  points(contrastsdB,abs(cleanmeansE2av[cond,]), pch = 20+cond, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves
}  
cond <- 6
  lines(contrastsdB,abs(cleanmeansE2av[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  points(contrastsdB,abs(cleanmeansE2av[cond,]), pch = 25, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves

# legend(22,0.8,c('Monocular','Binocular','Dichoptic','Dichoptic cross'),pch=c(21:23,25),pt.bg=colpal[c(1:3,6)],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.75,'(c)',adj=0.5,cex=2.5)

dev.off()

         if (!file.exists(paste0(datadir,'meanmatching.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '2qu6y'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name=='meanmatching.RData')
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
         }

load(paste0(datadir,'meanmatching.RData'))
  
postscript("matchingdata.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

plotlims <- c(0,125,0,125)  
ticklocs <- seq(0,125,25)   
ratiosL <- c(1, 1, 1, 1, 1, 0.75, 0.5, 0.25, 0)
ratiosR <- c(0, 0.25, 0.5, 0.75, 1, 1, 1, 1, 1)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   
axis(1, at=ticklocs, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocs, tck=0.01, lab=F, lwd=2)
mtext(text = ticklocs, side = 1, at=ticklocs)     # add the tick labels
mtext(text = ticklocs, side = 2, at=ticklocs, line=0.2, las=1)
title(xlab="Right eye contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
title(ylab="Left eye contrast (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

lines(c(0,24),c(24,24),lty=2)
lines(c(0,48),c(48,48),lty=2)
lines(c(24,24),c(0,24),lty=2)
lines(c(48,48),c(0,48),lty=2)
lines(c(0,96),c(96,0),lty=3)
lines(c(0,48),c(48,0),lty=3)

for (matchlev in 1:2){
lines(ratiosR*10^(meanthresh[matchlev,]/20),ratiosL*10^(meanthresh[matchlev,]/20),pch=16,col=colpal[matchlev],lwd=3)}

for (matchlev in 1:2){
for (cond in 1:9){
  points(ratiosR[cond]*10^(meanthresh[matchlev,cond]/20),ratiosL[cond]*10^(meanthresh[matchlev,cond]/20),pch=16,cex=2,col=colpal[matchlev])
  
  # if ((SEthresh[matchlev,cond]+meanthresh[matchlev,cond])<42){
  # arrows(ratiosR[cond]*10^(meanthresh[matchlev,cond]/20),ratiosL[cond]*10^(meanthresh[matchlev,cond]/20),ratiosR[cond]*10^((SEthresh[matchlev,cond]+meanthresh[matchlev,cond])/20),ratiosL[cond]*10^((SEthresh[matchlev,cond]+meanthresh[matchlev,cond])/20),length=0.015, angle=90, lwd=2)
  # }
  # 
  # # plot as an arrow if exceeding the axis limits
  # if ((SEthresh[matchlev,cond]+meanthresh[matchlev,cond])>42){
  # arrows(ratiosR[cond]*10^(meanthresh[matchlev,cond]/20),ratiosL[cond]*10^(meanthresh[matchlev,cond]/20),125,ratiosL[cond]*10^((SEthresh[matchlev,cond]+meanthresh[matchlev,cond])/20),length=0.035, angle=45, lwd=2)
  # }
  
  # arrows(ratiosR[cond]*10^(meanthresh[matchlev,cond]/20),ratiosL[cond]*10^(meanthresh[matchlev,cond]/20),ratiosR[cond]*10^((meanthresh[matchlev,cond]-SEthresh[matchlev,cond])/20),ratiosL[cond]*10^((meanthresh[matchlev,cond]-SEthresh[matchlev,cond])/20),length=0.015, angle=90, lwd=2)
}
}

text(10,117.5,'(d)',adj=0.5,cex=2.5)

legend(75,95,c('48% match','24% match'),pch=16,col=colpal[2:1],pt.cex=2,box.lwd=2)

legend(45.75,125,c('Winner-take-all','Linear summation'),lty=2:3,box.lwd=2)

dev.off()

  PostScriptTrace('CRF1p.ps')
  p1 <- readPicture('CRF1p.ps.xml')
  PostScriptTrace('CRF1e.ps')
  p2 <- readPicture('CRF1e.ps.xml')
  PostScriptTrace('CRF2e.ps')
  p3 <- readPicture('CRF2e.ps.xml')
  PostScriptTrace('matchingmodel.ps')
  p4 <- readPicture('matchingmodel.ps.xml')
  PostScriptTrace('posteriors.ps')
  p5 <- readPicture('posteriors.ps.xml')
  
  PostScriptTrace('pdata.ps')
  p6 <- readPicture('pdata.ps.xml')
  PostScriptTrace('edata.ps')
  p7 <- readPicture('edata.ps.xml')
  PostScriptTrace('edata2.ps')
  p8 <- readPicture('edata2.ps.xml')
  PostScriptTrace('matchingdata.ps')
  p9 <- readPicture('matchingdata.ps.xml')  
  
    for (n in 1:length(p5@paths)){
    temp <- class(p5@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(p5@paths[n]$path@rgb))<765){p5@paths[n]$path@rgb <- addalpha(p5@paths[n]$path@rgb,alpha=0.2)}}}

  
  pdf(paste0(figdir,"modelfigure.pdf"), bg="transparent", height = 10, width = 30)
  par(mar=c(0.1,0.1,0.1,0.1))
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(0,1), ylim=c(0,1))
  

  grid.picture(p1,x=1/12,y=0.25,width=1/6,height=1)
  grid.picture(p2,x=3/12,y=0.25,width=1/6,height=1)
  grid.picture(p3,x=5/12,y=0.25,width=1/6,height=1)
  grid.picture(p4,x=7/12,y=0.25,width=1/6,height=1)

  grid.picture(p5,x=5/6,y=0.5,width=1/3,height=1)

  grid.picture(p6,x=1/12,y=0.75,width=1/6,height=1)
  grid.picture(p7,x=3/12,y=0.75,width=1/6,height=1)
  grid.picture(p8,x=5/12,y=0.75,width=1/6,height=1)
  grid.picture(p9,x=7/12,y=0.75,width=1/6,height=1)
  
    
  dev.off()
  
  file.remove(c('CRF1e.ps','CRF2e.ps','CRF1p.ps','matchingmodel.ps','matchingdata.ps','pdata.ps','edata.ps','edata2.ps','posteriors.ps'))
  file.remove(c('CRF1e.ps.xml','CRF2e.ps.xml','CRF1p.ps.xml','matchingmodel.ps.xml','matchingdata.ps.xml','pdata.ps.xml','edata.ps.xml','edata2.ps.xml','posteriors.ps.xml'))



}

```

```{r modelfigure, fig.cap="Summary of computational modelling. Panels (a-d) show model behaviour for our four main data set, pupillometry (a), first harmonic EEG responses (b), second harmonic EEG responses (c) and contrast matching (d). Panel (e) shows the posterior probability distributions of the interocular suppression parameter for each of the four model fits. The pupillometry distribution (green) is centred about a substantially higher suppressive weight than for the other data types (note the logarithmic x-axis). The black curve shows the (scaled) prior distribution for the weight parameter.", fig.align="center", echo=FALSE}

knitr::include_graphics(paste0(figdir,'modelfigure.pdf'))

```

```{r paramtable, echo=FALSE}

exptnames <- c('Pupillometry','EEG 1F', 'EEG 2F', 'Matching')
zlist <- c(pupilZ,EEGZ,EEG2Z,matchingZ)
klist <- c(pupilK,EEGK,EEG2K,matchingK)
wlist <- c(pupilW,EEGW,EEG2W,matchingW)
Rlist <- c(round(c(pupilRmax,EEGRmax,EEG2Rmax),5),'-')
tabledata <- data.frame(exptnames,round(zlist,digits=2),round(klist,digits=2),round(wlist,digits=2),Rlist)

colnames(tabledata) <- c('Data set','Z','k','w','Rmax')
kable(tabledata, align='lcccc',caption = 'Summary of median parameter values.') 

```


# Discussion

# References
